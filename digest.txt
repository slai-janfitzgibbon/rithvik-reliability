Directory structure:
└── rithvik-reliability/
    ├── README.md
    ├── Test_flow.py
    ├── data_manager.py
    ├── health_check.py
    ├── interactive_test_system.py
    ├── run_test.py
    ├── test.py
    ├── drivers/
    │   ├── TLPMX.py
    │   ├── __init__.py
    │   ├── dfb13tk.py
    │   ├── pm101.py
    │   ├── smu.py
    │   ├── tti_qlp355.py
    │   └── __pycache__/
    ├── tests/
    │   ├── TLPMX.py
    │   ├── __init__.py
    │   ├── debug_thorlabs_devices.py
    │   ├── test_smu.py
    │   └── test_thorlabs_pm.py
    └── utils/
        ├── recorder.py
        └── __pycache__/

================================================
File: README.md
================================================
# FAU Production Test System

Professional automated test system for FAU (Fiber Array Unit) device characterization and production testing.

## Quick Start

```bash
python run_test.py
```

## System Components

### Main Scripts

#### `run_test.py` - System Launcher
Main entry point for all test operations. Provides menu-driven interface to access different test modes.

**Usage:**
```bash
python run_test.py
```

**Options:**
1. Interactive Test System (Recommended for operators)
2. Direct Test Flow (Preset parameters)
3. Exit

#### `interactive_test_system.py` - Interactive Test Interface
Comprehensive test interface with guided setup and session management.

**Features:**
- Step-by-step test configuration
- Device ID and operator tracking
- Configurable data saving preferences
- Test history and session persistence
- Real-time test monitoring
- Automatic instrument connection management

**Key Functions:**
- `setup_session()` - Configure test session parameters
- `setup_instruments()` - Connect and verify all instruments
- `run_test_sequence()` - Execute complete test flow
- `display_results()` - Show test results and analysis

#### `customer_test_flow.py` - Direct Test Implementation
Direct API for programmatic test execution with preset parameters.

**Usage:**
```python
from customer_test_flow import ProductionTestFlow

test_flow = ProductionTestFlow()
test_flow.connect_instruments()

# Configure test parameters
test_info = {
    "device_id": "FAU_001",
    "operator": "ProductionUser",
    "test_date": "2024-01-01"
}

env_info = {
    "environment_temp": 22.0,
    "environment_humidity": 45.0
}

# Execute test
success = test_flow.execute_test_sequence(
    device_count=2,
    test_info=test_info,
    env_info=env_info
)
```

**Key Methods:**
- `connect_instruments()` - Initialize all hardware connections
- `execute_test_sequence()` - Run complete test procedure
- `cleanup()` - Safe shutdown and resource cleanup

#### `health_check.py` - System Health Validation
Comprehensive health check for all instruments and system components.

**Usage:**
```bash
# Quick connectivity test
python health_check.py --quick

# Full system validation with detailed output
python health_check.py --verbose

# Export results to file
python health_check.py --export health_report.json

# Use custom configuration
python health_check.py --config custom_config.json
```

**Test Coverage:**
- DFB laser connectivity and safety state
- Power meter communication and calibration
- SMU output safety and measurement capability
- Power supply channel states and safety
- All instrument identification and error states

**Output Formats:**
- Console summary with pass/fail status
- JSON export for automated monitoring
- Detailed verbose logging for troubleshooting

### Utility Modules

#### `data_manager.py` - Data Management Utilities
Simple data saving and organization system.

**Key Classes:**
- `DataSavingPreferences` - Basic configuration for data export
- `DataManager` - Main data management interface

**Features:**
- Core data always saved (CSV measurements, JSON parameters, TXT logs)
- Optional PNG plots and additional JSON exports
- Date-based directory organization
- Simple preset system (minimal, standard)

**Usage:**
```python
from data_manager import DataManager, DataSavingPreferences

manager = DataManager()
preferences = manager.select_preset()  # Interactive setup
paths = manager.create_data_structure("DEVICE_001")
```

### Hardware Drivers

#### `drivers/dfb13tk.py` - DFB Laser Control
Controls DFB13TK 1310nm laser with temperature and current regulation.

**Connection:** Serial RS-232 (COM3, 9600 baud)
**Key Methods:**
- `laser_on()/laser_off()` - Laser output control
- `set_current(mA)/get_current()` - Current control (0-450mA)
- `set_temperature(Â°C)/get_temperature()` - Temperature control (15-35Â°C)
- `get_status()` - Complete instrument status

#### `drivers/pm101.py` - Thorlabs Power Meters
Universal driver for Thorlabs optical power meters with dual driver support.

**Connection:** USB via VISA or native TLPMX
**Key Methods:**
- `read_power()/read_power_dbm()` - Power measurements
- `set_wavelength(nm)` - Measurement wavelength
- `set_auto_range()` - Auto-ranging control
- `get_calibration_message()` - Calibration information

#### `drivers/smu.py` - Source Measure Units
Controls Aim-TTi SMU4000 series for precision source-measure operations.

**Connection:** USB/Ethernet VISA
**Key Methods:**
- `set_mode_source_voltage()/set_mode_source_current()` - Operating mode
- `enable_output()/get_output_state()` - Output control
- `measure_voltage()/measure_current()` - Measurements
- `get_errors()/clear_errors()` - Error management

#### `drivers/tti_qlp355.py` - Power Supplies
Controls TTi QL355TP dual-channel precision power supplies.

**Connection:** USB/Ethernet VISA
**Key Methods:**
- `set_voltage(channel, V)/set_current_limit(channel, A)` - Channel control
- `enable_output(channel)/get_output_state(channel)` - Output management
- `get_output_voltage(channel)/get_output_current(channel)` - Measurements
- `measure_channel_all(channel)` - Complete channel status

## Test Procedures

### FAU Alignment Test (< 4 Elements)
1. Sample placement and probe contact
2. IV sweep characterization (SMU1: 0-5V, 0.1V steps)
3. Laser power sweep (15-35mA, 0.2mA steps)
4. Dual channel power monitoring (PM1/PM2)
5. Data analysis and reporting

### Laser Characterization Test (â‰¥ 4 Elements)
1. Sample placement and probe contact
2. Direct laser power sweep (skip IV alignment)
3. Dual channel power monitoring
4. Data analysis and reporting

## Hardware Configuration

### Production Instrument Addresses
```python
INSTRUMENTS = {
    'SMU1': 'TCPIP::10.11.83.58::INSTR',
    'SMU2': 'TCPIP::10.11.83.60::INSTR',
    'PSU1': 'TCPIP::10.11.83.57::INSTR',
    'PSU2': 'TCPIP::10.11.83.52::INSTR',
    'PM1': 'USB0::0x1313::0x8076::M01250277::0::INSTR',
    'PM2': 'USB0::0x1313::0x8076::M01250278::0::INSTR',
    'LASER': 'COM3'
}
```

## Data Management

### Default Data Structure
```
test_data/
â”œâ”€â”€ {date}/                    # Optional date folders (YYYY-MM-DD)
â”‚   â””â”€â”€ {device_id}/
â”‚       â”œâ”€â”€ raw_measurements.csv
â”‚       â”œâ”€â”€ test_parameters.json
â”‚       â”œâ”€â”€ session_log.txt
â”‚       â””â”€â”€ plots/             # Optional plots folder
â”‚           â”œâ”€â”€ iv_sweep.png
â”‚           â””â”€â”€ power_sweep.png
```

### Data Export Formats
- **CSV**: Raw measurement data (always saved)
- **JSON**: Test parameters and results (always saved)
- **TXT**: Session logs (always saved)
- **PNG**: Analysis plots (optional)

## Safety Features

### Automatic Safety Systems
- Laser automatically disabled after each test
- SMU compliance limits enforced (10mA default)
- Power supply outputs disabled on startup/shutdown
- Error handling with safe instrument shutdown
- Connection monitoring with timeout protection

### Manual Safety Controls
- Emergency stop capability in all test modes
- Manual instrument disable commands
- Real-time status monitoring
- Error state detection and reporting

## System Requirements

### Dependencies
- Python 3.7+
- PyVISA (for VISA instrument communication)
- NumPy (for data processing)
- Matplotlib (for plotting)
- Serial communication libraries

### Hardware Requirements
- Windows/Linux system with USB and serial ports
- VISA-compatible instrument drivers
- Network access for Ethernet instruments

## Troubleshooting

### Common Issues
1. **Instrument Connection Failures**
   - Run health check: `python health_check.py --verbose`
   - Verify instrument addresses in configuration
   - Check USB/network connections

2. **VISA Driver Issues**
   - Install National Instruments VISA Runtime
   - Verify instrument appears in NI MAX (Windows)

3. **Laser Communication**
   - Verify COM port assignment (Windows Device Manager)
   - Check serial cable connections
   - Ensure proper baud rate (9600)

4. **Data Saving Issues**
   - Check directory permissions
   - Verify disk space availability
   - Review data manager configuration

### Diagnostic Tools
- `health_check.py` - Complete system validation
- Session logs in `./session_data.json`
- Individual driver test functions
- VISA instrument identification tools

## API Documentation

### ProductionTestFlow Class
Main test execution interface for programmatic control.

**Methods:**
- `connect_instruments()` - Initialize all hardware
- `execute_test_sequence(device_count, test_info, env_info)` - Run tests
- `get_test_results()` - Retrieve measurement data
- `cleanup()` - Safe system shutdown

### DataManager Class
Configurable data management system.

**Methods:**
- `select_preset()` - Interactive configuration (minimal/standard)
- `create_data_structure(device_id)` - Setup directories
- `get_save_summary(paths)` - Generate save plan
- `save_preferences(filename)` - Store configuration

## Support

For technical assistance:
1. Run system health check first
2. Review instrument connections and addresses  
3. Check session logs and error messages
4. Contact system administrator for hardware issues

## Version Information

**System Status:** Production Ready
- All drivers cleaned and validated
- Safety systems implemented and tested
- Complete documentation and API
- Health monitoring and diagnostics
- Comprehensive error handling


================================================
File: Test_flow.py
================================================

import logging
from typing import Dict, Any
from drivers import MultiInstrumentManager
from utils.recorder import UniversalRecorder

class ProductionTestFlow:
    def __init__(self):
        self.manager = MultiInstrumentManager()
        self.recorder = UniversalRecorder('./production_data')
        self.instruments = {}
        
    def connect_instruments(self) -> bool:
        connections = {
            'SMU1': ('smu', 'TCPIP::10.11.83.58::INSTR'),
            'SMU2': ('smu', 'TCPIP::10.11.83.60::INSTR'),
            'PSU1': ('psu', 'TCPIP::10.11.83.57::INSTR'),
            'PSU2': ('psu', 'TCPIP::10.11.83.52::INSTR'),
            'PM1': ('thorlabs_pm', 'USB0::0x1313::0x8076::M01250277::0::INSTR'),
            'PM2': ('thorlabs_pm', 'USB0::0x1313::0x8076::M01250278::0::INSTR'),
            'LASER': ('dfb13tk', 'COM3')
        }
        
        for unit_id, (driver_type, address) in connections.items():
            if self.manager.add_instrument(unit_id, driver_type, address):
                self.instruments[unit_id] = self.manager.get_instrument(unit_id)
        
        return len(self.instruments) >= 4
    
    def fau_alignment_iv_sweep(self, device_count: int) -> bool:
        if device_count >= 4:
            return True
            
        smu = self.instruments.get('SMU1')
        if not smu:
            return False
            
        smu.set_mode_source_voltage()
        smu.set_current_limit(0.01)
        smu.enable_output(True)
        
        measurements = []
        for voltage in [v * 0.1 for v in range(51)]:  # 0 to 5V, 0.1V steps
            smu.set_source_voltage(voltage)
            measurement = smu.measure_all()
            measurements.append(measurement)
        
        smu.enable_output(False)
        return len(measurements) > 0
    
    def laser_power_sweep(self, start_current_ma: float = 15.0, max_current_ma: float = 35.0) -> Dict[str, Any]:
        laser = self.instruments.get('LASER')
        pm1 = self.instruments.get('PM1')
        pm2 = self.instruments.get('PM2')
        
        if not all([laser, pm1, pm2]):
            return {}
        
        laser.set_temperature(25.0)
        laser.wait_temperature_stable(timeout=30)
        laser.laser_on()
        
        pm1.set_wavelength(1310)
        pm1.set_power_unit("W")
        pm1.set_auto_range(True)
        
        pm2.set_wavelength(1310)
        pm2.set_power_unit("W")
        pm2.set_auto_range(True)
        
        measurements = []
        current_ma = start_current_ma
        
        while current_ma <= max_current_ma:
            laser.set_current(current_ma)
            
            laser_measurement = laser.measure_all()
            pm1_measurement = pm1.measure_all('PM1')
            pm2_measurement = pm2.measure_all('PM2')
            
            combined_data = {
                'current_ma': current_ma,
                'laser_wavelength_nm': laser_measurement.wavelength_nm,
                'laser_power_mw': laser_measurement.estimated_power_mw,
                'channel3_power_w': pm1_measurement.power_w,
                'channel3_power_mw': pm1_measurement.power_mw,
                'channel4_power_w': pm2_measurement.power_w,
                'channel4_power_mw': pm2_measurement.power_mw,
                'timestamp': laser_measurement.timestamp
            }
            
            measurements.append(combined_data)
            current_ma += 0.2
        
        laser.laser_off()
        return {'measurements': measurements, 'success': True}
    
    def execute_test_sequence(self, device_count: int, test_info: Dict, env_info: Dict) -> bool:
        self.recorder.test_run_start(
            workstation=test_info.get('workstation', 'Station1'),
            dut_family=test_info.get('dut_family', 'FAU'),
            dut_batch=test_info.get('dut_batch', 'B001'),
            dut_lot=test_info.get('dut_lot', 'L001'),
            dut_wafer=test_info.get('dut_wafer', 'W001'),
            dut_id=test_info.get('dut_id', 'DUT001'),
            run_set_id=test_info.get('run_set_id', 1),
            run_id=test_info.get('run_id', 1)
        )
        
        if device_count < 4:
            self.recorder.phase_start(1, "FAU_Alignment")
            alignment_success = self.fau_alignment_iv_sweep(device_count)
            self.recorder.phase_end()
            
            if not alignment_success:
                self.recorder.run_end()
                return False
        
        self.recorder.phase_start(2, "Laser_Power_Sweep")
        sweep_results = self.laser_power_sweep()
        
        if sweep_results.get('success'):
            import pandas as pd
            df = pd.DataFrame(sweep_results['measurements'])
            
            result = self.recorder.record_complete_dataset(
                name='laser_power_characterization',
                data=df,
                test_info=test_info,
                environment_info=env_info,
                testing_variable="current_ma",
                dependent_variables=["channel3_power_mw", "channel4_power_mw", "laser_wavelength_nm"],
                equipment_ids="LASER, PM1, PM2"
            )
            
            self.recorder.phase_end()
            self.recorder.run_end()
            return result is not None
        
        self.recorder.phase_end()
        self.recorder.run_end()
        return False
    
    def disconnect_all(self):
        self.manager.disconnect_all()

def run_customer_test():
    test_flow = ProductionTestFlow()
    
    if not test_flow.connect_instruments():
        logging.error("Failed to connect required instruments")
        return False
    
    test_info = {
        "test_name": "FAU_Production_Test",
        "test_location": "Production_Line",
        "test_user": "Operator",
        "workstation": "TestStation_1",
        "dut_family": "FAU_Device",
        "dut_batch": "PROD_BATCH_001",
        "dut_lot": "LOT_001",
        "dut_wafer": "W001",
        "dut_id": "FAU_001"
    }
    
    env_info = {
        "environment_temp": 22.0,
        "environment_humidity": 45.0
    }
    
    device_count = 2  # Set based on actual device configuration
    
    try:
        success = test_flow.execute_test_sequence(device_count, test_info, env_info)
        return success
    finally:
        test_flow.disconnect_all()

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    success = run_customer_test()
    exit(0 if success else 1)


================================================
File: data_manager.py
================================================

import os
import json
from datetime import datetime
from typing import Dict, List, Any
from dataclasses import dataclass

@dataclass
class DataSavingPreferences:
    """Simple data saving preferences"""
    save_raw_measurements: bool = True  # Always enabled
    save_test_parameters: bool = True   # Always enabled
    save_session_log: bool = True       # Always enabled
    
    save_plots: bool = True
    export_json: bool = True
    
    create_date_folders: bool = True
    base_directory: str = "./test_data"

class DataManager:
    
    def __init__(self, preferences: DataSavingPreferences = None):
        self.preferences = preferences or DataSavingPreferences()
        
    def get_user_preferences(self) -> DataSavingPreferences:
        print("\n" + "="*50)
        print("DATA SAVING PREFERENCES")
        print("="*50)
        
        print("Core data (measurements, parameters, logs) is always saved.")
        print("Configure optional outputs below:\n")
        
        self.preferences.save_plots = self._get_yes_no(
            "Generate analysis plots?", self.preferences.save_plots
        )
        
        self.preferences.export_json = self._get_yes_no(
            "Export additional JSON files?", self.preferences.export_json
        )
        
        self.preferences.create_date_folders = self._get_yes_no(
            "Organize data by date folders?", self.preferences.create_date_folders
        )
        
        new_dir = input(f"Data directory [{self.preferences.base_directory}]: ").strip()
        if new_dir:
            self.preferences.base_directory = new_dir
        
        self._show_preferences_summary()
        
        return self.preferences
    
    def _get_yes_no(self, prompt: str, default: bool) -> bool:
        default_str = "y" if default else "n"
        response = input(f"  {prompt} (y/n) [{default_str}]: ").strip().lower()
        
        if not response:
            return default
        
        return response in ['y', 'yes', '1', 'true']
    
    def _show_preferences_summary(self):
        print("\n" + "="*50)
        print("DATA SAVING SUMMARY")
        print("="*50)
        
        print("ALWAYS SAVED:")
        print("   - Raw measurements (CSV)")
        print("   - Test parameters (JSON)")
        print("   - Session logs (TXT)")
        
        print("\nOPTIONAL OUTPUTS:")
        print(f"   - Analysis plots: {'Yes' if self.preferences.save_plots else 'No'}")
        print(f"   - Additional JSON: {'Yes' if self.preferences.export_json else 'No'}")
        
        print(f"\nSTORAGE:")
        print(f"   - Location: {self.preferences.base_directory}")
        print(f"   - Date folders: {'Yes' if self.preferences.create_date_folders else 'No'}")
        
    def get_data_directory(self, device_id: str, timestamp: str = None) -> str:
        base_dir = self.preferences.base_directory
        
        if self.preferences.create_date_folders:
            if timestamp:
                date_obj = datetime.fromisoformat(timestamp)
                date_folder = date_obj.strftime("%Y-%m-%d")
            else:
                date_folder = datetime.now().strftime("%Y-%m-%d")
            base_dir = os.path.join(base_dir, date_folder)
        
        device_dir = os.path.join(base_dir, device_id)
        
        return device_dir
    
    def save_preferences(self, filename: str = "./data_preferences.json"):
        try:
            import dataclasses
            prefs_dict = dataclasses.asdict(self.preferences)
            with open(filename, 'w') as f:
                json.dump(prefs_dict, f, indent=2)
            print(f"Preferences saved to {filename}")
        except Exception as e:
            print(f"Could not save preferences: {e}")
    
    def load_preferences(self, filename: str = "./data_preferences.json") -> bool:
        try:
            if os.path.exists(filename):
                with open(filename, 'r') as f:
                    prefs_dict = json.load(f)
                
                for key, value in prefs_dict.items():
                    if hasattr(self.preferences, key):
                        setattr(self.preferences, key, value)
                
                print(f"Preferences loaded from {filename}")
                return True
        except Exception as e:
            print(f"Could not load preferences: {e}")
        
        return False
    
    def get_quick_presets(self) -> Dict[str, DataSavingPreferences]:
        presets = {
            "minimal": DataSavingPreferences(
                save_plots=False,
                export_json=False,
                create_date_folders=False
            ),
            "standard": DataSavingPreferences(
                save_plots=True,
                export_json=True,
                create_date_folders=True
            )
        }
        
        return presets
    
    def select_preset(self) -> DataSavingPreferences:
        presets = self.get_quick_presets()
        
        print("\n" + "="*40)
        print("DATA SAVING PRESETS")
        print("="*40)
        
        print("1. Minimal  - Core data only (CSV)")
        print("2. Standard - Core data + plots + JSON")  
        print("3. Custom   - Configure manually")
        
        choice = input("\nSelect preset [2]: ").strip()
        
        if choice == "1":
            self.preferences = presets["minimal"]
            print("Using Minimal preset")
        elif choice == "3":
            return self.get_user_preferences()
        else:  # Default to standard
            self.preferences = presets["standard"]
            print("Using Standard preset")
        
        self._show_preferences_summary()
        return self.preferences
    
    def create_data_structure(self, device_id: str, timestamp: str = None) -> Dict[str, str]:
        base_dir = self.get_data_directory(device_id, timestamp)
        
        os.makedirs(base_dir, exist_ok=True)
        
        paths = {"base": base_dir}
        
        if self.preferences.save_plots:
            plots_dir = os.path.join(base_dir, "plots")
            os.makedirs(plots_dir, exist_ok=True)
            paths["plots"] = plots_dir
        
        return paths
    
    def get_save_summary(self, paths: Dict[str, str]) -> str:
        summary = []
        base_dir = paths["base"]
        
        summary.append("DATA SAVING PLAN:")
        summary.append(f"   Directory: {base_dir}")
        
        summary.append("\nFiles to be saved:")
        summary.append("   - Raw measurements (CSV)")
        summary.append("   - Test parameters (JSON)") 
        summary.append("   - Session log (TXT)")
        
        if self.preferences.save_plots:
            summary.append("   - Analysis plots (PNG)")
        
        if self.preferences.export_json:
            summary.append("   - Additional JSON exports")
        
        return "\n".join(summary)

def test_data_manager():
    print("Data Manager Test")
    print("="*50)
    
    manager = DataManager()
    
    if manager.load_preferences():
        print("Using saved preferences")
    else:
        print("No saved preferences found, using defaults")
    
    manager._show_preferences_summary()
    
    device_id = "DEVICE_001"
    
    paths = manager.create_data_structure(device_id)
    print(f"\nCreated directory structure:")
    for key, path in paths.items():
        print(f"  {key}: {path}")
    
    summary = manager.get_save_summary(paths)
    print(f"\n{summary}")

if __name__ == "__main__":
    test_data_manager()


================================================
File: health_check.py
================================================

import sys
import time
import json
import argparse
from datetime import datetime
from typing import Dict, List
from contextlib import contextmanager

from drivers.dfb13tk import DFB13TK
from drivers.pm101 import ThorlabsPowerMeter
from drivers.smu import AimTTi_SMU4000
from drivers.tti_qlp355 import TTi_QL355TP

class HealthCheckResult:
    def __init__(self, name: str, success: bool = False, message: str = "", details: Dict = None):
        self.name = name
        self.success = success
        self.message = message
        self.details = details or {}
        self.timestamp = datetime.now()

class InstrumentHealthChecker:
    
    def __init__(self, config: Dict = None, verbose: bool = False):
        self.verbose = verbose
        self.results: List[HealthCheckResult] = []
        self.config = config or self._get_default_config()
        
    def _get_default_config(self) -> Dict:
        return {
            'instruments': {
                'SMU1': {
                    'driver': 'smu',
                    'address': 'TCPIP::10.11.83.58::INSTR',
                    'unit_id': 'SMU1',
                    'timeout': 10.0
                },
                'SMU2': {
                    'driver': 'smu', 
                    'address': 'TCPIP::10.11.83.60::INSTR',
                    'unit_id': 'SMU2',
                    'timeout': 10.0
                },
                'PSU1': {
                    'driver': 'psu',
                    'address': 'TCPIP::10.11.83.57::INSTR', 
                    'unit_id': 'PSU1',
                    'timeout': 5.0
                },
                'PSU2': {
                    'driver': 'psu',
                    'address': 'TCPIP::10.11.83.52::INSTR',
                    'unit_id': 'PSU2', 
                    'timeout': 5.0
                },
                'PM1': {
                    'driver': 'pm',
                    'address': 'USB0::0x1313::0x8076::M01250277::0::INSTR',
                    'unit_id': 'PM1',
                    'channel': 3
                },
                'PM2': {
                    'driver': 'pm',
                    'address': 'USB0::0x1313::0x8076::M01250278::0::INSTR', 
                    'unit_id': 'PM2',
                    'channel': 4
                },
                'LASER': {
                    'driver': 'laser',
                    'address': 'COM3',
                    'timeout': 5.0
                }
            },
            'test_parameters': {
                'laser_safe_current': 150.0,  # mA
                'laser_safe_temp': 25.0,      # Â°C
                'pm_wavelength': 1310,        # nm
                'smu_test_voltage': 1.0,      # V
                'psu_test_voltage': 3.3,      # V
                'psu_test_current': 0.1       # A
            }
        }
    
    def log(self, message: str):
        if self.verbose:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] {message}")
    
    def add_result(self, name: str, success: bool, message: str, details: Dict = None):
        result = HealthCheckResult(name, success, message, details)
        self.results.append(result)
        return result
    
    @contextmanager
    def safe_instrument_context(self, instrument_class, *args, **kwargs):
        instrument = None
        try:
            instrument = instrument_class(*args, **kwargs)
            yield instrument
        except Exception as e:
            self.log(f"Failed to initialize {instrument_class.__name__}: {e}")
            raise
        finally:
            if instrument and hasattr(instrument, 'close'):
                try:
                    instrument.close()
                except:
                    pass
            elif instrument and hasattr(instrument, 'disconnect'):
                try:
                    instrument.disconnect()
                except:
                    pass
    
    def test_dfb_laser(self, config: Dict) -> HealthCheckResult:
        """Test DFB laser connectivity and basic functions."""
        self.log("Testing DFB laser...")
        
        try:
            with self.safe_instrument_context(DFB13TK, config['address']) as laser:
                serial_num = laser.get_serial_number()
                firmware = laser.get_firmware_version()
                
                laser_state = laser.get_laser_state()
                current = laser.get_current()
                temperature = laser.get_temperature()
                
                test_temp = self.config['test_parameters']['laser_safe_temp']
                laser.set_temperature(test_temp)
                
                if laser_state == 60:  # Laser is ON
                    laser.laser_off()
                    time.sleep(0.5)
                    laser_state = laser.get_laser_state()
                
                details = {
                    'serial_number': serial_num,
                    'firmware': firmware,
                    'laser_state': 'ON' if laser_state == 60 else 'OFF',
                    'current_ma': current,
                    'temperature_c': temperature,
                    'temperature_set_c': test_temp
                }
                
                success = laser_state == 61  # OFF state
                message = f"DFB laser functional (S/N: {serial_num}, FW: {firmware})"
                if not success:
                    message = f"WARNING: Laser state is ON - turned OFF for safety"
                
                return self.add_result("DFB_LASER", success, message, details)
                
        except Exception as e:
            return self.add_result("DFB_LASER", False, f"Failed: {e}")
    
    def test_power_meter(self, name: str, config: Dict) -> HealthCheckResult:
        """Test power meter connectivity and basic functions."""
        self.log(f"Testing power meter {name}...")
        
        try:
            with self.safe_instrument_context(ThorlabsPowerMeter, config['address'], True, config['unit_id']) as pm:
                idn = pm.get_idn()
                
                wavelength = self.config['test_parameters']['pm_wavelength']
                pm.set_wavelength(wavelength)
                
                power_w = pm.read_power()
                power_dbm = pm.read_power_dbm()
                
                cal_msg = pm.get_calibration_message()
                
                status = pm.get_status()
                
                details = {
                    'identification': idn,
                    'wavelength_nm': wavelength,
                    'power_w': power_w,
                    'power_dbm': power_dbm,
                    'calibration': cal_msg,
                    'channel': config.get('channel', 'N/A'),
                    'status': status
                }
                
                success = True
                message = f"Power meter {name} functional ({idn})"
                
                return self.add_result(f"POWER_METER_{name}", success, message, details)
                
        except Exception as e:
            return self.add_result(f"POWER_METER_{name}", False, f"Failed: {e}")
    
    def test_smu(self, name: str, config: Dict) -> HealthCheckResult:
        """Test SMU connectivity and basic functions."""
        self.log(f"Testing SMU {name}...")
        
        try:
            with self.safe_instrument_context(AimTTi_SMU4000, config['address'], config['unit_id']) as smu:
                idn = smu.get_idn()
                
                errors = smu.get_errors()
                if errors:
                    smu.clear_errors()
                
                smu.set_mode_source_voltage()
                mode = smu.get_source_mode()
                
                output_state = smu.get_output_state()
                
                voltage = smu.measure_voltage()
                current = smu.measure_current()
                
                status = smu.get_status()
                
                details = {
                    'identification': idn,
                    'source_mode': mode,
                    'output_enabled': output_state,
                    'voltage_v': voltage,
                    'current_a': current,
                    'errors_cleared': len(errors) if errors else 0,
                    'status': status
                }
                
                success = not output_state  # Output should be disabled
                message = f"SMU {name} functional ({idn.split(',')[1].strip()} if available)"
                if output_state:
                    message = f"WARNING: SMU {name} output was enabled - disabled for safety"
                
                return self.add_result(f"SMU_{name}", success, message, details)
                
        except Exception as e:
            return self.add_result(f"SMU_{name}", False, f"Failed: {e}")
    
    def test_psu(self, name: str, config: Dict) -> HealthCheckResult:
        """Test power supply connectivity and basic functions."""
        self.log(f"Testing PSU {name}...")
        
        try:
            with self.safe_instrument_context(TTi_QL355TP, config['address'], config['unit_id']) as psu:
                idn = psu.get_idn()
                
                ch1_state = psu.get_output_state(1)
                ch2_state = psu.get_output_state(2)
                
                ch1_voltage = psu.get_set_voltage(1)
                ch2_voltage = psu.get_set_voltage(2)
                ch1_current = psu.get_set_current_limit(1)
                ch2_current = psu.get_set_current_limit(2)
                
                ch1_output_v = psu.get_output_voltage(1)
                ch2_output_v = psu.get_output_voltage(2)
                
                status = psu.get_status()
                
                details = {
                    'identification': idn,
                    'channel_1': {
                        'output_enabled': ch1_state,
                        'set_voltage_v': ch1_voltage,
                        'set_current_a': ch1_current,
                        'output_voltage_v': ch1_output_v
                    },
                    'channel_2': {
                        'output_enabled': ch2_state,
                        'set_voltage_v': ch2_voltage, 
                        'set_current_a': ch2_current,
                        'output_voltage_v': ch2_output_v
                    },
                    'status': status
                }
                
                success = not ch1_state and not ch2_state
                message = f"PSU {name} functional ({idn.split(',')[1].strip()} if available)"
                if ch1_state or ch2_state:
                    message = f"WARNING: PSU {name} had enabled outputs - disabled for safety"
                
                return self.add_result(f"PSU_{name}", success, message, details)
                
        except Exception as e:
            return self.add_result(f"PSU_{name}", False, f"Failed: {e}")
    
    def run_quick_check(self) -> List[HealthCheckResult]:
        self.log("Starting quick health check...")
        self.results.clear()
        
        for name, config in self.config['instruments'].items():
            driver_type = config['driver']
            
            if driver_type == 'laser':
                self.test_dfb_laser(config)
            elif driver_type == 'pm':
                self.test_power_meter(name, config)
            elif driver_type == 'smu':
                self.test_smu(name, config)
            elif driver_type == 'psu':
                self.test_psu(name, config)
        
        return self.results
    
    def run_full_check(self) -> List[HealthCheckResult]:
        return self.run_quick_check()
    
    def print_summary(self):
        if not self.results:
            print("No test results available.")
            return
        
        total_tests = len(self.results)
        passed_tests = sum(1 for r in self.results if r.success)
        failed_tests = total_tests - passed_tests
        
        print("\n" + "="*60)
        print("FAU PRODUCTION TEST SYSTEM - HEALTH CHECK RESULTS")
        print("="*60)
        print(f"Test Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Total Tests: {total_tests}")
        print(f"Passed: {passed_tests}")
        print(f"Failed: {failed_tests}")
        print(f"Success Rate: {(passed_tests/total_tests)*100:.1f}%")
        print("="*60)
        
        for result in self.results:
            status = "PASS" if result.success else "FAIL"
            print(f"[{status}] {result.name}: {result.message}")
            
            if self.verbose and result.details:
                for key, value in result.details.items():
                    if isinstance(value, dict):
                        print(f"  {key}:")
                        for k, v in value.items():
                            print(f"    {k}: {v}")
                    else:
                        print(f"  {key}: {value}")
        
        print("="*60)
        
        if failed_tests == 0:
            print("STATUS: All systems operational - ready for production")
        else:
            print(f"STATUS: {failed_tests} system(s) require attention")
        
        print("="*60)
    
    def export_results(self, filename: str = None):
        if filename is None:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"health_check_{timestamp}.json"
        
        export_data = {
            'timestamp': datetime.now().isoformat(),
            'total_tests': len(self.results),
            'passed_tests': sum(1 for r in self.results if r.success),
            'failed_tests': sum(1 for r in self.results if not r.success),
            'results': []
        }
        
        for result in self.results:
            export_data['results'].append({
                'name': result.name,
                'success': result.success,
                'message': result.message,
                'details': result.details,
                'timestamp': result.timestamp.isoformat()
            })
        
        with open(filename, 'w') as f:
            json.dump(export_data, f, indent=2)
        
        print(f"Results exported to: {filename}")


def main():
    parser = argparse.ArgumentParser(description='FAU Production Test System Health Check')
    parser.add_argument('--quick', action='store_true', 
                       help='Run quick connectivity tests only')
    parser.add_argument('--verbose', action='store_true',
                       help='Enable detailed output')
    parser.add_argument('--config', type=str,
                       help='Use custom configuration file')
    parser.add_argument('--export', type=str, 
                       help='Export results to JSON file')
    
    args = parser.parse_args()
    
    config = None
    if args.config:
        try:
            with open(args.config, 'r') as f:
                config = json.load(f)
        except Exception as e:
            print(f"Failed to load configuration file: {e}")
            sys.exit(1)
    
    checker = InstrumentHealthChecker(config=config, verbose=args.verbose)
    
    print("FAU Production Test System - Health Check")
    print("Starting instrument health check...")
    
    try:
        if args.quick:
            results = checker.run_quick_check()
        else:
            results = checker.run_full_check()
        
        checker.print_summary()
        
        if args.export:
            checker.export_results(args.export)
        
        failed_count = sum(1 for r in results if not r.success)
        sys.exit(0 if failed_count == 0 else 1)
        
    except KeyboardInterrupt:
        print("\nHealth check interrupted by user.")
        sys.exit(1)
    except Exception as e:
        print(f"Health check failed with error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()


================================================
File: interactive_test_system.py
================================================

import os
import sys
import logging
import json
from datetime import datetime
from typing import Dict, Any, Optional, List
from drivers import MultiInstrumentManager
from utils.recorder import UniversalRecorder
from data_manager import DataManager, DataSavingPreferences

class InteractiveTestSystem:
    def __init__(self):
        self.manager = MultiInstrumentManager()
        self.recorder = None
        self.instruments = {}
        self.current_session = {}
        self.test_history = []
        self.data_manager = DataManager()
        
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(levelname)s: %(message)s'
        )
        
        self.load_session_data()
        self.data_manager.load_preferences()
    
    def load_session_data(self):
        """Load previous session data"""
        session_file = './session_data.json'
        if os.path.exists(session_file):
            try:
                with open(session_file, 'r') as f:
                    data = json.load(f)
                    self.test_history = data.get('test_history', [])
                    print(f"Loaded {len(self.test_history)} previous test records")
            except Exception as e:
                print(f"Could not load session data: {e}")
    
    def save_session_data(self):
        """Save current session data"""
        session_file = './session_data.json'
        try:
            data = {
                'test_history': self.test_history,
                'last_session': self.current_session
            }
            with open(session_file, 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            print(f"Could not save session data: {e}")
    
    def print_welcome(self):
        """Print welcome message and system status"""
        print("\n" + "="*80)
        print("              PRODUCTION FAU TEST SYSTEM")
        print("="*80)
        print("Welcome to the automated FAU testing system!")
        print(f"Session started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        if self.test_history:
            print(f"Previous tests in database: {len(self.test_history)}")
            last_test = max(self.test_history, key=lambda x: x['timestamp'])
            print(f"Last test: {last_test['device_id']} on {last_test['timestamp'][:10]}")
        
        print("\nSystem Status:")
        print("- Instruments: Not connected")
        print("- Recorder: Not initialized")
        print("- Ready for setup")
        print()
    
    def get_user_input(self, prompt: str, default: str = None, choices: List[str] = None) -> str:
        """Get user input with validation"""
        while True:
            if default:
                display_prompt = f"{prompt} [{default}]: "
            else:
                display_prompt = f"{prompt}: "
            
            if choices:
                print(f"Options: {', '.join(choices)}")
            
            response = input(display_prompt).strip()
            
            if not response and default:
                return default
            
            if choices and response.lower() not in [c.lower() for c in choices]:
                print(f"Please select from: {', '.join(choices)}")
                continue
            
            if response:
                return response
            
            print("Please provide a response.")
    
    def get_yes_no(self, prompt: str, default: str = "n") -> bool:
        """Get yes/no response from user"""
        response = self.get_user_input(f"{prompt} (y/n)", default, ["y", "n", "yes", "no"])
        return response.lower() in ["y", "yes"]
    
    def connect_instruments(self) -> bool:
        """Interactive instrument connection"""
        print("\n" + "="*60)
        print("INSTRUMENT CONNECTION SETUP")
        print("="*60)
        
        print("Connecting to production instruments...")
        print("Hardware addresses:")
        print("  SMU1: 10.11.83.58")
        print("  SMU2: 10.11.83.60") 
        print("  PSU1: 10.11.83.57")
        print("  PSU2: 10.11.83.52")
        print("  PM1:  M01250277")
        print("  PM2:  M01250278")
        print("  DFB:  COM3")
        
        if not self.get_yes_no("\nProceed with instrument connection?", "y"):
            return False
        
        connections = {
            'SMU1': ('smu', 'TCPIP::10.11.83.58::INSTR'),
            'SMU2': ('smu', 'TCPIP::10.11.83.60::INSTR'),
            'PSU1': ('psu', 'TCPIP::10.11.83.57::INSTR'),
            'PSU2': ('psu', 'TCPIP::10.11.83.52::INSTR'),
            'PM1': ('thorlabs_pm', 'USB0::0x1313::0x8076::M01250277::0::INSTR'),
            'PM2': ('thorlabs_pm', 'USB0::0x1313::0x8076::M01250278::0::INSTR'),
            'LASER': ('dfb13tk', 'COM3')
        }
        
        success_count = 0
        for unit_id, (driver_type, address) in connections.items():
            print(f"Connecting {unit_id}... ", end="", flush=True)
            if self.manager.add_instrument(unit_id, driver_type, address):
                self.instruments[unit_id] = self.manager.get_instrument(unit_id)
                success_count += 1
                print("Connected")
            else:
                print("Failed")
        
        print(f"\nConnection Results: {success_count}/7 instruments connected")
        
        if success_count < 4:
            print("WARNING: Less than 4 instruments connected")
            if not self.get_yes_no("Continue with limited instruments?", "n"):
                return False
        
        print("Instrument setup complete")
        return True
    
    def setup_test_session(self) -> Dict[str, Any]:
        """Interactive test session setup"""
        print("\n" + "="*60)
        print("TEST SESSION SETUP")
        print("="*60)
        
        is_rerun = False
        if self.test_history:
            print("Previous test records found.")
            if self.get_yes_no("Is this a rerun of a previous test?"):
                is_rerun = True
                self.show_previous_tests()
                rerun_id = self.get_user_input("Enter device ID to rerun")
                previous_test = next((t for t in self.test_history if t['device_id'] == rerun_id), None)
                if previous_test:
                    print(f"Found previous test: {previous_test['device_id']}")
                    print(f"Previous result: {previous_test.get('result', 'Unknown')}")
        
        session_info = {}
        
        if is_rerun and previous_test:
            session_info.update(previous_test)
            session_info['run_type'] = 'rerun'
            session_info['original_timestamp'] = previous_test['timestamp']
            session_info['rerun_count'] = previous_test.get('rerun_count', 0) + 1
        else:
            session_info['run_type'] = 'new'
            session_info['rerun_count'] = 0
        
        print("\nDevice Information:")
        session_info['device_id'] = self.get_user_input(
            "Device ID", 
            session_info.get('device_id', f"FAU_{datetime.now().strftime('%Y%m%d_%H%M')}")
        )
        
        session_info['operator'] = self.get_user_input("Operator name", "Production_User")
        session_info['workstation'] = self.get_user_input("Workstation ID", "TestStation_1")
        
        print("\nBatch Information:")
        session_info['dut_family'] = self.get_user_input("DUT Family", session_info.get('dut_family', "FAU_Device"))
        session_info['dut_batch'] = self.get_user_input("Batch ID", session_info.get('dut_batch', f"BATCH_{datetime.now().strftime('%Y%m%d')}"))
        session_info['dut_lot'] = self.get_user_input("Lot ID", session_info.get('dut_lot', "LOT_001"))
        session_info['dut_wafer'] = self.get_user_input("Wafer ID", session_info.get('dut_wafer', "W001"))
        
        print("\nTest Parameters:")
        device_count = int(self.get_user_input("Number of devices on sample", "2"))
        session_info['device_count'] = device_count
        
        if device_count < 4:
            print("INFO: With <4 devices, FAU alignment will be performed via IV sweep")
        
        print("\nEnvironment Information:")
        session_info['environment'] = {
            'temperature': float(self.get_user_input("Environment temperature (Â°C)", "22.0")),
            'humidity': float(self.get_user_input("Environment humidity (%)", "45.0")),
            'location': self.get_user_input("Test location", "Production_Lab")
        }
        
        print("\nData Saving Setup:")
        session_info['log_data'] = self.get_yes_no("Save test data?", "y")
        
        if session_info['log_data']:
            if self.get_yes_no("Configure data saving options?", "y"):
                configure_choice = self.get_user_input(
                    "Choose configuration method", "preset", 
                    ["preset", "custom", "previous"]
                )
                
                if configure_choice == "custom":
                    session_info['data_preferences'] = self.data_manager.get_user_preferences()
                elif configure_choice == "previous":
                    print("Using previously saved preferences")
                    session_info['data_preferences'] = self.data_manager.preferences
                else:  # preset
                    session_info['data_preferences'] = self.data_manager.select_preset()
                
                if self.get_yes_no("Save these preferences for future tests?", "y"):
                    self.data_manager.save_preferences()
            else:
                session_info['data_preferences'] = self.data_manager.preferences
            
            session_info['data_paths'] = self.data_manager.create_data_structure(
                session_info['device_id'], 
                session_info['operator'],
                session_info['timestamp']
            )
            
            save_summary = self.data_manager.get_save_summary(session_info['data_paths'])
            print(f"\n{save_summary}")
        else:
            print("WARNING: Data will NOT be saved (measurements will still be displayed)")
            session_info['data_preferences'] = None
            session_info['data_paths'] = None
        
        print("\nRun Configuration:")
        if self.get_yes_no("Plan multiple test runs?"):
            session_info['planned_runs'] = int(self.get_user_input("Number of planned runs", "1"))
            session_info['run_interval'] = self.get_user_input("Time between runs (minutes)", "0")
        else:
            session_info['planned_runs'] = 1
            session_info['run_interval'] = "0"
        
        session_info['timestamp'] = datetime.now().isoformat()
        
        return session_info
    
    def show_previous_tests(self):
        """Show previous test history"""
        print("\nPrevious Tests:")
        print("-" * 80)
        print(f"{'Device ID':<20} {'Date':<12} {'Result':<10} {'Operator':<15}")
        print("-" * 80)
        
        recent_tests = sorted(self.test_history, key=lambda x: x['timestamp'], reverse=True)[:10]
        for test in recent_tests:
            date = test['timestamp'][:10]
            result = test.get('result', 'Unknown')
            operator = test.get('operator', 'Unknown')
            print(f"{test['device_id']:<20} {date:<12} {result:<10} {operator:<15}")
        
        if len(self.test_history) > 10:
            print(f"... and {len(self.test_history) - 10} more tests")
        print()
    
    def confirm_test_setup(self, session_info: Dict[str, Any]) -> bool:
        """Show test setup summary and get confirmation"""
        print("\n" + "="*60)
        print("TEST SETUP CONFIRMATION")
        print("="*60)
        
        print(f"Device ID: {session_info['device_id']}")
        print(f"Operator: {session_info['operator']}")
        print(f"Run Type: {session_info['run_type'].upper()}")
        if session_info['run_type'] == 'rerun':
            print(f"Rerun Count: {session_info['rerun_count']}")
        
        print(f"Device Count: {session_info['device_count']}")
        print(f"Environment: {session_info['environment']['temperature']}Â°C, {session_info['environment']['humidity']}%")
        
        print(f"\nData Saving: {'Enabled' if session_info['log_data'] else 'Disabled'}")
        if session_info['log_data']:
            base_dir = session_info['data_paths']['base']
            print(f"Data Directory: {base_dir}")
            
            prefs = session_info['data_preferences']
            enabled_features = []
            if prefs.save_analysis_plots: enabled_features.append("Analysis Plots")
            if prefs.export_excel: enabled_features.append("Excel")
            if prefs.export_json: enabled_features.append("JSON")
            if prefs.backup_enabled: enabled_features.append("Backup")
            
            if enabled_features:
                print(f"Features: {', '.join(enabled_features)}")
            else:
                print("Features: Core data only")
        
        print(f"Planned Runs: {session_info['planned_runs']}")
        
        print("\nTest Sequence:")
        if session_info['device_count'] < 4:
            print("1. FAU Alignment (IV Sweep)")
            print("2. Laser Power Sweep (15-35mA)")
        else:
            print("1. Laser Power Sweep (15-35mA)")
        print("3. Data Recording & Analysis")
        
        return self.get_yes_no("\nConfirm test setup and begin testing?", "y")
    
    def run_test_sequence(self, session_info: Dict[str, Any]) -> Dict[str, Any]:
        """Execute the test sequence"""
        print("\n" + "="*60)
        print("EXECUTING TEST SEQUENCE")
        print("="*60)
        
        if session_info['log_data']:
            data_dir = session_info['data_paths']['base']
            self.recorder = UniversalRecorder(data_dir)
            self.recorder.test_run_start(
                workstation=session_info['workstation'],
                dut_family=session_info['dut_family'],
                dut_batch=session_info['dut_batch'],
                dut_lot=session_info['dut_lot'],
                dut_wafer=session_info['dut_wafer'],
                dut_id=session_info['device_id'],
                run_set_id=session_info.get('run_set_id', 1),
                run_id=session_info.get('rerun_count', 0) + 1
            )
        
        test_results = {}
        
        print("\nðŸ“‹ STEP 1: Sample Placement")
        print("Please ensure:")
        print("- Sample is placed on chuck")
        print("- Probe card touchdown is complete")
        print("- All connections are secure")
        
        input("Press Enter when sample placement is complete...")
        
        if session_info['device_count'] < 4:
            print(f"\nðŸ“‹ STEP 2: FAU Alignment (Device count: {session_info['device_count']})")
            print("Performing IV sweep for FAU alignment...")
            
            if session_info['log_data']:
                self.recorder.phase_start(1, "FAU_Alignment")
            
            alignment_result = self.perform_fau_alignment()
            test_results['fau_alignment'] = alignment_result
            
            if session_info['log_data']:
                self.recorder.phase_end()
            
            if not alignment_result['success']:
                print("FAILED: FAU alignment failed!")
                return {'success': False, 'error': 'FAU alignment failed'}
            else:
                print("FAU alignment complete")
        
        step_num = 3 if session_info['device_count'] < 4 else 2
        print(f"\nðŸ“‹ STEP {step_num}: Laser Power Sweep")
        print("Performing laser power characterization...")
        print("- Turning laser ON")
        print("- Sweeping current 15-35mA in 0.2mA steps") 
        print("- Measuring power on channels 3&4")
        
        if session_info['log_data']:
            self.recorder.phase_start(step_num, "Laser_Power_Sweep")
        
        sweep_result = self.perform_laser_sweep()
        test_results['laser_sweep'] = sweep_result
        
        if session_info['log_data'] and sweep_result['success']:
            import pandas as pd
            df = pd.DataFrame(sweep_result['measurements'])
            
            self.recorder.record_complete_dataset(
                name='laser_power_characterization',
                data=df,
                test_info={
                    'test_name': 'FAU_Production_Test',
                    'test_location': session_info['environment']['location'],
                    'test_user': session_info['operator'],
                    'device_count': session_info['device_count']
                },
                environment_info=session_info['environment'],
                testing_variable="current_ma",
                dependent_variables=["channel3_power_mw", "channel4_power_mw", "laser_wavelength_nm"],
                equipment_ids="LASER, PM1, PM2"
            )
            
            self.recorder.phase_end()
        
        if not sweep_result['success']:
            print("FAILED: Laser power sweep failed!")
            return {'success': False, 'error': 'Laser power sweep failed'}
        else:
            print("Laser power sweep complete")
        
        if session_info['log_data']:
            self.recorder.run_end()
        
        test_results['success'] = True
        test_results['timestamp'] = datetime.now().isoformat()
        
        return test_results
    
    def perform_fau_alignment(self) -> Dict[str, Any]:
        """Perform FAU alignment via IV sweep"""
        smu = self.instruments.get('SMU1')
        if not smu:
            return {'success': False, 'error': 'SMU1 not available'}
        
        try:
            smu.set_mode_source_voltage()
            smu.set_current_limit(0.01)
            smu.enable_output(True)
            
            measurements = []
            for voltage in [v * 0.1 for v in range(51)]:  # 0 to 5V, 0.1V steps
                smu.set_source_voltage(voltage)
                measurement = smu.measure_all()
                measurements.append(measurement)
                
                if int(voltage * 10) % 10 == 0:
                    print(f"  Voltage: {voltage:.1f}V, Current: {measurement.measured_current*1000:.3f}mA")
            
            smu.enable_output(False)
            
            return {
                'success': True,
                'measurement_count': len(measurements),
                'voltage_range': '0-5V',
                'measurements': [m.to_dict() for m in measurements]
            }
            
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def perform_laser_sweep(self) -> Dict[str, Any]:
        """Perform laser power sweep with dual power meters"""
        laser = self.instruments.get('LASER')
        pm1 = self.instruments.get('PM1') 
        pm2 = self.instruments.get('PM2')
        
        if not all([laser, pm1, pm2]):
            missing = []
            if not laser: missing.append('LASER')
            if not pm1: missing.append('PM1')
            if not pm2: missing.append('PM2')
            return {'success': False, 'error': f'Missing instruments: {", ".join(missing)}'}
        
        try:
            laser.set_temperature(25.0)
            laser.wait_temperature_stable(timeout=30)
            laser.laser_on()
            
            pm1.set_wavelength(1310)
            pm1.set_power_unit("W")
            pm1.set_auto_range(True)
            
            pm2.set_wavelength(1310)
            pm2.set_power_unit("W")
            pm2.set_auto_range(True)
            
            measurements = []
            current_ma = 15.0
            
            print("  Progress:")
            while current_ma <= 35.0:
                laser.set_current(current_ma)
                
                laser_measurement = laser.measure_all()
                pm1_measurement = pm1.measure_all('PM1')
                pm2_measurement = pm2.measure_all('PM2')
                
                combined_data = {
                    'current_ma': current_ma,
                    'laser_wavelength_nm': laser_measurement.wavelength_nm,
                    'laser_power_mw': laser_measurement.estimated_power_mw,
                    'channel3_power_w': pm1_measurement.power_w,
                    'channel3_power_mw': pm1_measurement.power_mw,
                    'channel4_power_w': pm2_measurement.power_w,
                    'channel4_power_mw': pm2_measurement.power_mw,
                    'timestamp': laser_measurement.timestamp
                }
                
                measurements.append(combined_data)
                
                if int((current_ma - 15) * 10) % 10 == 0:
                    print(f"    {current_ma:.1f}mA: CH3={pm1_measurement.power_mw:.3f}mW, CH4={pm2_measurement.power_mw:.3f}mW")
                
                current_ma += 0.2
            
            laser.laser_off()
            
            return {
                'success': True,
                'measurement_count': len(measurements),
                'current_range': '15.0-35.0mA',
                'measurements': measurements
            }
            
        except Exception as e:
            if 'laser' in locals():
                laser.laser_off()  # Safety
            return {'success': False, 'error': str(e)}
    
    def show_test_results(self, session_info: Dict[str, Any], test_results: Dict[str, Any]):
        """Display test results summary"""
        print("\n" + "="*60)
        print("TEST RESULTS SUMMARY")
        print("="*60)
        
        print(f"Device ID: {session_info['device_id']}")
        print(f"Test Status: {'PASSED' if test_results['success'] else 'FAILED'}")
        print(f"Completion Time: {test_results.get('timestamp', 'Unknown')}")
        
        if 'fau_alignment' in test_results:
            align_result = test_results['fau_alignment']
            print(f"FAU Alignment: {'Success' if align_result['success'] else 'Failed'}")
            if align_result['success']:
                print(f"  - Measurements: {align_result['measurement_count']}")
        
        if 'laser_sweep' in test_results:
            sweep_result = test_results['laser_sweep']
            print(f"Laser Sweep: {'Success' if sweep_result['success'] else 'Failed'}")
            if sweep_result['success']:
                print(f"  - Measurements: {sweep_result['measurement_count']}")
                print(f"  - Current Range: {sweep_result['current_range']}")
        
        if session_info['log_data'] and test_results['success']:
            data_dir = session_info['data_paths']['base']
            print(f"Data Location: {data_dir}")
            
            prefs = session_info['data_preferences']
            saved_items = ["CSV data", "Test parameters", "Session log"]
            
            if prefs.save_analysis_plots: saved_items.append("Analysis plots")
            if prefs.save_summary_plots: saved_items.append("Summary plots")
            if prefs.export_excel: saved_items.append("Excel files")
            if prefs.export_json: saved_items.append("JSON data")
            if prefs.backup_enabled: saved_items.append("Backup copy")
            
            print(f"Saved: {', '.join(saved_items)}")
        
        history_record = {
            'device_id': session_info['device_id'],
            'timestamp': test_results.get('timestamp'),
            'result': 'PASSED' if test_results['success'] else 'FAILED',
            'operator': session_info['operator'],
            'run_type': session_info['run_type'],
            'rerun_count': session_info.get('rerun_count', 0)
        }
        
        if test_results.get('error'):
            history_record['error'] = test_results['error']
        
        self.test_history.append(history_record)
        self.save_session_data()
    
    def ask_next_action(self, session_info: Dict[str, Any]) -> str:
        """Ask user what to do next"""
        print("\n" + "="*60)
        print("NEXT ACTION")
        print("="*60)
        
        actions = ["new", "rerun", "exit"]
        
        if session_info.get('planned_runs', 1) > 1:
            actions.insert(0, "continue")
            print("Options:")
            print("  continue - Continue with next planned run")
            print("  new      - Start new test with different device")
            print("  rerun    - Repeat current test")
            print("  exit     - Exit system")
        else:
            print("Options:")
            print("  new   - Start new test with different device") 
            print("  rerun - Repeat current test")
            print("  exit  - Exit system")
        
        return self.get_user_input("Select next action", "exit", actions)
    
    def cleanup(self):
        """Cleanup system resources"""
        print("\nðŸ“‹ System Cleanup")
        print("Disconnecting instruments...")
        self.manager.disconnect_all()
        
        if self.recorder:
            print("Finalizing data recording...")
            self.recorder.run_end()
        
        self.save_session_data()
        print("Cleanup complete")
    
    def run(self):
        """Main interactive system loop"""
        try:
            self.print_welcome()
            
            if not self.connect_instruments():
                print("ERROR: Cannot proceed without instruments")
                return
            
            while True:
                session_info = self.setup_test_session()
                self.current_session = session_info
                
                if not self.confirm_test_setup(session_info):
                    print("Test cancelled by user")
                    continue
                
                print(f"\nStarting test for device: {session_info['device_id']}")
                test_results = self.run_test_sequence(session_info)
                
                self.show_test_results(session_info, test_results)
                
                next_action = self.ask_next_action(session_info)
                
                if next_action == "exit":
                    break
                elif next_action == "rerun":
                    print("Preparing for rerun...")
                    continue
                elif next_action == "new":
                    print("Preparing for new test...")
                    continue
                elif next_action == "continue":
                    print("Continuing with planned runs...")
                    session_info['rerun_count'] += 1
                    continue
        
        except KeyboardInterrupt:
            print("\n\nWARNING: Test interrupted by user")
        except Exception as e:
            print(f"\nERROR: System error: {e}")
            logging.error(f"System error: {e}", exc_info=True)
        finally:
            self.cleanup()

if __name__ == "__main__":
    system = InteractiveTestSystem()
    system.run()


================================================
File: run_test.py
================================================
"""
Simple launcher for the production test system
"""

import sys
import os

sys.path.insert(0, os.path.dirname(__file__))

if __name__ == "__main__":
    print("FAU Production Test System")
    print("=" * 50)
    print("1. Interactive Test System (Recommended)")
    print("2. Direct Customer Test Flow")
    print("3. Exit")
    
    choice = input("\nSelect option [1]: ").strip()
    
    if choice == "2":
        print("\nLaunching direct customer test flow...")
        from Test_flow import run_test
        success = run_test()
        sys.exit(0 if success else 1)
    
    elif choice == "3":
        print("Goodbye!")
        sys.exit(0)
    
    else:  # Default to interactive system
        print("\nLaunching interactive test system...")
        from interactive_test_system import InteractiveTestSystem
        system = InteractiveTestSystem()
        system.run()


================================================
File: test.py
================================================
import time
import numpy as np
import pandas as pd
import logging

from drivers.tti_qlp355 import TTi_QL355TP
from drivers.smu import AimTTi_SMU4000
from drivers.pm101 import ThorlabsPowerMeter as Thorlabs_PMxxx
from utils.recorder import UniversalRecorder, PlotConfig, DataConfig

PSU_VISA_ADDRESS = 'USB0::0x103E::0x0109::...::INSTR'
SMU_VISA_ADDRESS = 'USB0::0x103E::0x4002::...::INSTR'
PD_VISA_ADDRESS  = 'USB0::0x1313::0x8078::...::INSTR'

TARGET_POWER_MW = 5.0
STABILIZATION_TOLERANCE_MW = 0.05
MAX_STABILIZATION_ATTEMPTS = 20
PSU_INITIAL_VOLTAGE = 3.3
PSU_CHANNEL = 1

SMU_CURRENT_START_A = 0.0
SMU_CURRENT_STOP_A = 0.05
SMU_CURRENT_STEPS = 51
SMU_VOLTAGE_LIMIT_V = 5.0

logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(levelname)s: %(message)s')
recorder = UniversalRecorder(top_dir='./test_output')

def stabilize_psu_output(psu: TTi_QL355TP, pd: Thorlabs_PMxxx):
    logging.info(f"--- Starting PSU stabilization for {TARGET_POWER_MW:.2f} mW ---")
    
    current_voltage = PSU_INITIAL_VOLTAGE
    psu.set_voltage(PSU_CHANNEL, current_voltage)
    psu.enable_output(PSU_CHANNEL, True)
    time.sleep(0.5)

    for attempt in range(MAX_STABILIZATION_ATTEMPTS):
        measured_power_mw = pd.read_power() * 1000
        error_mw = measured_power_mw - TARGET_POWER_MW
        
        logging.info(
            f"Attempt {attempt+1}/{MAX_STABILIZATION_ATTEMPTS}: "
            f"Voltage={current_voltage:.3f}V, "
            f"Power={measured_power_mw:.3f}mW, "
            f"Error={error_mw:.3f}mW"
        )
        
        if abs(error_mw) <= STABILIZATION_TOLERANCE_MW:
            logging.info(f"Stabilization successful at {measured_power_mw:.3f} mW.")
            return True
        
        p_gain = 0.02
        voltage_adjustment = -error_mw * p_gain
        current_voltage += voltage_adjustment
        current_voltage = max(0, min(5.0, current_voltage))
        
        psu.set_voltage(PSU_CHANNEL, current_voltage)
        time.sleep(0.2)

    logging.error("Failed to stabilize power within max attempts.")
    psu.enable_output(PSU_CHANNEL, False)
    return False

def run_smu_sweep(smu: AimTTi_SMU4000, pd: Thorlabs_PMxxx):
    logging.info(f"--- Starting SMU current sweep from {SMU_CURRENT_START_A}A to {SMU_CURRENT_STOP_A}A ---")
    
    smu.set_mode_source_current()
    smu.set_voltage_limit(SMU_VOLTAGE_LIMIT_V)
    smu.enable_output(True)
    
    current_sweep = np.linspace(SMU_CURRENT_START_A, SMU_CURRENT_STOP_A, SMU_CURRENT_STEPS)
    measured_powers = []
    
    for i, current in enumerate(current_sweep):
        smu.set_source_current(current)
        time.sleep(0.1)
        
        power = pd.read_power()
        measured_powers.append(power)
        
        logging.info(f"Step {i+1}/{SMU_CURRENT_STEPS}: Set Current={current*1000:.2f}mA, Measured Power={power*1000:.3f}mW")
        
    smu.enable_output(False)
    
    results_df = pd.DataFrame({
        'SMU_Current_A': current_sweep,
        'Photodetector_Power_W': measured_powers
    })
    
    return results_df

if __name__ == "__main__":
    psu = None
    smu = None
    pd = None

    try:
        logging.info("Connecting to instruments...")
        psu = TTi_QL355TP(PSU_VISA_ADDRESS)
        smu = AimTTi_SMU4000(SMU_VISA_ADDRESS)
        pd = Thorlabs_PMxxx(PD_VISA_ADDRESS)
        
        pd.set_wavelength(1550)
        pd.set_power_unit("W")
        pd.set_auto_range(True)
        psu.set_current_limit(PSU_CHANNEL, 0.5)

        recorder.test_run_start(
            workstation='AutoTest-01',
            dut_family='MyDeviceFamily', 
            dut_batch='B01',
            dut_lot='L01',
            dut_wafer='W01',
            dut_id='DUT-SN123',
            run_set_id=1,
            run_id=1
        )

        recorder.phase_start(phase_idx=1, phase_name="PSU_Stabilization")
        if stabilize_psu_output(psu, pd):
            logging.info("PSU stabilization phase complete.")
        else:
            raise RuntimeError("Could not complete PSU stabilization phase.")
        recorder.phase_end()
        
        recorder.phase_start(phase_idx=2, phase_name="SMU_Current_Sweep")
        sweep_data = run_smu_sweep(smu, pd)
        
        test_info = {"test_name": "SMU_IV_Sweep", "test_location": "Lab_B", "test_user": "AutoScript"}
        env_info = {"environment_temp": 22.5, "environment_humidity": 48.1}

        recorder.record_complete_dataset(
            name='smu_sweep_results',
            data=sweep_data,
            test_info=test_info,
            environment_info=env_info,
            testing_variable="SMU_Current_A",
            dependent_variables=["Photodetector_Power_W"],
            script_version="1.0"
        )
        
        logging.info("SMU sweep phase complete.")
        recorder.phase_end()

    except Exception as e:
        logging.error(f"An error occurred during the test flow: {e}", exc_info=True)
        
    finally:
        logging.info("Test flow finished. Cleaning up...")
        if psu:
            psu.enable_output(1, False)
            psu.enable_output(2, False)
            psu.disconnect()
        if smu:
            smu.enable_output(False)
            smu.disconnect()
        if pd:
            pd.disconnect()
            
        recorder.run_end()
        logging.info("All resources closed.")


================================================
File: drivers/TLPMX.py
================================================
import os
from ctypes import cdll,c_long,c_uint32,c_uint16,c_uint8,byref,create_string_buffer,c_bool, c_char, c_char_p,c_int,c_int16,c_int8,c_double,c_float,sizeof,c_voidp, Structure

_VI_ERROR = (-2147483647-1)
VI_ON = 1
VI_OFF = 0
TLPM_VID_THORLABS = (0x1313)  # Thorlabs
TLPM_PID_TLPM_DFU = (0x8070)  # PM100D with DFU interface enabled
TLPM_PID_PM100A_DFU = (0x8071)  # PM100A with DFU interface enabled
TLPM_PID_PM100USB = (0x8072)  # PM100USB with DFU interface enabled
TLPM_PID_PM160USB_DFU = (0x8073)  # PM160 on USB with DFU interface enabled
TLPM_PID_PM160TUSB_DFU = (0x8074)  # PM160T on USB with DFU interface enabled
TLPM_PID_PM400_DFU = (0x8075)  # PM400 on USB with DFU interface enabled
TLPM_PID_PM101_DFU = (0x8076)  # PM101 on USB with DFU interface enabled (Interface 0 TMC, Interface 1 DFU)
TLPM_PID_PM102_DFU = (0x8077)  # PM102 on USB with DFU interface enabled (Interface 0 TMC, Interface 1 DFU)
TLPM_PID_PM103_DFU = (0x807A)  # PM103 on USB with DFU interface enabled (Interface 0 TMC, Interface 1 DFU)
TLPM_PID_PM100D = (0x8078)  # PM100D w/o DFU interface
TLPM_PID_PM100A = (0x8079)  # PM100A w/o DFU interface
TLPM_PID_PM160USB = (0x807B)  # PM160 on USB w/o DFU interface
TLPM_PID_PM160TUSB = (0x807C)  # PM160T on USB w/o DFU interface
TLPM_PID_PM400 = (0x807D)  # PM400 on USB w/o DFU interface
TLPM_PID_PM101 = (0x807E)  # reserved
TLPM_PID_PMTest = (0x807F)  # PM Test Platform
TLPM_PID_PM200 = (0x80B0)  # PM200
TLPM_PID_PM5020 = (0x80BB)  # PM5020 1 channel benchtop powermeter (Interface 0 TMC, Interface 1 DFU)
TLPM_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x8070 || VI_ATTR_MODEL_CODE==0x8078)}"
PM100A_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x8071 || VI_ATTR_MODEL_CODE==0x8079)}"
PM100USB_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && VI_ATTR_MODEL_CODE==0x8072}"
PM160USB_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x8073 || VI_ATTR_MODEL_CODE==0x807B)}"
PM160TUSB_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x8074 || VI_ATTR_MODEL_CODE==0x807C)}"
PM200_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && VI_ATTR_MODEL_CODE==0x80B0}"
PM400_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x8075 || VI_ATTR_MODEL_CODE==0x807D)}"
PM101_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x8076)}"
PM102_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x8077)}"
PM103_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && VI_ATTR_MODEL_CODE==0x807A}"
PMTest_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && VI_ATTR_MODEL_CODE==0x807F}"
PM100_FIND_PATTERN = "USB?*::0x1313::0x807?::?*::INSTR"
PM5020_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && VI_ATTR_MODEL_CODE==0x80BB}"
PMxxx_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x8070 || VI_ATTR_MODEL_CODE==0x8078 || " \
"VI_ATTR_MODEL_CODE==0x8071 || VI_ATTR_MODEL_CODE==0x8079 || " \
"VI_ATTR_MODEL_CODE==0x8072 || " \
"VI_ATTR_MODEL_CODE==0x8073 || VI_ATTR_MODEL_CODE==0x807B || " \
"VI_ATTR_MODEL_CODE==0x8074 || VI_ATTR_MODEL_CODE==0x807C || " \
"VI_ATTR_MODEL_CODE==0x8075 || VI_ATTR_MODEL_CODE==0x807D || " \
"VI_ATTR_MODEL_CODE==0x8076 || VI_ATTR_MODEL_CODE==0x807E || " \
"VI_ATTR_MODEL_CODE==0x8077 || VI_ATTR_MODEL_CODE==0x807F || " \
"VI_ATTR_MODEL_CODE==0x807A || VI_ATTR_MODEL_CODE==0x80BB ||" \
"VI_ATTR_MODEL_CODE==0x80B0)}"
PMBT_FIND_PATTERN = "ASRL?*::INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x807C || VI_ATTR_MODEL_CODE==0x807B)}"
PMUART_FIND_PATTERN_VISA = "ASRL?*::INSTR"
PMUART_FIND_PATTERN_COM = "COM?*"
TLPM_BUFFER_SIZE = 256  # General buffer size
TLPM_ERR_DESCR_BUFFER_SIZE = 512  # Buffer size for error messages
VI_INSTR_WARNING_OFFSET = (0x3FFC0900 )
VI_INSTR_ERROR_OFFSET = (_VI_ERROR + 0x3FFC0900 )
VI_INSTR_ERROR_NOT_SUPP_INTF = (VI_INSTR_ERROR_OFFSET + 0x01 )
VI_INSTR_WARN_OVERFLOW = (VI_INSTR_WARNING_OFFSET + 0x01 )
VI_INSTR_WARN_UNDERRUN = (VI_INSTR_WARNING_OFFSET + 0x02 )
VI_INSTR_WARN_NAN = (VI_INSTR_WARNING_OFFSET + 0x03 )
TLPM_ATTR_SET_VAL = (0)
TLPM_ATTR_MIN_VAL = (1)
TLPM_ATTR_MAX_VAL = (2)
TLPM_ATTR_DFLT_VAL = (3)
TLPM_ATTR_AUTO_VAL = (9)
TLPM_DEFAULT_CHANNEL = (1)
TLPM_SENSOR_CHANNEL1 = (1)
TLPM_SENSOR_CHANNEL2 = (2)
TLPM_INDEX_1 = (1)
TLPM_INDEX_2 = (2)
TLPM_INDEX_3 = (3)
TLPM_INDEX_4 = (4)
TLPM_INDEX_5 = (5)
TLPM_PEAK_FILTER_NONE = (0)
TLPM_PEAK_FILTER_OVER = (1)
TLPM_REG_STB = (0)  # < Status Byte Register
TLPM_REG_SRE = (1)  # < Service Request Enable
TLPM_REG_ESB = (2)  # < Standard Event Status Register
TLPM_REG_ESE = (3)  # < Standard Event Enable
TLPM_REG_OPER_COND = (4)  # < Operation Condition Register
TLPM_REG_OPER_EVENT = (5)  # < Operation Event Register
TLPM_REG_OPER_ENAB = (6)  # < Operation Event Enable Register
TLPM_REG_OPER_PTR = (7)  # < Operation Positive Transition Filter
TLPM_REG_OPER_NTR = (8)  # < Operation Negative Transition Filter
TLPM_REG_QUES_COND = (9)  # < Questionable Condition Register
TLPM_REG_QUES_EVENT = (10)  # < Questionable Event Register
TLPM_REG_QUES_ENAB = (11)  # < Questionable Event Enable Reg.
TLPM_REG_QUES_PTR = (12)  # < Questionable Positive Transition Filter
TLPM_REG_QUES_NTR = (13)  # < Questionable Negative Transition Filter
TLPM_REG_MEAS_COND = (14)  # < Measurement Condition Register
TLPM_REG_MEAS_EVENT = (15)  # < Measurement Event Register
TLPM_REG_MEAS_ENAB = (16)  # < Measurement Event Enable Register
TLPM_REG_MEAS_PTR = (17)  # < Measurement Positive Transition Filter
TLPM_REG_MEAS_NTR = (18)  # < Measurement Negative Transition Filter
TLPM_REG_AUX_COND = (19)  # < Auxiliary Condition Register
TLPM_REG_AUX_EVENT = (20)  # < Auxiliary Event Register
TLPM_REG_AUX_ENAB = (21)  # < Auxiliary Event Enable Register
TLPM_REG_AUX_PTR = (22)  # < Auxiliary Positive Transition Filter
TLPM_REG_AUX_NTR = (23)  # < Auxiliary Negative Transition Filter
TLPM_REG_OPER_COND_1 = (24)  # < Operation Condition Register Channel 1
TLPM_REG_OPER_COND_2 = (25)  # < Operation Condition Register Channel 2
TLPM_REG_AUX_DET_COND = (26)  # < Auxiliary Condition Register DET
TLPM_STATBIT_STB_AUX = (0x01)  # < Auxiliary summary
TLPM_STATBIT_STB_MEAS = (0x02)  # < Device Measurement Summary
TLPM_STATBIT_STB_EAV = (0x04)  # < Error available
TLPM_STATBIT_STB_QUES = (0x08)  # < Questionable Status Summary
TLPM_STATBIT_STB_MAV = (0x10)  # < Message available
TLPM_STATBIT_STB_ESB = (0x20)  # < Event Status Bit
TLPM_STATBIT_STB_MSS = (0x40)  # < Master summary status
TLPM_STATBIT_STB_OPER = (0x80)  # < Operation Status Summary
TLPM_STATBIT_ESR_OPC = (0x01)  # < Operation complete
TLPM_STATBIT_ESR_RQC = (0x02)  # < Request control
TLPM_STATBIT_ESR_QYE = (0x04)  # < Query error
TLPM_STATBIT_ESR_DDE = (0x08)  # < Device-Specific error
TLPM_STATBIT_ESR_EXE = (0x10)  # < Execution error
TLPM_STATBIT_ESR_CME = (0x20)  # < Command error
TLPM_STATBIT_ESR_URQ = (0x40)  # < User request
TLPM_STATBIT_ESR_PON = (0x80)  # < Power on
TLPM_STATBIT_QUES_VOLT = (0x0001)  # < questionable voltage measurement
TLPM_STATBIT_QUES_CURR = (0x0002)  # < questionable current measurement
TLPM_STATBIT_QUES_TIME = (0x0004)  # < questionable time measurement
TLPM_STATBIT_QUES_POW = (0x0008)  # < questionable power measurement
TLPM_STATBIT_QUES_TEMP = (0x0010)  # < questionable temperature measurement
TLPM_STATBIT_QUES_FREQ = (0x0020)  # < questionable frequency measurement
TLPM_STATBIT_QUES_PHAS = (0x0040)  # < questionable phase measurement
TLPM_STATBIT_QUES_MOD = (0x0080)  # < questionable modulation measurement
TLPM_STATBIT_QUES_CAL = (0x0100)  # < questionable calibration
TLPM_STATBIT_QUES_ENER = (0x0200)  # < questionable energy measurement
TLPM_STATBIT_QUES_10 = (0x0400)  # < reserved
TLPM_STATBIT_QUES_11 = (0x0800)  # < reserved
TLPM_STATBIT_QUES_12 = (0x1000)  # < reserved
TLPM_STATBIT_QUES_INST = (0x2000)  # < instrument summary
TLPM_STATBIT_QUES_WARN = (0x4000)  # < command warning
TLPM_STATBIT_QUES_15 = (0x8000)  # < reserved
TLPM_STATBIT_OPER_CAL = (0x0001)  # < The instrument is currently performing a calibration.
TLPM_STATBIT_OPER_SETT = (0x0002)  # < The instrument is waiting for signals it controls to stabilize enough to begin measurements.
TLPM_STATBIT_OPER_RANG = (0x0004)  # < The instrument is currently changing its range.
TLPM_STATBIT_OPER_SWE = (0x0008)  # < A sweep is in progress.
TLPM_STATBIT_OPER_MEAS = (0x0010)  # < The instrument is actively measuring.
TLPM_STATBIT_OPER_TRIG = (0x0020)  # < The instrument is in a �wait for trigger� state of the trigger model.
TLPM_STATBIT_OPER_ARM = (0x0040)  # < The instrument is in a �wait for arm� state of the trigger model.
TLPM_STATBIT_OPER_CORR = (0x0080)  # < The instrument is currently performing a correction (Auto-PID tune).
TLPM_STATBIT_OPER_SENS = (0x0100)  # < Optical powermeter sensor connected and operable.
TLPM_STATBIT_OPER_DATA = (0x0200)  # < Measurement data ready for fetch.
TLPM_STATBIT_OPER_THAC = (0x0400)  # < Thermopile accelerator active.
TLPM_STATBIT_OPER_11 = (0x0800)  # < reserved
TLPM_STATBIT_OPER_12 = (0x1000)  # < reserved
TLPM_STATBIT_OPER_INST = (0x2000)  # < One of n multiple logical instruments is reporting OPERational status.
TLPM_STATBIT_OPER_PROG = (0x4000)  # < A user-defined programming is currently in the run state.
TLPM_STATBIT_OPER_15 = (0x8000)  # < reserved
TLPM_STATBIT_MEAS_0 = (0x0001)  # < reserved
TLPM_STATBIT_MEAS_1 = (0x0002)  # < reserved
TLPM_STATBIT_MEAS_2 = (0x0004)  # < reserved
TLPM_STATBIT_MEAS_3 = (0x0008)  # < reserved
TLPM_STATBIT_MEAS_4 = (0x0010)  # < reserved
TLPM_STATBIT_MEAS_5 = (0x0020)  # < reserved
TLPM_STATBIT_MEAS_6 = (0x0040)  # < reserved
TLPM_STATBIT_MEAS_7 = (0x0080)  # < reserved
TLPM_STATBIT_MEAS_8 = (0x0100)  # < reserved
TLPM_STATBIT_MEAS_9 = (0x0200)  # < reserved
TLPM_STATBIT_MEAS_10 = (0x0400)  # < reserved
TLPM_STATBIT_MEAS_11 = (0x0800)  # < reserved
TLPM_STATBIT_MEAS_12 = (0x1000)  # < reserved
TLPM_STATBIT_MEAS_13 = (0x2000)  # < reserved
TLPM_STATBIT_MEAS_14 = (0x4000)  # < reserved
TLPM_STATBIT_MEAS_15 = (0x8000)  # < reserved
TLPM_STATBIT_AUX_NTC = (0x0001)  # < Auxiliary NTC temperature sensor connected.
TLPM_STATBIT_AUX_EMM = (0x0002)  # < External measurement module connected.
TLPM_STATBIT_AUX_UPCS = (0x0004)  # < User Power Calibration supported by this instrument
TLPM_STATBIT_AUX_UPCA = (0x0008)  # < User Power Calibration active status
TLPM_STATBIT_AUX_EXPS = (0x0010)  # < External power supply connected
TLPM_STATBIT_AUX_BATC = (0x0020)  # < Battery charging
TLPM_STATBIT_AUX_BATL = (0x0040)  # < Battery low
TLPM_STATBIT_AUX_IPS = (0x0080)  # < Apple(tm) authentification supported. True if an authentification co-processor is installed.
TLPM_STATBIT_AUX_IPF = (0x0100)  # < Apple(tm) authentification failed. True if the authentification setup procedure failed.
TLPM_STATBIT_AUX_9 = (0x0200)  # < reserved
TLPM_STATBIT_AUX_10 = (0x0400)  # < reserved
TLPM_STATBIT_AUX_11 = (0x0800)  # < reserved
TLPM_STATBIT_AUX_12 = (0x1000)  # < reserved
TLPM_STATBIT_AUX_13 = (0x2000)  # < reserved
TLPM_STATBIT_AUX_14 = (0x4000)  # < reserved
TLPM_STATBIT_AUX_15 = (0x8000)  # < reserved
TLPM_WINTERTIME = (0)
TLPM_SUMMERTIME = (1)
TLPM_LINE_FREQ_50 = (50)  # < line frequency in Hz
TLPM_LINE_FREQ_60 = (60)  # < line frequency in Hz
TLPM_INPUT_FILTER_STATE_OFF = (0)
TLPM_INPUT_FILTER_STATE_ON = (1)
TLPM_ACCELERATION_STATE_OFF = (0)
TLPM_ACCELERATION_STATE_ON = (1)
TLPM_ACCELERATION_MANUAL = (0)
TLPM_ACCELERATION_AUTO = (1)
TLPM_STAT_DARK_ADJUST_FINISHED = (0)
TLPM_STAT_DARK_ADJUST_RUNNING = (1)
TLPM_AUTORANGE_CURRENT_OFF = (0)
TLPM_AUTORANGE_CURRENT_ON = (1)
TLPM_CURRENT_REF_OFF = (0)
TLPM_CURRENT_REF_ON = (1)
TLPM_ENERGY_REF_OFF = (0)
TLPM_ENERGY_REF_ON = (1)
TLPM_FREQ_MODE_CW = (0)
TLPM_FREQ_MODE_PEAK = (1)
TLPM_AUTORANGE_POWER_OFF = (0)
TLPM_AUTORANGE_POWER_ON = (1)
TLPM_POWER_REF_OFF = (0)
TLPM_POWER_REF_ON = (1)
TLPM_POWER_UNIT_WATT = (0)
TLPM_POWER_UNIT_DBM = (1)
SENSOR_SWITCH_POS_1 = (1)
SENSOR_SWITCH_POS_2 = (2)
TLPM_AUTORANGE_VOLTAGE_OFF = (0)
TLPM_AUTORANGE_VOLTAGE_ON = (1)
TLPM_VOLTAGE_REF_OFF = (0)
TLPM_VOLTAGE_REF_ON = (1)
TLPM_ANALOG_ROUTE_PUR = (0)
TLPM_ANALOG_ROUTE_CBA = (1)
TLPM_ANALOG_ROUTE_CMA = (2)
TLPM_ANALOG_ROUTE_GEN = (3)
TLPM_IODIR_INP = (VI_OFF)
TLPM_IODIR_OUTP = (VI_ON)
TLPM_IOLVL_LOW = (VI_OFF)
TLPM_IOLVL_HIGH = (VI_ON)
DIGITAL_IO_CONFIG_INPUT = (0)
DIGITAL_IO_CONFIG_OUTPUT = (1)
DIGITAL_IO_CONFIG_INPUT_ALT = (2)
DIGITAL_IO_CONFIG_OUTPUT_ALT = (3)
I2C_OPER_INTER = (0)
I2C_OPER_SLOW = (1)
I2C_OPER_FAST = (2)
FAN_OPER_OFF = (0)
FAN_OPER_FULL = (1)
FAN_OPER_OPEN_LOOP = (2)
FAN_OPER_CLOSED_LOOP = (3)
FAN_OPER_TEMPER_CTRL = (4)
FAN_TEMPER_SRC_HEAD = (0)
FAN_TEMPER_SRC_EXT_NTC = (1)
SENSOR_TYPE_NONE = 0x0  # No sensor. This value is used to mark sensor data for 'no sensor connected'.
SENSOR_TYPE_PD_SINGLE = 0x1  # Single photodiode sensor. Only one ipd input active at the same time.
SENSOR_TYPE_THERMO = 0x2  # Thermopile sensor
SENSOR_TYPE_PYRO = 0x3  # Pyroelectric sensor
SENSOR_TYPE_4Q = 0x4  # 4Q Sensor
SENSOR_SUBTYPE_NONE = 0x0  # No sensor. This value is used to mark RAM data structure for 'no sensor connected'. Do not write this value to the EEPROM.
SENSOR_SUBTYPE_PD_ADAPTER = 0x01  # Photodiode adapter (no temperature sensor)
SENSOR_SUBTYPE_PD_SINGLE_STD = 0x02  # Standard single photodiode sensor (no temperature sensor)
SENSOR_SUBTYPE_PD_SINGLE_FSR = 0x03  # One single photodiode. Filter position set by a slide on the sensor selects responsivity data set to use. (no temperature sensor)
SENSOR_SUBTYPE_PD_SINGLE_STD_T = 0x12  # Standard single photodiode sensor (with temperature sensor)
SENSOR_SUBTYPE_THERMO_ADAPTER = 0x01  # Thermopile adapter (no temperature sensor)
SENSOR_SUBTYPE_THERMO_STD = 0x02  # Standard thermopile sensor (no temperature sensor)
SENSOR_SUBTYPE_THERMO_STD_T = 0x12  # Standard thermopile sensor (with temperature sensor)
SENSOR_SUBTYPE_PYRO_ADAPTER = 0x01  # Pyroelectric adapter (no temperature sensor)
SENSOR_SUBTYPE_PYRO_STD = 0x02  # Standard pyroelectric sensor (no temperature sensor)
SENSOR_SUBTYPE_PYRO_STD_T = 0x12  # Standard pyroelectric sensor (with temperature sensor)
TLPM_SENS_FLAG_IS_POWER = 0x0001  # Power sensor
TLPM_SENS_FLAG_IS_ENERGY = 0x0002  # Energy sensor
TLPM_SENS_FLAG_IS_RESP_SET = 0x0010  # Responsivity settable
TLPM_SENS_FLAG_IS_WAVEL_SET = 0x0020  # Wavelength settable
TLPM_SENS_FLAG_IS_TAU_SET = 0x0040  # Time constant tau settable
TLPM_SENS_FLAG_HAS_TEMP = 0x0100  # Temperature sensor included

class TLPMX:

	def __init__(self, resourceName = None, IDQuery = False, resetDevice = False):
		"""
		This function initializes the instrument driver session and performs the following initialization actions:
		
		(1) Opens a session to the Default Resource Manager resource and a session to the specified device using the Resource Name.
		(2) Performs an identification query on the instrument.
		(3) Resets the instrument to a known state.
		(4) Sends initialization commands to the instrument.
		(5) Returns an instrument handle which is used to distinguish between different sessions of this instrument driver.
		
		Notes:
		(1) Each time this function is invoked a unique session is opened.  
		
		Args:
			resourceName (create_string_buffer)
			IDQuery (c_bool):This parameter specifies whether an identification query is performed during the initialization process.
			
			VI_TRUE  (1): Do query (default).
			VI_FALSE (0): Skip query.
			
			
			resetDevice (c_bool):This parameter specifies whether the instrument is reset during the initialization process.
			
			VI_TRUE  (1) - instrument is reset (default)
			VI_FALSE (0) - no reset 
			
			
		"""
		if sizeof(c_voidp) == 4:
			dll_name = "TLPMX_32.dll"
			dllabspath = os.path.dirname(os.path.abspath(__file__)) + os.path.sep + dll_name
			self.dll = cdll.LoadLibrary(dllabspath)
		else:
			dll_name = "TLPMX_64.dll"
			dllabspath = os.path.dirname(os.path.abspath(__file__)) + os.path.sep + dll_name
			self.dll = cdll.LoadLibrary(dllabspath)

		self.devSession = c_long()
		self.devSession.value = 0
		if resourceName!= None:
			pInvokeResult = self.dll.TLPMX_init(resourceName, IDQuery, resetDevice, byref(self.devSession))
			self.__testForError(pInvokeResult)


	def __testForError(self, status):
		if status < 0:
			self.__throwError(status)
		return status

	def __throwError(self, code):
		msg = create_string_buffer(1024)
		self.dll.TLPMX_errorMessage(self.devSession, c_int(code), msg)
		raise NameError(c_char_p(msg.raw).value)

	def open(self, resourceName, IDQuery, resetDevice):
		"""
		This function initializes the instrument driver session and performs the following initialization actions:
		
		(1) Opens a session to the Default Resource Manager resource and a session to the specified device using the Resource Name.
		(2) Performs an identification query on the instrument.
		(3) Resets the instrument to a known state.
		(4) Sends initialization commands to the instrument.
		(5) Returns an instrument handle which is used to distinguish between different sessions of this instrument driver.
		
		Notes:
		(1) Each time this function is invoked a unique session is opened.  
		
		Args:
			resourceName (create_string_buffer)
			IDQuery (c_bool):This parameter specifies whether an identification query is performed during the initialization process.
			
			VI_TRUE  (1): Do query (default).
			VI_FALSE (0): Skip query.
			
			
			resetDevice (c_bool):This parameter specifies whether the instrument is reset during the initialization process.
			
			VI_TRUE  (1) - instrument is reset (default)
			VI_FALSE (0) - no reset 
			
			
		Returns:
			int: The return value, 0 is for success
		"""
		self.dll.TLPMX_close(self.devSession)
		self.devSession.value = 0
		pInvokeResult = self.dll.TLPMX_init(resourceName, IDQuery, resetDevice, byref(self.devSession))
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def close(self):
		"""
		This function closes the instrument driver session.
		
		Note: The instrument must be reinitialized to use it again.
		
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_close(self.devSession)
		return pInvokeResult

	def findRsrc(self, resourceCount):
		"""
		This function finds all driver compatible devices attached to the PC and returns the number of found devices.
		
		Note:
		(1) The function additionally stores information like system name about the found resources internally. This information can be retrieved with further functions from the class, e.g. <Get Resource Description> and <Get Resource Information>.
		
		
		Args:
			resourceCount(c_uint32 use with byref) : The number of connected devices that are supported by this driver.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_findRsrc(self.devSession, resourceCount)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getRsrcName(self, index, resourceName):
		"""
		This function gets the resource name string needed to open a device with <Initialize>.
		
		Notes:
		(1) The data provided by this function was updated at the last call of <Find Resources>.
		
		Args:
			index(c_uint32) : This parameter accepts the index of the device to get the resource descriptor from.
			
			Notes: 
			(1) The index is zero based. The maximum index to be used here is one less than the number of devices found by the last call of <Find Resources>.
			
			resourceName(create_string_buffer(1024)) : This parameter returns the resource descriptor. Use this descriptor to specify the device in <Initialize>.
			
			Notes:
			(1) The array must contain at least TLPM_BUFFER_SIZE (256) elements ViChar[256].
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getRsrcName(self.devSession, index, resourceName)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getRsrcInfo(self, index, modelName, serialNumber, manufacturer, deviceAvailable):
		"""
		This function gets information about a connected resource.
		
		Notes:
		(1) The data provided by this function was updated at the last call of <Find Resources>.
		
		Args:
			index(c_uint32) : This parameter accepts the index of the device to get the resource descriptor from.
			
			Notes: 
			(1) The index is zero based. The maximum index to be used here is one less than the number of devices found by the last call of <Find Resources>.
			
			modelName(create_string_buffer(1024)) : This parameter returns the model name of the device.
			
			Notes:
			(1) The array must contain at least TLPM_BUFFER_SIZE (256) elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this parameter.
			(3) Serial interfaces over Bluetooth will return the interface name instead of the device model name.
			serialNumber(create_string_buffer(1024)) : This parameter returns the serial number of the device.
			
			Notes:
			(1) The array must contain at least TLPM_BUFFER_SIZE (256) elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this parameter.
			(3) The serial number is not available for serial interfaces over Bluetooth.
			manufacturer(create_string_buffer(1024)) : This parameter returns the manufacturer name of the device.
			
			Notes:
			(1) The array must contain at least TLPM_BUFFER_SIZE (256) elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this parameter.
			(3) The manufacturer name is not available for serial interfaces over Bluetooth.
			deviceAvailable(c_int16 use with byref) : Returns the information if the device is available.
			Devices that are not available are used by other applications.
			
			Notes:
			(1) You may pass VI_NULL if you do not need this parameter.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getRsrcInfo(self.devSession, index, modelName, serialNumber, manufacturer, deviceAvailable)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def writeRegister(self, reg, value):
		"""
		This function writes the content of any writable instrument register. Refer to your instrument's user's manual for more details on status structure registers.
		
		
		Args:
			reg(c_int16) : Specifies the register to be used for operation. This parameter can be any of the following constants:
			
			  TLPM_REG_SRE         (1): Service Request Enable
			  TLPM_REG_ESE         (3): Standard Event Enable
			  TLPM_REG_OPER_ENAB   (6): Operation Event Enable Register
			  TLPM_REG_OPER_PTR    (7): Operation Positive Transition
			  TLPM_REG_OPER_NTR    (8): Operation Negative Transition
			  TLPM_REG_QUES_ENAB  (11): Questionable Event Enable Reg.
			  TLPM_REG_QUES_PTR   (12): Questionable Positive Transition
			  TLPM_REG_QUES_NTR   (13): Questionable Negative Transition
			  TLPM_REG_MEAS_ENAB  (16): Measurement Event Enable Register
			  TLPM_REG_MEAS_PTR   (17): Measurement Positive Transition
			  TLPM_REG_MEAS_NTR   (18): Measurement Negative Transition
			  TLPM_REG_AUX_ENAB   (21): Auxiliary Event Enable Register
			  TLPM_REG_AUX_PTR    (22): Auxiliary Positive Transition
			  TLPM_REG_AUX_NTR    (23): Auxiliary Negative Transition 
			
			value(c_int16) : This parameter specifies the new value of the selected register.
			
			These register bits are defined:
			
			STATUS BYTE bits (see IEEE488.2-1992 §11.2)
			TLPM_STATBIT_STB_AUX        (0x01): Auxiliary summary
			TLPM_STATBIT_STB_MEAS       (0x02): Device Measurement Summary
			TLPM_STATBIT_STB_EAV        (0x04): Error available
			TLPM_STATBIT_STB_QUES       (0x08): Questionable Status Summary
			TLPM_STATBIT_STB_MAV        (0x10): Message available
			TLPM_STATBIT_STB_ESB        (0x20): Event Status Bit
			TLPM_STATBIT_STB_MSS        (0x40): Master summary status
			TLPM_STATBIT_STB_OPER       (0x80): Operation Status Summary
			
			STANDARD EVENT STATUS REGISTER bits (see IEEE488.2-1992 §11.5.1)
			TLPM_STATBIT_ESR_OPC        (0x01): Operation complete
			TLPM_STATBIT_ESR_RQC        (0x02): Request control
			TLPM_STATBIT_ESR_QYE        (0x04): Query error
			TLPM_STATBIT_ESR_DDE        (0x08): Device-Specific error
			TLPM_STATBIT_ESR_EXE        (0x10): Execution error
			TLPM_STATBIT_ESR_CME        (0x20): Command error
			TLPM_STATBIT_ESR_URQ        (0x40): User request
			TLPM_STATBIT_ESR_PON        (0x80): Power on
			
			QUESTIONABLE STATUS REGISTER bits (see SCPI 99.0 §9)
			TLPM_STATBIT_QUES_VOLT      (0x0001): Questionable voltage measurement
			TLPM_STATBIT_QUES_CURR      (0x0002): Questionable current measurement
			TLPM_STATBIT_QUES_TIME      (0x0004): Questionable time measurement
			TLPM_STATBIT_QUES_POW       (0x0008): Questionable power measurement
			TLPM_STATBIT_QUES_TEMP      (0x0010): Questionable temperature measurement
			TLPM_STATBIT_QUES_FREQ      (0x0020): Questionable frequency measurement
			TLPM_STATBIT_QUES_PHAS      (0x0040): Questionable phase measurement
			TLPM_STATBIT_QUES_MOD       (0x0080): Questionable modulation measurement
			TLPM_STATBIT_QUES_CAL       (0x0100): Questionable calibration
			TLPM_STATBIT_QUES_ENER      (0x0200): Questionable energy measurement
			TLPM_STATBIT_QUES_10        (0x0400): Reserved
			TLPM_STATBIT_QUES_11        (0x0800): Reserved
			TLPM_STATBIT_QUES_12        (0x1000): Reserved
			TLPM_STATBIT_QUES_INST      (0x2000): Instrument summary
			TLPM_STATBIT_QUES_WARN      (0x4000): Command warning
			TLPM_STATBIT_QUES_15        (0x8000): Reserved
			
			OPERATION STATUS REGISTER bits (see SCPI 99.0 §9)
			TLPM_STATBIT_OPER_CAL       (0x0001): The instrument is currently performing a calibration.
			TLPM_STATBIT_OPER_SETT      (0x0002): The instrument is waiting for signals to stabilize for measurements.
			TLPM_STATBIT_OPER_RANG      (0x0004): The instrument is currently changing its range.
			TLPM_STATBIT_OPER_SWE       (0x0008): A sweep is in progress.
			TLPM_STATBIT_OPER_MEAS      (0x0010): The instrument is actively measuring.
			TLPM_STATBIT_OPER_TRIG      (0x0020): The instrument is in a “wait for trigger” state of the trigger model.
			TLPM_STATBIT_OPER_ARM       (0x0040): The instrument is in a “wait for arm” state of the trigger model.
			TLPM_STATBIT_OPER_CORR      (0x0080): The instrument is currently performing a correction (Auto-PID tune).
			TLPM_STATBIT_OPER_SENS      (0x0100): Optical powermeter sensor connected and operable.
			TLPM_STATBIT_OPER_DATA      (0x0200): Measurement data ready for fetch.
			TLPM_STATBIT_OPER_THAC      (0x0400): Thermopile accelerator active.
			TLPM_STATBIT_OPER_11        (0x0800): Reserved
			TLPM_STATBIT_OPER_12        (0x1000): Reserved
			TLPM_STATBIT_OPER_INST      (0x2000): One of n multiple logical instruments is reporting OPERational status.
			TLPM_STATBIT_OPER_PROG      (0x4000): A user-defined programming is currently in the run state.
			TLPM_STATBIT_OPER_15        (0x8000): Reserved
			
			Thorlabs defined MEASRUEMENT STATUS REGISTER bits
			TLPM_STATBIT_MEAS_0         (0x0001): Reserved
			TLPM_STATBIT_MEAS_1         (0x0002): Reserved
			TLPM_STATBIT_MEAS_2         (0x0004): Reserved
			TLPM_STATBIT_MEAS_3         (0x0008): Reserved
			TLPM_STATBIT_MEAS_4         (0x0010): Reserved
			TLPM_STATBIT_MEAS_5         (0x0020): Reserved
			TLPM_STATBIT_MEAS_6         (0x0040): Reserved
			TLPM_STATBIT_MEAS_7         (0x0080): Reserved
			TLPM_STATBIT_MEAS_8         (0x0100): Reserved
			TLPM_STATBIT_MEAS_9         (0x0200): Reserved
			TLPM_STATBIT_MEAS_10        (0x0400): Reserved
			TLPM_STATBIT_MEAS_11        (0x0800): Reserved
			TLPM_STATBIT_MEAS_12        (0x1000): Reserved
			TLPM_STATBIT_MEAS_13        (0x2000): Reserved
			TLPM_STATBIT_MEAS_14        (0x4000): Reserved
			TLPM_STATBIT_MEAS_15        (0x8000): Reserved
			
			Thorlabs defined Auxiliary STATUS REGISTER bits
			TLPM_STATBIT_AUX_NTC        (0x0001): Auxiliary NTC temperature sensor connected.
			TLPM_STATBIT_AUX_EMM        (0x0002): External measurement module connected.
			TLPM_STATBIT_AUX_2          (0x0004): Reserved
			TLPM_STATBIT_AUX_3          (0x0008): Reserved
			TLPM_STATBIT_AUX_EXPS       (0x0010): External power supply connected
			TLPM_STATBIT_AUX_BATC       (0x0020): Battery charging
			TLPM_STATBIT_AUX_BATL       (0x0040): Battery low
			TLPM_STATBIT_AUX_IPS        (0x0080): Apple(tm) authentification supported.
			TLPM_STATBIT_AUX_IPF        (0x0100): Apple(tm) authentification failed.
			TLPM_STATBIT_AUX_9          (0x0200): Reserved
			TLPM_STATBIT_AUX_10         (0x0400): Reserved
			TLPM_STATBIT_AUX_11         (0x0800): Reserved
			TLPM_STATBIT_AUX_12         (0x1000): Reserved
			TLPM_STATBIT_AUX_13         (0x2000): Reserved
			TLPM_STATBIT_AUX_14         (0x4000): Reserved
			TLPM_STATBIT_AUX_15         (0x8000): Reserved
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_writeRegister(self.devSession, reg, value)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def readRegister(self, reg, value):
		"""
		This function reads the content of any readable instrument register. Refer to your instrument's user's manual for more details on status structure registers.
		
		
		Args:
			reg(c_int16) : Specifies the register to be used for operation. This parameter can be any of the following constants:
			
			  TLPM_REG_STB         (0): Status Byte Register
			  TLPM_REG_SRE         (1): Service Request Enable
			  TLPM_REG_ESB         (2): Standard Event Status Register
			  TLPM_REG_ESE         (3): Standard Event Enable
			  TLPM_REG_OPER_COND   (4): Operation Condition Register
			  TLPM_REG_OPER_EVENT  (5): Operation Event Register
			  TLPM_REG_OPER_ENAB   (6): Operation Event Enable Register
			  TLPM_REG_OPER_PTR    (7): Operation Positive Transition
			  TLPM_REG_OPER_NTR    (8): Operation Negative Transition
			  TLPM_REG_QUES_COND   (9): Questionable Condition Register
			  TLPM_REG_QUES_EVENT (10): Questionable Event Register
			  TLPM_REG_QUES_ENAB  (11): Questionable Event Enable Reg.
			  TLPM_REG_QUES_PTR   (12): Questionable Positive Transition
			  TLPM_REG_QUES_NTR   (13): Questionable Negative Transition
			  TLPM_REG_MEAS_COND  (14): Measurement Condition Register
			  TLPM_REG_MEAS_EVENT (15): Measurement Event Register
			  TLPM_REG_MEAS_ENAB  (16): Measurement Event Enable Register
			  TLPM_REG_MEAS_PTR   (17): Measurement Positive Transition
			  TLPM_REG_MEAS_NTR   (18): Measurement Negative Transition
			  TLPM_REG_AUX_COND   (19): Auxiliary Condition Register
			  TLPM_REG_AUX_EVENT  (20): Auxiliary Event Register
			  TLPM_REG_AUX_ENAB   (21): Auxiliary Event Enable Register
			  TLPM_REG_AUX_PTR    (22): Auxiliary Positive Transition
			  TLPM_REG_AUX_NTR    (23): Auxiliary Negative Transition 
			
			value(c_int16 use with byref) : This parameter returns the value of the selected register.
			
			These register bits are defined:
			
			STATUS BYTE bits (see IEEE488.2-1992 §11.2)
			TLPM_STATBIT_STB_AUX        (0x01): Auxiliary summary
			TLPM_STATBIT_STB_MEAS       (0x02): Device Measurement Summary
			TLPM_STATBIT_STB_EAV        (0x04): Error available
			TLPM_STATBIT_STB_QUES       (0x08): Questionable Status Summary
			TLPM_STATBIT_STB_MAV        (0x10): Message available
			TLPM_STATBIT_STB_ESB        (0x20): Event Status Bit
			TLPM_STATBIT_STB_MSS        (0x40): Master summary status
			TLPM_STATBIT_STB_OPER       (0x80): Operation Status Summary
			
			STANDARD EVENT STATUS REGISTER bits (see IEEE488.2-1992 §11.5.1)
			TLPM_STATBIT_ESR_OPC        (0x01): Operation complete
			TLPM_STATBIT_ESR_RQC        (0x02): Request control
			TLPM_STATBIT_ESR_QYE        (0x04): Query error
			TLPM_STATBIT_ESR_DDE        (0x08): Device-Specific error
			TLPM_STATBIT_ESR_EXE        (0x10): Execution error
			TLPM_STATBIT_ESR_CME        (0x20): Command error
			TLPM_STATBIT_ESR_URQ        (0x40): User request
			TLPM_STATBIT_ESR_PON        (0x80): Power on
			
			QUESTIONABLE STATUS REGISTER bits (see SCPI 99.0 §9)
			TLPM_STATBIT_QUES_VOLT      (0x0001): Questionable voltage measurement
			TLPM_STATBIT_QUES_CURR      (0x0002): Questionable current measurement
			TLPM_STATBIT_QUES_TIME      (0x0004): Questionable time measurement
			TLPM_STATBIT_QUES_POW       (0x0008): Questionable power measurement
			TLPM_STATBIT_QUES_TEMP      (0x0010): Questionable temperature measurement
			TLPM_STATBIT_QUES_FREQ      (0x0020): Questionable frequency measurement
			TLPM_STATBIT_QUES_PHAS      (0x0040): Questionable phase measurement
			TLPM_STATBIT_QUES_MOD       (0x0080): Questionable modulation measurement
			TLPM_STATBIT_QUES_CAL       (0x0100): Questionable calibration
			TLPM_STATBIT_QUES_ENER      (0x0200): Questionable energy measurement
			TLPM_STATBIT_QUES_10        (0x0400): Reserved
			TLPM_STATBIT_QUES_11        (0x0800): Reserved
			TLPM_STATBIT_QUES_12        (0x1000): Reserved
			TLPM_STATBIT_QUES_INST      (0x2000): Instrument summary
			TLPM_STATBIT_QUES_WARN      (0x4000): Command warning
			TLPM_STATBIT_QUES_15        (0x8000): Reserved
			
			OPERATION STATUS REGISTER bits (see SCPI 99.0 §9)
			TLPM_STATBIT_OPER_CAL       (0x0001): The instrument is currently performing a calibration.
			TLPM_STATBIT_OPER_SETT      (0x0002): The instrument is waiting for signals to stabilize for measurements.
			TLPM_STATBIT_OPER_RANG      (0x0004): The instrument is currently changing its range.
			TLPM_STATBIT_OPER_SWE       (0x0008): A sweep is in progress.
			TLPM_STATBIT_OPER_MEAS      (0x0010): The instrument is actively measuring.
			TLPM_STATBIT_OPER_TRIG      (0x0020): The instrument is in a “wait for trigger” state of the trigger model.
			TLPM_STATBIT_OPER_ARM       (0x0040): The instrument is in a “wait for arm” state of the trigger model.
			TLPM_STATBIT_OPER_CORR      (0x0080): The instrument is currently performing a correction (Auto-PID tune).
			TLPM_STATBIT_OPER_SENS      (0x0100): Optical powermeter sensor connected and operable.
			TLPM_STATBIT_OPER_DATA      (0x0200): Measurement data ready for fetch.
			TLPM_STATBIT_OPER_THAC      (0x0400): Thermopile accelerator active.
			TLPM_STATBIT_OPER_11        (0x0800): Reserved
			TLPM_STATBIT_OPER_12        (0x1000): Reserved
			TLPM_STATBIT_OPER_INST      (0x2000): One of n multiple logical instruments is reporting OPERational status.
			TLPM_STATBIT_OPER_PROG      (0x4000): A user-defined programming is currently in the run state.
			TLPM_STATBIT_OPER_15        (0x8000): Reserved
			
			Thorlabs defined MEASRUEMENT STATUS REGISTER bits
			TLPM_STATBIT_MEAS_0         (0x0001): Reserved
			TLPM_STATBIT_MEAS_1         (0x0002): Reserved
			TLPM_STATBIT_MEAS_2         (0x0004): Reserved
			TLPM_STATBIT_MEAS_3         (0x0008): Reserved
			TLPM_STATBIT_MEAS_4         (0x0010): Reserved
			TLPM_STATBIT_MEAS_5         (0x0020): Reserved
			TLPM_STATBIT_MEAS_6         (0x0040): Reserved
			TLPM_STATBIT_MEAS_7         (0x0080): Reserved
			TLPM_STATBIT_MEAS_8         (0x0100): Reserved
			TLPM_STATBIT_MEAS_9         (0x0200): Reserved
			TLPM_STATBIT_MEAS_10        (0x0400): Reserved
			TLPM_STATBIT_MEAS_11        (0x0800): Reserved
			TLPM_STATBIT_MEAS_12        (0x1000): Reserved
			TLPM_STATBIT_MEAS_13        (0x2000): Reserved
			TLPM_STATBIT_MEAS_14        (0x4000): Reserved
			TLPM_STATBIT_MEAS_15        (0x8000): Reserved
			
			Thorlabs defined Auxiliary STATUS REGISTER bits
			TLPM_STATBIT_AUX_NTC        (0x0001): Auxiliary NTC temperature sensor connected.
			TLPM_STATBIT_AUX_EMM        (0x0002): External measurement module connected.
			TLPM_STATBIT_AUX_2          (0x0004): Reserved
			TLPM_STATBIT_AUX_3          (0x0008): Reserved
			TLPM_STATBIT_AUX_EXPS       (0x0010): External power supply connected
			TLPM_STATBIT_AUX_BATC       (0x0020): Battery charging
			TLPM_STATBIT_AUX_BATL       (0x0040): Battery low
			TLPM_STATBIT_AUX_IPS        (0x0080): Apple(tm) authentification supported.
			TLPM_STATBIT_AUX_IPF        (0x0100): Apple(tm) authentification failed.
			TLPM_STATBIT_AUX_9          (0x0200): Reserved
			TLPM_STATBIT_AUX_10         (0x0400): Reserved
			TLPM_STATBIT_AUX_11         (0x0800): Reserved
			TLPM_STATBIT_AUX_12         (0x1000): Reserved
			TLPM_STATBIT_AUX_13         (0x2000): Reserved
			TLPM_STATBIT_AUX_14         (0x4000): Reserved
			TLPM_STATBIT_AUX_15         (0x8000): Reserved
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_readRegister(self.devSession, reg, value)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def presetRegister(self):
		"""
		This function presets all status registers to default.
		
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_presetRegister(self.devSession)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def sendNTPRequest(self, timeMode, timeZone, IPAddress):
		"""
		This function sets the system date and time of the powermeter.
		
		Notes:
		(1) Date and time are displayed on instruments screen and are used as timestamp for data saved to memory card.
		(2) The function is only available on PM100D, PM200, PM400.
		
		Args:
			timeMode(c_int16)
			timeZone(c_int16)
			IPAddress(create_string_buffer(1024))
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_sendNTPRequest(self.devSession, timeMode, timeZone, IPAddress)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setTime(self, year, month, day, hour, minute, second):
		"""
		This function sets the system date and time of the powermeter.
		
		Notes:
		(1) Date and time are displayed on instruments screen and are used as timestamp for data saved to memory card.
		(2) The function is only available on PM100D, PM200, PM400.
		
		Args:
			year(c_int16) : This parameter specifies the actual year in the format yyyy e.g. 2009.
			month(c_int16) : This parameter specifies the actual month in the format mm e.g. 01.
			day(c_int16) : This parameter specifies the actual day in the format dd e.g. 15.
			
			hour(c_int16) : This parameter specifies the actual hour in the format hh e.g. 14.
			
			minute(c_int16) : This parameter specifies the actual minute in the format mm e.g. 43.
			
			second(c_int16) : This parameter specifies the actual second in the format ss e.g. 50.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setTime(self.devSession, year, month, day, hour, minute, second)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getTime(self, year, month, day, hour, minute, second):
		"""
		This function returns the system date and time of the powermeter.
		
		Notes:
		(1) Date and time are displayed on instruments screen and are used as timestamp for data saved to memory card.
		(2) The function is only available on PM100D, PM200, PM400.
		
		Args:
			year(c_int16 use with byref) : This parameter specifies the actual year in the format yyyy.
			month(c_int16 use with byref) : This parameter specifies the actual month in the format mm.
			day(c_int16 use with byref) : This parameter specifies the actual day in the format dd.
			hour(c_int16 use with byref) : This parameter specifies the actual hour in the format hh.
			minute(c_int16 use with byref) : This parameter specifies the actual minute in the format mm.
			second(c_int16 use with byref) : This parameter specifies the actual second in the format ss.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getTime(self.devSession, year, month, day, hour, minute, second)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setSummertime(self, timeMode):
		"""
		This function sets the clock to summertime.
		
		Notes:
		(1) Date and time are displayed on instruments screen and are used as timestamp for data saved to memory card.
		(2) The function is only available on PM5020
		
		Args:
			timeMode(c_int16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setSummertime(self.devSession, timeMode)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getSummertime(self, timeMode):
		"""
		This function returns if the device uses the summertime.
		
		Notes:
		(1) Date and time are displayed on instruments screen and are used as timestamp for data saved to memory card.
		(2) The function is only available on PM5020.
		
		Args:
			timeMode(c_int16 use with byref)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getSummertime(self.devSession, timeMode)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setLineFrequency(self, lineFrequency):
		"""
		This function selects the line frequency.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200.
		
		
		Args:
			lineFrequency(c_int16) : This parameter specifies the line frequency.
			
			Accepted values:
			  TLPM_LINE_FREQ_50 (50): 50Hz
			  TLPM_LINE_FREQ_60 (60): 60Hz
			
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setLineFrequency(self.devSession, lineFrequency)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getLineFrequency(self, lineFrequency):
		"""
		This function returns the selected line frequency.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200.
		
		
		Args:
			lineFrequency(c_int16 use with byref) : This parameter returns the selected line frequency in Hz.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getLineFrequency(self.devSession, lineFrequency)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getBatteryVoltage(self, voltage):
		"""
		This function is used to obtain the battery voltage readings from the instrument.
		
		Remark:
		(1) This function is only supported with the PM160 and PM160T.
		(2) This function obtains the latest battery voltage measurement result.
		(3) With the USB cable connected this function will obtain the loading voltage. Only with USB cable disconnected (Bluetooth connection) the actual battery voltage can be read. 
		
		Args:
			voltage(c_double use with byref) : This parameter returns the battery voltage in volts [V].
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getBatteryVoltage(self.devSession, voltage)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDispBrightness(self, val):
		"""
		This function sets the display brightness.
		
		Args:
			val(c_double) : This parameter specifies the display brightness.
			
			Range   : 0.0 .. 1.0
			Default : 1.0
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDispBrightness(self.devSession, val)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDispBrightness(self, pVal):
		"""
		This function returns the display brightness.
		
		
		Args:
			pVal(c_double use with byref) : This parameter returns the display brightness. Value range is 0.0 to 1.0.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDispBrightness(self.devSession, pVal)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDispContrast(self, val):
		"""
		This function sets the display contrast of a PM100D.
		
		Note: The function is available on PM100D only.
		
		Args:
			val(c_double) : This parameter specifies the display contrast.
			
			Range   : 0.0 .. 1.0
			Default : 0.5
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDispContrast(self.devSession, val)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDispContrast(self, pVal):
		"""
		This function returns the display contrast of a PM100D.
		
		Note: This function is available on PM100D only
		
		Args:
			pVal(c_double use with byref) : This parameter returns the display contrast (0..1).
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDispContrast(self.devSession, pVal)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def beep(self):
		"""
		Plays a beep sound.
		
		Note: Only supported by PM5020.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_beep(self.devSession)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setInputFilterState(self, inputFilterState, channel):
		"""
		This function sets the instrument's photodiode input filter state.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			inputFilterState(c_int16) : This parameter specifies the input filter mode.
			
			Acceptable values:
			  TLPM_INPUT_FILTER_STATE_OFF (0) input filter off
			  TLPM_INPUT_FILTER_STATE_ON  (1) input filter on
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setInputFilterState(self.devSession, inputFilterState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getInputFilterState(self, inputFilterState, channel):
		"""
		This function returns the instrument's photodiode input filter state.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			inputFilterState(c_int16 use with byref) : This parameter returns the input filter state.
			
			Return values:
			  TLPM_INPUT_FILTER_STATE_OFF (0) input filter off
			  TLPM_INPUT_FILTER_STATE_ON  (1) input filter on
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getInputFilterState(self.devSession, inputFilterState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAccelState(self, accelState, channel):
		"""
		This function sets the thermopile acceleration state.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200.
		
		
		Args:
			accelState(c_int16) : This parameter specifies the thermopile acceleration mode.
			
			Acceptable values:
			  TLPM_ACCELERATION_STATE_OFF (0): thermopile acceleration off
			  TLPM_ACCELERATION_STATE_ON  (1): thermopile acceleration on
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAccelState(self.devSession, accelState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAccelState(self, accelState, channel):
		"""
		This function returns the thermopile acceleration state.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			accelState(c_int16 use with byref) : This parameter returns the thermopile acceleration mode.
			
			Return values:
			  TLPM_ACCELERATION_STATE_OFF (0): thermopile acceleration off
			  TLPM_ACCELERATION_STATE_ON  (1): thermopile acceleration on
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAccelState(self.devSession, accelState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAccelMode(self, accelMode, channel):
		"""
		This function sets the thermopile acceleration auto mode.
		
		While thermopile acceleration improves displaying changing measurement values it unfortunately adds extra noise which can become noticeable on constant values measurements. With acceleration mode set to AUTO the instrument enables the acceleration circuitry after big measurement value changes for five times of "Tau". See also functions <Set Thermopile Accelerator Tau> and <Set Thermopile Accelerator State>.
		
		With calling <Set Thermopile Accelerator State> the accelerator mode will always be reset to MANUAL.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			accelMode(c_int16) : This parameter specifies the thermopile acceleration mode.
			
			Acceptable values:
			  TLPM_ACCELERATION_MANUAL (0): auto acceleration off
			  TLPM_ACCELERATION_AUTO   (1): auto acceleration on
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAccelMode(self.devSession, accelMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAccelMode(self, accelMode, channel):
		"""
		This function returns the thermopile acceleration mode.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			accelMode(c_int16 use with byref) : This parameter returns the thermopile acceleration mode.
			
			Return values:
			  TLPM_ACCELERATION_MANUAL (0): auto acceleration off
			  TLPM_ACCELERATION_AUTO   (1): auto acceleration on
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAccelMode(self.devSession, accelMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAccelTau(self, accelTau, channel):
		"""
		This function sets the thermopile acceleration time constant in seconds [s].
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			accelTau(c_double) : This parameter specifies the thermopile acceleration time constant in seconds [s].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAccelTau(self.devSession, accelTau, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAccelTau(self, attribute, accelTau, channel):
		"""
		This function returns the thermopile acceleration time constant in seconds [s].
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			accelTau(c_double use with byref) : This parameter returns the thermopile acceleration time constant in seconds [s].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAccelTau(self.devSession, attribute, accelTau, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setInputAdapterType(self, type, channel):
		"""
		This function sets the sensor type to assume for custom sensors without calibration data memory connected to the instrument.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			type(c_int16) : This parameter specifies the custom sensor type.
			
			Acceptable values:
			 SENSOR_TYPE_PD_SINGLE (1): Photodiode sensor
			 SENSOR_TYPE_THERMO    (2): Thermopile sensor
			 SENSOR_TYPE_PYRO      (3): Pyroelectric sensor
			
			Value SENSOR_TYPE_PYRO is only available for energy meter instruments.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setInputAdapterType(self.devSession, type, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getInputAdapterType(self, type, channel):
		"""
		This function returns the assumed sensor type for custom sensors without calibration data memory connected to the instrument.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			type(c_int16 use with byref) : This parameter returns the custom sensor type.
			
			Remark:
			The meanings of the obtained sensor type are:
			
			Sensor Types:
			 SENSOR_TYPE_PD_SINGLE (1): Photodiode sensor
			 SENSOR_TYPE_THERMO    (2): Thermopile sensor
			 SENSOR_TYPE_PYRO      (3): Pyroelectric sensor
			 SENSOR_TYPE_4Q        (4): 4 Quadrant sensor
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getInputAdapterType(self.devSession, type, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAvgTime(self, avgTime, channel):
		"""
		This function sets the average time for measurement value generation.
		
		Args:
			avgTime(c_double) : This parameter specifies the average time in seconds.
			
			The value will be rounded to the closest multiple of the device's internal sampling rate.
			
			Remark: 
			To get an measurement value from the device the timeout in your application has to be longer than the average time.
			
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAvgTime(self.devSession, avgTime, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAvgTime(self, attribute, avgTime, channel):
		"""
		This function returns the average time for measurement value generation.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			avgTime(c_double use with byref) : This parameter returns the specified average time in seconds.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAvgTime(self.devSession, attribute, avgTime, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAvgCnt(self, averageCount, channel):
		"""
		This function sets the average count for measurement value generation.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		(2) The function is deprecated and kept for legacy reasons. Its recommended to use TLPM_setAvgTime() instead.
		
		
		Args:
			averageCount(c_int16) : This parameter specifies the average count.
			The default value is 1.
			
			Remark: 
			Depending on the powermeter model internal there are taken up to 3000 measurements per second.
			In this example   Average Time = Average Count / 3000 [s].
			To get an measurement value from the device the timeout in your application has to be longer than the calculated average time.
			
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAvgCnt(self.devSession, averageCount, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAvgCnt(self, averageCount, channel):
		"""
		This function returns the average count for measurement value generation.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		(2) The function is deprecated and kept for legacy reasons. Its recommended to use TLPM_getAvgTime() instead.
		
		
		Args:
			averageCount(c_int16 use with byref) : This parameter returns the actual Average Count.
			
			Remark: 
			Depending on the powermeter model internal there are taken up to 3000 measurements per second.
			In this example   Average Time = Average Count / 3000 [s].
			To get an measurement value from the device the timeout in your application has to be longer than the calculated average time.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAvgCnt(self.devSession, averageCount, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAttenuation(self, attenuation, channel):
		"""
		This function sets the input attenuation.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			attenuation(c_double) : This parameter specifies the input attenuation in dezibel [dB].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAttenuation(self.devSession, attenuation, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAttenuation(self, attribute, attenuation, channel):
		"""
		This function returns the input attenuation.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			attenuation(c_double use with byref) : This parameter returns the specified input attenuation in dezibel [dB].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAttenuation(self.devSession, attribute, attenuation, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def startDarkAdjust(self, channel):
		"""
		This function starts the dark current/zero offset adjustment procedure.
		
		Remark: 
		(1) You have to darken the input before starting dark/zero adjustment.
		(2) You can get the state of dark/zero adjustment with <Get Dark Adjustment State>
		(3) You can stop dark/zero adjustment with <Cancel Dark Adjustment>
		(4) You get the dark/zero value with <Get Dark Offset>
		(5) Energy sensors do not support this function
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_startDarkAdjust(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def cancelDarkAdjust(self, channel):
		"""
		This function cancels a running dark current/zero offset adjustment procedure.
		
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_cancelDarkAdjust(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDarkAdjustState(self, state, channel):
		"""
		This function returns the state of a dark current/zero offset adjustment procedure previously initiated by <Start Dark Adjust>.
		
		
		Args:
			state(c_int16 use with byref) : This parameter returns the dark adjustment state.
			
			Possible return values are:
			TLPM_STAT_DARK_ADJUST_FINISHED (0) : no dark adjustment running
			TLPM_STAT_DARK_ADJUST_RUNNING  (1) : dark adjustment is running
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDarkAdjustState(self.devSession, state, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDarkOffset(self, darkOffset, channel):
		"""
		This function returns the dark/zero offset.
		
		The function is not supported with energy sensors.
		
		Args:
			darkOffset(c_double) : This parameter returns the dark/zero offset.
			
			The unit of the returned offset value depends on the sensor type. Photodiodes return the dark offset in ampere [A]. Thermal sensors return the dark offset in volt [V].
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDarkOffset(self.devSession, darkOffset, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDarkOffset(self, darkOffset, channel):
		"""
		This function returns the dark/zero offset.
		
		The function is not supported with energy sensors.
		
		Args:
			darkOffset(c_double use with byref) : This parameter returns the dark/zero offset.
			
			The unit of the returned offset value depends on the sensor type. Photodiodes return the dark offset in ampere [A]. Thermal sensors return the dark offset in volt [V].
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDarkOffset(self.devSession, darkOffset, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setBeamDia(self, beamDiameter, channel):
		"""
		This function sets the users beam diameter in millimeter [mm].
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		(2) Beam diameter set value is used for calculating power and energy density.
		
		
		Args:
			beamDiameter(c_double) : This parameter specifies the users beam diameter in millimeter [mm].
			
			Remark:
			Beam diameter set value is used for calculating power and energy density.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setBeamDia(self.devSession, beamDiameter, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getBeamDia(self, attribute, beamDiameter, channel):
		"""
		This function returns the users beam diameter in millimeter [mm].
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM101, PM102, PM400.
		(2) Beam diameter set value is used for calculating power and energy density.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			
			beamDiameter(c_double use with byref) : This parameter returns the specified beam diameter in millimeter [mm].
			
			Remark:
			Beam diameter set value is used for calculating power and energy density.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getBeamDia(self.devSession, attribute, beamDiameter, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setWavelength(self, wavelength, channel):
		"""
		This function sets the users wavelength in nanometer [nm].
		
		Remark:
		Wavelength set value is used for calculating power.
		
		
		Args:
			wavelength(c_double) : This parameter specifies the users wavelength in nanometer [nm].
			
			Remark:
			Wavelength set value is used for calculating power.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setWavelength(self.devSession, wavelength, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getWavelength(self, attribute, wavelength, channel):
		"""
		This function returns the users wavelength in nanometer [nm].
		
		Remark:
		Wavelength set value is used for calculating power.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			
			wavelength(c_double use with byref) : This parameter returns the specified wavelength in nanometer [nm].
			
			Remark:
			Wavelength set value is used for calculating power.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getWavelength(self.devSession, attribute, wavelength, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPhotodiodeResponsivity(self, response, channel):
		"""
		This function sets the photodiode responsivity in ampere per watt [A/W].
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			response(c_double) : This parameter specifies the photodiode responsivity in ampere per watt [A/W].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPhotodiodeResponsivity(self.devSession, response, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPhotodiodeResponsivity(self, attribute, responsivity, channel):
		"""
		This function returns the photodiode responsivity in ampere per watt [A/W].
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			responsivity(c_double use with byref) : This parameter returns the specified photodiode responsivity in ampere per watt [A/W].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPhotodiodeResponsivity(self.devSession, attribute, responsivity, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setThermopileResponsivity(self, response, channel):
		"""
		This function sets the thermopile responsivity in volt per watt [V/W]
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			response(c_double) : This parameter specifies the thermopile responsivity in volt per watt [V/W]
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setThermopileResponsivity(self.devSession, response, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getThermopileResponsivity(self, attribute, responsivity, channel):
		"""
		This function returns the thermopile responsivity in volt per watt [V/W]
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			responsivity(c_double use with byref) : This parameter returns the specified thermopile responsivity in volt per watt [V/W]
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getThermopileResponsivity(self.devSession, attribute, responsivity, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPyrosensorResponsivity(self, response, channel):
		"""
		This function sets the pyrosensor responsivity in volt per joule [V/J]
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			response(c_double) : This parameter specifies the pyrosensor responsivity in volt per joule [V/J]
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPyrosensorResponsivity(self.devSession, response, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPyrosensorResponsivity(self, attribute, responsivity, channel):
		"""
		This function returns the pyrosensor responsivity in volt per joule [V/J]
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			responsivity(c_double use with byref) : This parameter returns the specified pyrosensor responsivity in volt per joule [V/J]
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPyrosensorResponsivity(self.devSession, attribute, responsivity, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setCurrentAutoRange(self, currentAutorangeMode, channel):
		"""
		This function sets the current auto range mode.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			currentAutorangeMode(c_int16) : This parameter specifies the current auto range mode.
			
			Acceptable values:
			  TLPM_AUTORANGE_CURRENT_OFF (0): current auto range disabled
			  TLPM_AUTORANGE_CURRENT_ON  (1): current auto range enabled
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setCurrentAutoRange(self.devSession, currentAutorangeMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getCurrentAutorange(self, currentAutorangeMode, channel):
		"""
		This function returns the current auto range mode.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			currentAutorangeMode(c_int16 use with byref) : This parameter returns the current auto range mode.
			
			Return values:
			  TLPM_AUTORANGE_CURRENT_OFF (0): current auto range disabled
			  TLPM_AUTORANGE_CURRENT_ON  (1): current auto range enabled
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getCurrentAutorange(self.devSession, currentAutorangeMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setCurrentRange(self, current_to_Measure, channel):
		"""
		This function sets the sensor's current range.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			current_to_Measure(c_double) : This parameter specifies the current value to be measured in ampere [A].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setCurrentRange(self.devSession, current_to_Measure, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getCurrentRange(self, attribute, currentValue, channel):
		"""
		This function returns the actual current range value.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			
			currentValue(c_double use with byref) : This parameter returns the specified current range value in ampere [A].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getCurrentRange(self.devSession, attribute, currentValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getCurrentRanges(self, currentValues, rangeCount, channel):
		"""
		This function returns the actual voltage range value.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			currentValues( (c_double * arrayLength)()) : This parameter returns the specified voltage range value in volts [V].
			
			rangeCount(c_uint16 use with byref)
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getCurrentRanges(self.devSession, currentValues, rangeCount, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setCurrentRangeSearch(self, channel):
		"""
		This function returns the actual voltage range value.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setCurrentRangeSearch(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setCurrentRef(self, currentReferenceValue, channel):
		"""
		This function sets the current reference value.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			currentReferenceValue(c_double) : This parameter specifies the current reference value in amperes [A].
			
			Remark:
			This value is used for calculating differences between the actual current value and this current reference value if Current Reference State is ON.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setCurrentRef(self.devSession, currentReferenceValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getCurrentRef(self, attribute, currentReferenceValue, channel):
		"""
		This function returns the current reference value.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			currentReferenceValue(c_double use with byref) : This parameter returns the specified current reference value in amperes [A].
			
			Remark:
			This value is used for calculating differences between the actual current value and this current reference value if Current Reference State is ON.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getCurrentRef(self.devSession, attribute, currentReferenceValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setCurrentRefState(self, currentReferenceState, channel):
		"""
		This function sets the current reference state.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			currentReferenceState(c_int16) : This parameter specifies the current reference state.
			
			Acceptable values:
			  TLPM_CURRENT_REF_OFF (0): Current reference disabled. Absolute measurement.
			  TLPM_CURRENT_REF_ON  (1): Current reference enabled. Relative measurement.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setCurrentRefState(self.devSession, currentReferenceState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getCurrentRefState(self, currentReferenceState, channel):
		"""
		This function returns the current reference state.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			currentReferenceState(c_int16 use with byref) : This parameter returns the current reference state.
			
			Return values:
			  TLPM_CURRENT_REF_OFF (0): Current reference disabled. Absolute measurement.
			  TLPM_CURRENT_REF_ON  (1): Current reference enabled. Relative measurement.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getCurrentRefState(self.devSession, currentReferenceState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setEnergyRange(self, energyToMeasure, channel):
		"""
		This function sets the pyro sensor's energy range.
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			energyToMeasure(c_double) : This parameter specifies the energy value in joule [J] to be measured.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setEnergyRange(self.devSession, energyToMeasure, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getEnergyRange(self, attribute, energyValue, channel):
		"""
		This function returns the pyro sensor's energy range.
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			
			energyValue(c_double use with byref) : This parameter returns the specified pyro sensor's energy value in joule [J].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getEnergyRange(self.devSession, attribute, energyValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setEnergyRef(self, energyReferenceValue, channel):
		"""
		This function sets the pyro sensor's energy reference value
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		(2) This value is used for calculating differences between the actual energy value and this energy reference value.
		
		
		Args:
			energyReferenceValue(c_double) : This parameter specifies the pyro sensor's energy reference value in joule [J].
			
			Remark:
			This value is used for calculating differences between the actual energy value and this energy reference value if Energy Reference State is ON.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setEnergyRef(self.devSession, energyReferenceValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getEnergyRef(self, attribute, energyReferenceValue, channel):
		"""
		This function returns the specified pyro sensor's energy reference value.
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		(2) The set value is used for calculating differences between the actual energy value and this energy reference value.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			energyReferenceValue(c_double use with byref) : This parameter returns the specified pyro sensor's energy reference value in joule [J].
			
			Remark:
			The set value is used for calculating differences between the actual energy value and this energy reference value if Energy Reference State is ON.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getEnergyRef(self.devSession, attribute, energyReferenceValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setEnergyRefState(self, energyReferenceState, channel):
		"""
		This function sets the instrument's energy reference state.
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			energyReferenceState(c_int16) : This parameter specifies the energy reference state.
			
			Acceptable values:
			  TLPM_ENERGY_REF_OFF (0): Energy reference disabled. Absolute measurement.
			  TLPM_ENERGY_REF_ON  (1): Energy reference enabled. Relative measurement.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setEnergyRefState(self.devSession, energyReferenceState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getEnergyRefState(self, energyReferenceState, channel):
		"""
		This function returns the instrument's energy reference state.
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			energyReferenceState(c_int16 use with byref) : This parameter returns the energy reference state.
			
			Return values:
			  TLPM_ENERGY_REF_OFF (0): Energy reference disabled. Absolute measurement.
			  TLPM_ENERGY_REF_ON  (1): Energy reference enabled. Relative measurement.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getEnergyRefState(self.devSession, energyReferenceState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFreqRange(self, lowerFrequency, upperFrequency, channel):
		"""
		This function returns the instruments frequency measurement range.
		
		Remark:
		The frequency of the input signal is calculated over at least 0.3s. So it takes at least 0.3s to get a new frequency value from the instrument.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, and PM100USB.
		
		
		Args:
			lowerFrequency(c_double use with byref) : This parameter returns the lower instruments frequency in [Hz].
			
			upperFrequency(c_double use with byref) : This parameter returns the upper instruments frequency in [Hz].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFreqRange(self.devSession, lowerFrequency, upperFrequency, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setFreqMode(self, frequencyMode, channel):
		"""
		This function sets the instruments frequency measurement mode. Only for photodiodes.
		
		Notes:
		(1) The function is only available on PM103
		
		
		Args:
			frequencyMode(c_uint16) : This parameter returns the frequency mode.
			
			CW (0)
			PEAK (1)
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setFreqMode(self.devSession, frequencyMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFreqMode(self, frequencyMode, channel):
		"""
		This function returns the instruments frequency measurement mode. 
		
		Notes:
		(1) The function is only available on PM103
		
		
		Args:
			frequencyMode(c_uint16 use with byref) : This parameter returns the frequency mode.
			
			CW (0)
			PEAK (1)
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFreqMode(self.devSession, frequencyMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPowerAutoRange(self, powerAutorangeMode, channel):
		"""
		This function sets the power auto range mode.
		
		
		Args:
			powerAutorangeMode(c_int16) : This parameter specifies the power auto range mode.
			
			Acceptable values:
			  TLPM_AUTORANGE_POWER_OFF (0): power auto range disabled
			  TLPM_AUTORANGE_POWER_ON  (1): power auto range enabled
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPowerAutoRange(self.devSession, powerAutorangeMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPowerAutorange(self, powerAutorangeMode, channel):
		"""
		This function returns the power auto range mode.
		
		
		Args:
			powerAutorangeMode(c_int16 use with byref) : This parameter returns the power auto range mode.
			
			Return values:
			  TLPM_AUTORANGE_POWER_OFF (0): power auto range disabled
			  TLPM_AUTORANGE_POWER_ON  (0): power auto range enabled
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPowerAutorange(self.devSession, powerAutorangeMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPowerRange(self, power_to_Measure, channel):
		"""
		This function sets the sensor's power range.
		
		
		Args:
			power_to_Measure(c_double) : This parameter specifies the most positive signal level expected for the sensor input in watt [W].
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPowerRange(self.devSession, power_to_Measure, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPowerRange(self, attribute, powerValue, channel):
		"""
		This function returns the actual power range value.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			
			powerValue(c_double use with byref) : This parameter returns the specified power range value in watt [W].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPowerRange(self.devSession, attribute, powerValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPowerRef(self, powerReferenceValue, channel):
		"""
		This function sets the power reference value.
		
		
		Args:
			powerReferenceValue(c_double) : This parameter specifies the power reference value.
			
			Remark:
			(1) The power reference value has the unit specified with <Set Power Unit>.
			(2) This value is used for calculating differences between the actual power value and this power reference value if Power Reference State is ON.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPowerRef(self.devSession, powerReferenceValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPowerRef(self, attribute, powerReferenceValue, channel):
		"""
		This function returns the power reference value.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			powerReferenceValue(c_double use with byref) : This parameter returns the specified power reference value.
			
			Remark:
			(1) The power reference value has the unit specified with <Set Power Unit>.
			(2) This value is used for calculating differences between the actual power value and this power reference value if Power Reference State is ON.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPowerRef(self.devSession, attribute, powerReferenceValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPowerRefState(self, powerReferenceState, channel):
		"""
		This function sets the power reference state.
		
		
		Args:
			powerReferenceState(c_int16) : This parameter specifies the power reference state.
			
			Acceptable values:
			  TLPM_POWER_REF_OFF (0): Power reference disabled. Absolute measurement.
			  TLPM_POWER_REF_ON  (1): Power reference enabled. Relative measurement.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPowerRefState(self.devSession, powerReferenceState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPowerRefState(self, powerReferenceState, channel):
		"""
		This function returns the power reference state.
		
		
		Args:
			powerReferenceState(c_int16 use with byref) : This parameter returns the power reference state.
			
			Return values:
			  TLPM_POWER_REF_OFF (0): Power reference disabled. Absolute measurement.
			  TLPM_POWER_REF_ON  (1): Power reference enabled. Relative measurement.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPowerRefState(self.devSession, powerReferenceState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPowerUnit(self, powerUnit, channel):
		"""
		This function sets the unit of the power value.
		
		
		Args:
			powerUnit(c_int16) : This parameter specifies the unit of the pover value.
			
			Acceptable values:
			  TLPM_POWER_UNIT_WATT (0): power in Watt
			  TLPM_POWER_UNIT_DBM  (1): power in dBm
			
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPowerUnit(self.devSession, powerUnit, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPowerUnit(self, powerUnit, channel):
		"""
		This function returns the unit of the power value.
		
		
		Args:
			powerUnit(c_int16 use with byref) : This parameter returns the unit of the power value.
			
			Return values:
			  TLPM_POWER_UNIT_WATT (0): power in Watt
			  TLPM_POWER_UNIT_DBM  (1): power in dBm
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPowerUnit(self.devSession, powerUnit, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPowerCalibrationPointsInformation(self, index, serialNumber, calibrationDate, calibrationPointsCount, author, sensorPosition, channel):
		"""
		Queries the customer adjustment header like serial nr, cal date, nr of points at given index
		
		
		Args:
			index(c_uint16) : Index of the power calibration (range 1...5)
			serialNumber(create_string_buffer(1024)) : Serial Number of the sensor.
			Please provide a buffer of 256 characters.
			calibrationDate(create_string_buffer(1024)) : Last calibration date of this sensor
			Please provide a buffer of 256 characters.
			calibrationPointsCount(c_uint16 use with byref) : Number of calibration points of the power calibration with this sensor
			author(create_string_buffer(1024))
			sensorPosition(c_uint16 use with byref) : The position of the sencor switch of a Thorlabs S130C
			1 = 5mW
			2 = 500mW
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPowerCalibrationPointsInformation(self.devSession, index, serialNumber, calibrationDate, calibrationPointsCount, author, sensorPosition, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPowerCalibrationPointsState(self, index, state, channel):
		"""
		Queries the state if the power calibration of this sensor is activated.
		
		
		Args:
			index(c_uint16)
			state(c_int16 use with byref) : State if the user power calibration is activated and used for the power measurements.
			
			VI_ON: The user power calibration is used
			VI_OFF: The user power calibration is ignored in the power measurements
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPowerCalibrationPointsState(self.devSession, index, state, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPowerCalibrationPointsState(self, index, state, channel):
		"""
		This function activates/inactivates the power calibration of this sensor.
		
		
		Args:
			index(c_uint16) : Index of the power calibration (range 1...5)
			state(c_int16) : State if the user power calibration is activated and used for the power measurements.
			
			VI_ON: The user power calibration is used
			VI_OFF: The user power calibration is ignored in the power measurements
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPowerCalibrationPointsState(self.devSession, index, state, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPowerCalibrationPoints(self, index, pointCounts, wavelengths, powerCorrectionFactors, channel):
		"""
		Returns a list of wavelength and the corresponding power correction factor.
		
		
		Args:
			index(c_uint16)
			pointCounts(c_uint16) : Number of points that are submitted in the wavelength and power correction factors arrays.
			Maximum of 8 wavelength - power correction factors pairs can be calibrated for each sensor.
			wavelengths( (c_double * arrayLength)()) : Array of wavelengths in nm. Requires ascending wavelength order.
			The array must contain <points counts> entries.
			powerCorrectionFactors( (c_double * arrayLength)()) : Array of power correction factorw that correspond to the wavelength array. 
			The array must contain <points counts> entries, same as wavelenght to build wavelength - power correction factors pairs.
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPowerCalibrationPoints(self.devSession, index, pointCounts, wavelengths, powerCorrectionFactors, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPowerCalibrationPoints(self, index, pointCounts, wavelengths, powerCorrectionFactors, author, sensorPosition, channel):
		"""
		Sumbits a list of wavelength and the corresponding measured power correction factors to calibrate the power measurement.
		
		
		Args:
			index(c_uint16) : Index of the power calibration (range 1...5)
			pointCounts(c_uint16) : Number of points that are submitted in the wavelength and power correction factors arrays.
			Maximum of 8 wavelength - power correction factors  pairs can be calibrated for each sensor.
			wavelengths( (c_double * arrayLength)()) : Array of wavelengths in nm. Requires ascending wavelength order.
			The array must contain <points counts> entries.
			powerCorrectionFactors( (c_double * arrayLength)()) : Array of powers correction factors that correspond to the wavelength array. 
			The array must contain <points counts> entries, same as wavelenght to build wavelength - power correction factors  pairs.
			author(create_string_buffer(1024)) : Buffer that contains the name of the editor of the calibration.
			Name of Author limited to 19 chars + ''
			sensorPosition(c_uint16) : The position of the sencor switch of a Thorlabs S130C
			1 = 5mW
			2 = 500mW
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPowerCalibrationPoints(self.devSession, index, pointCounts, wavelengths, powerCorrectionFactors, author, sensorPosition, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def reinitSensor(self, channel):
		"""
		To use the user power calibration, the sensor has to be reconnected.
		Either manually remove and reconnect the sensor to the instrument or use this funtion.
		
		This function will wait 2 seconds until the sensor has been reinitialized.
		
		Args:
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_reinitSensor(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setVoltageAutoRange(self, voltageAutorangeMode, channel):
		"""
		This function sets the voltage auto range mode.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			voltageAutorangeMode(c_int16) : This parameter specifies the voltage auto range mode.
			
			Acceptable values:
			  TLPM_AUTORANGE_VOLTAGE_OFF (0): voltage auto range disabled
			  TLPM_AUTORANGE_VOLTAGE_ON  (1): voltage auto range enabled
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setVoltageAutoRange(self.devSession, voltageAutorangeMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getVoltageAutorange(self, voltageAutorangeMode, channel):
		"""
		This function returns the voltage auto range mode.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			voltageAutorangeMode(c_int16 use with byref) : This parameter returns the voltage auto range mode.
			
			Return values:
			  TLPM_AUTORANGE_VOLTAGE_OFF (0): voltage auto range disabled
			  TLPM_AUTORANGE_VOLTAGE_ON  (1): voltage auto range enabled
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getVoltageAutorange(self.devSession, voltageAutorangeMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setVoltageRange(self, voltage_to_Measure, channel):
		"""
		This function sets the sensor's voltage range.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			voltage_to_Measure(c_double) : This parameter specifies the voltage value to be measured in volts [V].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setVoltageRange(self.devSession, voltage_to_Measure, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getVoltageRange(self, attribute, voltageValue, channel):
		"""
		This function returns the actual voltage range value.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			
			voltageValue(c_double use with byref) : This parameter returns the specified voltage range value in volts [V].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getVoltageRange(self.devSession, attribute, voltageValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getVoltageRanges(self, voltageValues, rangeCount, channel):
		"""
		This function returns the actual voltage range value.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			voltageValues( (c_double * arrayLength)()) : This parameter returns the specified voltage range value in volts [V].
			
			rangeCount(c_uint16 use with byref)
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getVoltageRanges(self.devSession, voltageValues, rangeCount, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setVoltageRangeSearch(self, channel):
		"""
		This function returns the actual voltage range value.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setVoltageRangeSearch(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setVoltageRef(self, voltageReferenceValue, channel):
		"""
		This function sets the voltage reference value.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			voltageReferenceValue(c_double) : This parameter specifies the voltage reference value in volts [V].
			
			Remark:
			This value is used for calculating differences between the actual voltage value and this voltage reference value if Voltage Reference State is ON.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setVoltageRef(self.devSession, voltageReferenceValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getVoltageRef(self, attribute, voltageReferenceValue, channel):
		"""
		This function returns the voltage reference value.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			voltageReferenceValue(c_double use with byref) : This parameter returns the specified voltage reference value in volts [V].
			
			Remark:
			This value is used for calculating differences between the actual voltage value and this voltage reference value if Voltage Reference State is ON.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getVoltageRef(self.devSession, attribute, voltageReferenceValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setVoltageRefState(self, voltageReferenceState, channel):
		"""
		This function sets the voltage reference state.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			voltageReferenceState(c_int16) : This parameter specifies the voltage reference state.
			
			Acceptable values:
			  TLPM_VOLTAGE_REF_OFF (0): Voltage reference disabled. Absolute measurement.
			  TLPM_VOLTAGE_REF_ON  (1): Voltage reference enabled. Relative measurement.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setVoltageRefState(self.devSession, voltageReferenceState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getVoltageRefState(self, voltageReferenceState, channel):
		"""
		This function returns the voltage reference state.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			voltageReferenceState(c_int16 use with byref) : This parameter returns the voltage reference state.
			
			Return values:
			  TLPM_VOLTAGE_REF_OFF (0): Voltage reference disabled. Absolute measurement.
			  TLPM_VOLTAGE_REF_ON  (1): Voltage reference enabled. Relative measurement.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getVoltageRefState(self.devSession, voltageReferenceState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPeakThreshold(self, peakThreshold, channel):
		"""
		This function sets the peak detector threshold.
		
		Remark:
		Peak detector threshold is in percent [%] of the maximum from the actual measurements range.
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			peakThreshold(c_double) : This parameter specifies the peak detector threshold.
			
			Remark:
			Peak detector threshold is in percent [%] of the maximum from the actual measurements range.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPeakThreshold(self.devSession, peakThreshold, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPeakThreshold(self, attribute, peakThreshold, channel):
		"""
		This function returns the peak detector threshold.
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			peakThreshold(c_double use with byref) : This parameter returns the peak detector threshold.
			
			Remark:
			Peak detector threshold is in percent [%] of the maximum from the actual measurements range.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPeakThreshold(self.devSession, attribute, peakThreshold, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def startPeakDetector(self, channel):
		"""
		Starts peak finder. For pyro or photodiode in pulse mode.
		
		Notes:
		(1) The function is only available on PM103
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_startPeakDetector(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def isPeakDetectorRunning(self, isRunning, channel):
		"""
		Tests if peak finder is active at the moment. Same as polling status operation register of sensor and checking for bit 3.
		
		Notes:
		(1) The function is only available on PM103
		
		Args:
			isRunning(c_int16 use with byref) : returns the running state of the peak detector.
			
			VI_TRUE: peak detector is running
			VI_FALSE: peak detector is stopped.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_isPeakDetectorRunning(self.devSession, isRunning, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPeakFilter(self, filter, channel):
		"""
		
		Args:
			filter(c_int16) : Valid valus for this parameter are
			0 = NONE
			1 = OVER
			Use OVER if the signal measured is a rectangular signal.
			If it is a sinus or triangle signal use NONE.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPeakFilter(self.devSession, filter, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPeakFilter(self, filter, channel):
		"""
		
		Args:
			filter(c_int16 use with byref) : Valid valus for this parameter are
			0 = NONE
			1 = OVER
			Use OVER if the signal measured is a rectangular signal.
			If it is a sinus or triangle signal use NONE.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPeakFilter(self.devSession, filter, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setExtNtcParameter(self, r0Coefficient, betaCoefficient, channel):
		"""
		This function sets the temperature calculation coefficients for the NTC sensor externally connected to the instrument (NTC IN).
		
		Notes:
		(1) The function is only available on PM400.
		
		
		Args:
			r0Coefficient(c_double) : This parameter specifies the R0 coefficient in [Ohm] for calculating the temperature from the sensor's resistance by the beta parameter equation. R0 is the NTC's resistance at T0 (25 °C = 298.15 K).
			betaCoefficient(c_double) : This parameter specifies the B coefficient in [K] for calculating the temperature from the sensor's resistance by the beta parameter equation.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setExtNtcParameter(self.devSession, r0Coefficient, betaCoefficient, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getExtNtcParameter(self, attribute, r0Coefficient, betaCoefficient, channel):
		"""
		This function gets the temperature calculation coefficients for the NTC sensor externally connected to the instrument (NTC IN).
		
		Notes:
		(1) The function is only available on PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the values to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			r0Coefficient(c_double use with byref) : This parameter returns the specified R0 coefficient in [Ohm].
			betaCoefficient(c_double use with byref) : This parameter returns the specified B coefficient in [K].
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getExtNtcParameter(self.devSession, attribute, r0Coefficient, betaCoefficient, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setFilterPosition(self, filterPosition):
		"""
		This function sets the current filter position
		
		Notes:
		(1) The function is only available on PM160 with firmware version 1.5.4 and higher
		
		
		Args:
			filterPosition(c_int16) : This parameter specifies the current filter position
			
			Acceptable values:
			  VI_OFF (0): Filter position OFF. The filter value will not be used in the power calculation
			  VI_ON  (1): Filter position ON, The filter value will be used in the power correction
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setFilterPosition(self.devSession, filterPosition)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFilterPosition(self, filterPosition):
		"""
		This function returns the current filter position
		
		Notes:
		(1) The function is only available on PM160 with firmware version 1.5.4 and higher
		
		
		Args:
			filterPosition(c_int16 use with byref) : This parameter returns the current filter position
			
			Acceptable values:
			  VI_OFF (0): Filter position OFF. The filter value will not be used in the power calculation
			  VI_ON  (1): Filter position ON, The filter value will be used in the power correction
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFilterPosition(self.devSession, filterPosition)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setFilterAutoMode(self, filterAutoPositionDetection):
		"""
		This function enables / disables the automatic filter position detection
		
		Notes:
		(1) The function is only available on PM160 with firmware version 1.5.4 and higher
		
		
		Args:
			filterAutoPositionDetection(c_int16) : This parameter specifies if the automatic filter position detection is enabled/disabled
			
			Acceptable values:
			  VI_OFF (0): Filter position detection is OFF. The manual set fitler position is used
			  VI_ON  (1): Filter position detection is ON, The filter position will be automatically detected
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setFilterAutoMode(self.devSession, filterAutoPositionDetection)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFilterAutoMode(self, filterAutoPositionDetection):
		"""
		This function returns if the automatic filter position detection is used
		
		Notes:
		(1) The function is only available on PM160 with firmware version 1.5.4 and higher
		
		
		Args:
			filterAutoPositionDetection(c_int16 use with byref) : This parameter returns if the automatic filter position detection is enabled/disabled
			
			Acceptable values:
			  VI_OFF (0): Filter position detection is OFF. The manual set fitler position is used
			  VI_ON  (1): Filter position detection is ON, The filter position will be automatically detected
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFilterAutoMode(self.devSession, filterAutoPositionDetection)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAnalogOutputSlopeRange(self, minSlope, maxSlope, channel):
		"""
		This function returns range of the responsivity in volts per watt [V/W] for the analog output.
		
		Notes:
		(1) The function is only available on PM101 and PM102
		
		
		
		Args:
			minSlope(c_double use with byref) : This parameter returns the minimum voltage in Volt [V/W] of the analog output.
			Lower voltage is clipped to the minimum.
			
			maxSlope(c_double use with byref) : This parameter returns the maximum voltage in Volt [V/W] of the analog output.
			Higher voltage values are clipped to the maximum.
			
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAnalogOutputSlopeRange(self.devSession, minSlope, maxSlope, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAnalogOutputSlope(self, slope, channel):
		"""
		This function sets the responsivity in volts per watt [V/W] for the analog output.
		
		Notes:
		(1) The function is only available on PM101 and PM102
		
		
		Args:
			slope(c_double) : This parameter specifies the responsivity in volts per watt [V/W].
			
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAnalogOutputSlope(self.devSession, slope, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAnalogOutputSlope(self, attribute, slope, channel):
		"""
		This function returns the responsivity in volts per watt [V/W] for the analog output.
		
		Notes:
		(1) The function is only available on PM101 and PM102
		
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			slope(c_double use with byref) : This parameter returns the specified responsivity in volts per watt [V/W].
			
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAnalogOutputSlope(self.devSession, attribute, slope, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAnalogOutputVoltageRange(self, minVoltage, maxVoltage, channel):
		"""
		This function returns the range in Volt [V] of the analog output.
		
		Notes:
		(1) The function is only available on PM101 and PM102
		
		
		
		Args:
			minVoltage(c_double use with byref) : This parameter returns the minimum voltage in Volt [V] of the analog output.
			Lower voltage is clipped to the minimum.
			
			maxVoltage(c_double use with byref) : This parameter returns the maximum voltage in Volt [V] of the analog output.
			Higher voltage values are clipped to the maximum.
			
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAnalogOutputVoltageRange(self.devSession, minVoltage, maxVoltage, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAnalogOutputVoltage(self, attribute, voltage, channel):
		"""
		This function returns the analog output in Volt [V].
		
		Notes:
		(1) The function is only available on PM101 and PM102
		
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			voltage(c_double use with byref) : This parameter returns the analog output in Volt [V].
			
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAnalogOutputVoltage(self.devSession, attribute, voltage, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAnalogOutputGainRange(self, gainRangeIndex, channel):
		"""
		This function returns the analog output hub in Volt [V].
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			gainRangeIndex(c_int16 use with byref)
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAnalogOutputGainRange(self.devSession, gainRangeIndex, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAnalogOutputGainRange(self, gainRangeIndex, channel):
		"""
		This function returns the analog output hub in Volt [V].
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			gainRangeIndex(c_int16)
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAnalogOutputGainRange(self.devSession, gainRangeIndex, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAnalogOutputRoute(self, routeName, channel):
		"""
		This function returns the analog output hub in Volt [V].
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			routeName(create_string_buffer(1024))
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAnalogOutputRoute(self.devSession, routeName, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAnalogOutputRoute(self, routeStrategy, channel):
		"""
		This function returns the analog output hub in Volt [V].
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			routeStrategy(c_uint16) : TLPM_ANALOG_ROUTE_PUR  (0)  (Direct Route): The raw amplified signal is output. This signal is related to the photo current or voltage. It is not wavelength or zero compensated.
			TLPM_ANALOG_ROUTE_CBA  (1)  (Compensated Base Unit): The raw amplified signal is multiplied with a correction factor in hardware to compensate the dark current/voltage. The signal is the photo current or voltage and is not wavelength compensated.
			TLPM_ANALOG_ROUTE_CMA  (2) (Compensated Main Unit): The raw amplified signal is multiplied with a correction factor in hardware to output a analogue voltage related to power or energy. The signal is zero and wavelength compensated.
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAnalogOutputRoute(self.devSession, routeStrategy, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPositionAnalogOutputSlopeRange(self, minSlope, maxSlope, channel):
		"""
		This function returns range of the responsivity in volts per µm [V/µm] for the analog output.
		
		Notes:
		(1) The function is only available on PM102
		
		
		
		Args:
			minSlope(c_double use with byref) : This parameter returns the minimum slope in [V/µm] of the analog output.
			
			maxSlope(c_double use with byref) : This parameter returns the maximum slope in [V/µm] of the analog output.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPositionAnalogOutputSlopeRange(self.devSession, minSlope, maxSlope, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPositionAnalogOutputSlope(self, slope, channel):
		"""
		This function sets the responsivity in volts per µm [V/µm] for the analog output.
		
		Notes:
		(1) The function is only available on PM102
		
		
		Args:
			slope(c_double) : This parameter specifies the responsivity in volts per µm [V/µm] for the AO2 and AO3 channel 
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPositionAnalogOutputSlope(self.devSession, slope, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPositionAnalogOutputSlope(self, attribute, slope, channel):
		"""
		This function returns the responsivity in volts per µm [V/µm] for the analog output channels.
		
		Notes:
		(1) The function is only available on PM102
		
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			slope(c_double use with byref) : This parameter returns the specified responsivity in volts per µm [V/µm] for the AO2 and AO3 channel 
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPositionAnalogOutputSlope(self.devSession, attribute, slope, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPositionAnalogOutputVoltageRange(self, minVoltage, maxVoltage, channel):
		"""
		This function returns the range in Volt [V] of the analog output.
		
		Notes:
		(1) The function is only available on PM102
		
		
		
		Args:
			minVoltage(c_double use with byref) : This parameter returns the minimum voltage in Volt [V] of the analog output.
			Lower voltage is clipped to the minimum.
			
			maxVoltage(c_double use with byref) : This parameter returns the maximum voltage in Volt [V] of the analog output.
			Higher voltage values are clipped to the maximum.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPositionAnalogOutputVoltageRange(self.devSession, minVoltage, maxVoltage, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPositionAnalogOutputVoltage(self, attribute, voltageX, voltageY, channel):
		"""
		This function returns the analog output in Volt [V].
		
		Notes:
		(1) The function is only available on PM102
		
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			voltageX(c_double use with byref) : This parameter returns the analog output in Volt [V] for the AO2 channel ( x direction)
			
			voltageY(c_double use with byref) : This parameter returns the analog output in Volt [V] for the AO3 channel ( y direction)
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPositionAnalogOutputVoltage(self.devSession, attribute, voltageX, voltageY, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getMeasPinMode(self, state, channel):
		"""
		This function returns the meas pin state
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			state(c_int16 use with byref) : This parameter returns the analog output hub in Volt [V].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getMeasPinMode(self.devSession, state, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getMeasPinPowerLevel(self, level, channel):
		"""
		This function returns the meas pin power level in [W]
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			level(c_double use with byref) : This parameter returns the measure pin output power level in Watt [W].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getMeasPinPowerLevel(self.devSession, level, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setMeasPinPowerLevel(self, level, channel):
		"""
		This function returns the meas pin state
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			level(c_double) : This parameter sets the measure pin output power level in Watt [W].
			
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setMeasPinPowerLevel(self.devSession, level, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getMeasPinEnergyLevel(self, level, channel):
		"""
		This function returns the meas pin energy level in [J]
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			level(c_double use with byref) : This parameter returns the measure pin output energy level in  [J].
			
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getMeasPinEnergyLevel(self.devSession, level, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setMeasPinEnergyLevel(self, level, channel):
		"""
		This function returns the meas pin state
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			level(c_double) : This parameter returns the measurement pin energy level in [J].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setMeasPinEnergyLevel(self.devSession, level, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setNegativePulseWidth(self, pulseDuration, channel):
		"""
		This function sets the low pulse duration in Seconds
		
		Notes:
		(1) The function is only available on PM103
		
		
		Args:
			pulseDuration(c_double) : low pulse duration in Seconds
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setNegativePulseWidth(self.devSession, pulseDuration, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPositivePulseWidth(self, pulseDuration, channel):
		"""
		This function sets the high pulse duration in Seconds
		
		Notes:
		(1) The function is only available on PM103
		
		
		Args:
			pulseDuration(c_double) : high pulse duration in Seconds
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPositivePulseWidth(self.devSession, pulseDuration, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setNegativeDutyCycle(self, dutyCycle, channel):
		"""
		This function sets the low duty cycle in Percent
		
		Notes:
		(1) The function is only available on PM103
		
		
		Args:
			dutyCycle(c_double) : low pulse duty cycle in Percent
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setNegativeDutyCycle(self.devSession, dutyCycle, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPositiveDutyCycle(self, dutyCycle, channel):
		"""
		This function sets the high duty cycle in Percent
		
		Notes:
		(1) The function is only available on PM103
		
		
		Args:
			dutyCycle(c_double) : high pulse duty cycle in Percent
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPositiveDutyCycle(self.devSession, dutyCycle, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measCurrent(self, current, channel):
		"""
		This function is used to obtain current readings from the instrument. 
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>. 
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			current(c_double use with byref) : This parameter returns the current in amperes [A].
			
			Remark:
			This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>. 
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measCurrent(self.devSession, current, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measVoltage(self, voltage, channel):
		"""
		This function is used to obtain voltage readings from the instrument. 
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>. 
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			voltage(c_double use with byref) : This parameter returns the voltage in volts [V].
			
			Remark:
			This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>. 
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measVoltage(self.devSession, voltage, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measPower(self, power, channel):
		"""
		This function is used to obtain power readings from the instrument. 
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>. 
		
		Args:
			power(c_double use with byref) : This parameter returns the power in the selected unit.
			
			Remark:
			(1) This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>. 
			(2) Select the unit with <Set Power Unit>.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measPower(self.devSession, power, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measEnergy(self, energy, channel):
		"""
		This function is used to obtain energy readings from the instrument. 
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			energy(c_double use with byref) : This parameter returns the actual measured energy value in joule [J].
			
			Remark:
			This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>. 
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measEnergy(self.devSession, energy, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measFreq(self, frequency, channel):
		"""
		This function is used to obtain frequency readings from the instrument. 
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			frequency(c_double use with byref) : This parameter returns the actual measured frequency of the input signal. 
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measFreq(self.devSession, frequency, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measPowerDens(self, powerDensity, channel):
		"""
		This function is used to obtain power density readings from the instrument. 
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			powerDensity(c_double use with byref) : This parameter returns the actual measured power density in watt per square centimeter [W/cm²].
			
			Remark:
			This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measPowerDens(self.devSession, powerDensity, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measEnergyDens(self, energyDensity, channel):
		"""
		This function is used to obtain energy density readings from the instrument. 
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			energyDensity(c_double use with byref) : This parameter returns the actual measured energy in joule per square centimeter [J/cm²].
			
			Remark:
			This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measEnergyDens(self.devSession, energyDensity, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measAuxAD0(self, voltage, channel):
		"""
		This function is used to obtain voltage readings from the instrument's auxiliary AD0 input. 
		
		Notes:
		(1) The function is only available on PM200, PM400.
		
		
		Args:
			voltage(c_double use with byref) : This parameter returns the voltage in volt.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measAuxAD0(self.devSession, voltage, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measAuxAD1(self, voltage, channel):
		"""
		This function is used to obtain voltage readings from the instrument's auxiliary AD1 input. 
		
		Notes:
		(1) The function is only available on PM200, PM400.
		
		
		Args:
			voltage(c_double use with byref) : This parameter returns the voltage in volt.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measAuxAD1(self.devSession, voltage, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measEmmHumidity(self, humidity, channel):
		"""
		This function is used to obtain relative humidity readings from the Environment Monitor Module (EMM) connected to the instrument. 
		
		Notes:
		(1) The function is only available on PM200, PM400.
		(2) The function will return an error when no EMM is connected.
		
		Args:
			humidity(c_double use with byref) : This parameter returns the relative humidity in %.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measEmmHumidity(self.devSession, humidity, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measEmmTemperature(self, temperature, channel):
		"""
		This function is used to obtain temperature readings from the Environment Monitor Module (EMM) connected to the instrument. 
		
		Notes:
		(1) The function is only available on PM200, PM400.
		(2) The function will return an error when no EMM is connected.
		
		Args:
			temperature(c_double use with byref) : This parameter returns the temperature in °C
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measEmmTemperature(self.devSession, temperature, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measExtNtcTemperature(self, temperature, channel):
		"""
		This function gets temperature readings from the external thermistor sensor connected to the instrument (NTC IN). 
		
		Notes:
		(1) The function is only available on PM400.
		(2) The function will return an error when no external sensor is connected.
		
		
		Args:
			temperature(c_double use with byref) : This parameter returns the temperature in °C
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measExtNtcTemperature(self.devSession, temperature, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measExtNtcResistance(self, resistance, channel):
		"""
		This function gets resistance readings from the external thermistor sensor connected to the instrument (NTC IN). 
		
		Notes:
		(1) The function is only available on PM400.
		(2) The function will return an error when no external sensor is connected.
		
		
		Args:
			resistance(c_double use with byref) : This parameter returns the resistance in Ohm
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measExtNtcResistance(self.devSession, resistance, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measHeadResistance(self, frequency, channel):
		"""
		This function is used to obtain frequency readings from the instrument. 
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			frequency(c_double use with byref) : This parameter returns the resistance in Ohm
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measHeadResistance(self.devSession, frequency, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measHeadTemperature(self, frequency, channel):
		"""
		This function is used to obtain frequency readings from the instrument. 
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			frequency(c_double use with byref) : This parameter returns the temperature in °C
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measHeadTemperature(self.devSession, frequency, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def meas4QPositions(self, xPosition, yPosition, channel):
		"""
		This function returns the x and position of a 4q sensor
		
		Notes:
		(1) The function is only available on PM101, PM102, PM400.
		
		
		Args:
			xPosition(c_double use with byref) : This parameter returns the actual measured x position in µm
			yPosition(c_double use with byref) : This parameter returns the actual measured y position in µm
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_meas4QPositions(self.devSession, xPosition, yPosition, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def meas4QVoltages(self, voltage1, voltage2, voltage3, voltage4, channel):
		"""
		This function returns the voltage of each sector of a 4q sensor
		
		Notes:
		(1) The function is only available on PM101, PM102, PM400.
		
		
		Args:
			voltage1(c_double use with byref) : This parameter returns the actual measured voltage of the upper left sector of a 4q sensor.
			voltage2(c_double use with byref)
			voltage3(c_double use with byref)
			voltage4(c_double use with byref)
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_meas4QVoltages(self.devSession, voltage1, voltage2, voltage3, voltage4, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measNegPulseWidth(self, negativePulseWidth, channel):
		"""
		This function returns the negative pulse width in µsec.
		Notes:
		(1) The function is only available on PM103.
		
		
		Args:
			negativePulseWidth(c_double use with byref) : Negative Pulse Width in µsec.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measNegPulseWidth(self.devSession, negativePulseWidth, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measPosPulseWidth(self, positivePulseWidth, channel):
		"""
		This function returns the positive pulse width in µsec.
		Notes:
		(1) The function is only available on PM103.
		
		
		Args:
			positivePulseWidth(c_double use with byref) : Positive Pulse Width in µsec.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measPosPulseWidth(self.devSession, positivePulseWidth, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measNegDutyCycle(self, negativeDutyCycle, channel):
		"""
		This function returns the negative duty cycle in percentage.
		Notes:
		(1) The function is only available on PM103.
		
		
		Args:
			negativeDutyCycle(c_double use with byref) : Negative Duty Cycle in percentage.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measNegDutyCycle(self.devSession, negativeDutyCycle, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measPosDutyCycle(self, positiveDutyCycle, channel):
		"""
		This function returns the positive duty cycle in percentage.
		Notes:
		(1) The function is only available on PM103.
		
		
		Args:
			positiveDutyCycle(c_double use with byref) : Positive Duty Cycle in percentage.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measPosDutyCycle(self.devSession, positiveDutyCycle, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measPowerMeasurementSequence(self, baseTime, channel):
		"""
		This function send the SCPI Command "CONF:ARR:POW" to the device.
		Then is possible to call the method 'getMeasurementSequence' to get the power data.
		
		Duration of measurement in µsec = Count * Interval
		The maximum capture time is 1 sec regardless of the used interval
		
		Set the bandwidth to high(setInputFilterState to OFF) and disable auto ranging(setPowerAutoRange to OFF)
		
		Note: The function is only available on PM103.
		
		
		Args:
			baseTime(c_uint32) : interval between two measurements in the array in µsec.
			The maximum resolution is 100µsec without averaging
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measPowerMeasurementSequence(self.devSession, baseTime, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measPowerMeasurementSequenceHWTrigger(self, baseTime, hPos, channel):
		"""
		PM103:
		This function send the SCPI Command "CONF:ARR:HWTrig:POW" to the device.
		Then is possible to call the methods 'startMeasurementSequence' and  'getMeasurementSequenceHWTrigger' to get the power data.
		 
		Set the bandwidth to high (setInputFilterState to OFF) and disable auto ranging (setPowerAutoRange to OFF)
		
		PM101 special:
		This function send the SCPI Command "CONF:ARR" to the device.
		Then is possible to call the methods 'startMeasurementSequence' and 'getMeasurementSequenceHWTrigger' to get the power data.
		
		Note: The function is only available on PM103 and PM101 special.
		
		
		Args:
			baseTime(c_uint32) : PM103:
			interval between two measurements in the array in µsec. The maximum resolution is 100 µsec without averaging.
			
			PM101 special:
			time to collect measurements.
			hPos(c_uint32) : PM103:
			Sets the horizontal position of trigger condition in the scope catpure (Between 1 and 9999)
			
			PM101 special:
			Interval between measurements.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measPowerMeasurementSequenceHWTrigger(self.devSession, baseTime, hPos, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measureCurrentMeasurementSequence(self, baseTime, channel):
		"""
		This function send the SCPI Command "CONF:ARR:CURR" to the device.
		Then is possible to call the method 'getMeasurementSequence' to get the power data.
		 
		Duration of measurement in µsec = Count* Interval
		The maximum capture time is 1 sec regardless of the used interval
		
		Set the bandwidth to high(setInputFilterState to OFF) and disable auto ranging(setPowerAutoRange to OFF)
		
		Note: The function is only available on PM103.
		
		
		Args:
			baseTime(c_uint32) : interval between two measurements in the array in µsec.
			The maximum resolution is 100µsec without averaging
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measureCurrentMeasurementSequence(self.devSession, baseTime, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measureCurrentMeasurementSequenceHWTrigger(self, baseTime, hPos, channel):
		"""
		This function send the SCPI Command "CONF:ARR:HWTrig:CURR" to the device.
		Then is possible to call the method 'getMeasurementSequenceHWTrigger' to get the current data.
		 
		Set the bandwidth to high (setInputFilterState to OFF) and disable auto ranging ( setPowerAutoRange to OFF)
		
		PM101 special:
		This function send the SCPI Command "CONF:ARR:CURR" to the device.
		Then is possible to call the methods 'startMeasurementSequence' and 'getMeasurementSequenceHWTrigger' to get the current data.
		
		Note: The function is only available on PM103 and PM101 special.
		
		
		Args:
			baseTime(c_uint32) : PM103:
			interval between two measurements in the array in µsec. The maximum resolution is 100 µsec without averaging.
			
			PM101 special:
			time to collect measurements.
			hPos(c_uint32) : PM103:
			Sets the horizontal position of trigger condition in the scope catpure (Between 1 and 9999)
			
			PM101 special:
			Interval between measurements.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measureCurrentMeasurementSequenceHWTrigger(self.devSession, baseTime, hPos, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measureVoltageMeasurementSequence(self, baseTime, channel):
		"""
		This function send the SCPI Command "CONF:ARR:CURR" to the device.
		Then is possible to call the method 'getMeasurementSequence' to get the power data.
		 
		Duration of measurement in µsec = Count* Interval
		The maximum capture time is 1 sec regardless of the used interval
		
		Set the bandwidth to high(setInputFilterState to OFF) and disable auto ranging(setPowerAutoRange to OFF)
		
		Note: The function is only available on PM5020.
		
		
		Args:
			baseTime(c_uint32) : interval between two measurements in the array in µsec.
			The maximum resolution is 100µsec without averaging
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measureVoltageMeasurementSequence(self.devSession, baseTime, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measureVoltageMeasurementSequenceHWTrigger(self, baseTime, hPos, channel):
		"""
		This function send the SCPI Command "CONF:ARR:HWTrig:CURR" to the device.
		Then is possible to call the method 'getMeasurementSequenceHWTrigger' to get the current data.
		 
		Set the bandwidth to high (setInputFilterState to OFF) and disable auto ranging ( setPowerAutoRange to OFF)
		
		Note: The function is only available on PM5020.
		
		
		Args:
			baseTime(c_uint32) : PM103:
			interval between two measurements in the array in µsec. The maximum resolution is 100 µsec without averaging.
			
			PM101 special:
			time to collect measurements.
			hPos(c_uint32) : PM103:
			Sets the horizontal position of trigger condition in the scope catpure (Between 1 and 9999)
			
			PM101 special:
			Interval between measurements.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measureVoltageMeasurementSequenceHWTrigger(self.devSession, baseTime, hPos, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFetchState(self, state, channel):
		"""
		This function can be used to get the measurement state information before doing a fetch.
		
		Notes:
		(1) The function is only available on PM5020.
		
		
		Args:
			state(c_int16 use with byref) : This parameter returns the fetch state
			
			VI_FALSE = no new measurement is ready
			VI_TRUE  = a new measurement is ready and can be get by "FETCH#?" ( replace # with the number of the channel)
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFetchState(self.devSession, state, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def resetFastArrayMeasurement(self, channel):
		"""
		This function resets the array measurement.
		
		Note: The function is only available on PM103.
		
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_resetFastArrayMeasurement(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confPowerFastArrayMeasurement(self, channel):
		"""
		This function is used to conffiure the fast array measurement of power values
		After calling this method, wait some milliseconds to call the method TLPM_getNextFastArrayMeasurement.
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds.   
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confPowerFastArrayMeasurement(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confCurrentFastArrayMeasurement(self, channel):
		"""
		This function is used to conffiure the fast array measurement of current values
		After calling this method, wait some milliseconds to call the method TLPM_getNextFastArrayMeasurement.
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. 
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confCurrentFastArrayMeasurement(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confVoltageFastArrayMeasurement(self, channel):
		"""
		This function is used to conffiure the fast array measurement of voltage values
		After calling this method, wait some milliseconds to call the method TLPM_getNextFastArrayMeasurement.
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds.  
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confVoltageFastArrayMeasurement(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confPDensityFastArrayMeasurement(self, channel):
		"""
		This function is used to conffiure the fast array measurement of P density values
		After calling this method, wait some milliseconds to call the method TLPM_getNextFastArrayMeasurement.
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. 
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confPDensityFastArrayMeasurement(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confEnergyFastArrayMeasurement(self, channel):
		"""
		This function is used to configure the fast array measurement of energy values
		After calling this method, wait some milliseconds to call the method TLPM_getNextFastArrayMeasurement.
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. 
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confEnergyFastArrayMeasurement(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confEDensityFastArrayMeasurement(self, channel):
		"""
		This function is used to configure the fast array measurement of E density values.
		After calling this method, wait some milliseconds to call the method TLPM_getNextFastArrayMeasurement.
		
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. 
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confEDensityFastArrayMeasurement(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getNextFastArrayMeasurement(self, count, timestamps, values, values2, channel):
		"""
		This function is used to obtain measurements from the instrument. 
		The result are timestamp - value pairs.
		
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds.
		
		Args:
			count(c_uint16 use with byref) : The count of timestamp - measurement value pairs
			The value will be 200
			timestamps( (c_uint32 * arrayLength)()) : Buffer containing up to 200 timestamps.
			This are raw timestamps and are NOT in ms.
			values( (c_float * arrayLength)()) : Buffer containing up to 200 measurement values.
			values2( (c_float * arrayLength)()) : Array of power/current measurements. The size of this array is 100 * baseTime.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getNextFastArrayMeasurement(self.devSession, count, timestamps, values, values2, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFastMaxSamplerate(self, pVal, channel):
		"""
		This function is used to obtain the maximal possible sample rate (Hz) 
		
		Args:
			pVal(c_uint32 use with byref) : Max possible sample rate (Hz)
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFastMaxSamplerate(self.devSession, pVal, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confPowerMeasurementSequence(self, baseTime, channel):
		"""
		This function send the SCPI Command "CONF:ARR:POW" to the device.
		Then is possible to call the method 'getMeasurementSequence' to get the power data.
		
		Duration of measurement in µsec = Count * Interval
		The maximum capture time is 1 sec regardless of the used interval
		
		Set the bandwidth to high(setInputFilterState to OFF) and disable auto ranging(setPowerAutoRange to OFF)
		
		Note: The function is only available on PM103.
		
		
		Args:
			baseTime(c_uint32) : interval between two measurements in the array in µsec.
			The maximum resolution is 100µsec without averaging
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confPowerMeasurementSequence(self.devSession, baseTime, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confPowerMeasurementSequenceHWTrigger(self, trigSrc, baseTime, hPos, channel):
		"""
		PM103:
		This function send the SCPI Command "CONF:ARR:HWTrig:POW" to the device.
		Then is possible to call the methods 'startMeasurementSequence' and  'getMeasurementSequenceHWTrigger' to get the power data.
		 
		Set the bandwidth to high (setInputFilterState to OFF) and disable auto ranging (setPowerAutoRange to OFF)
		
		PM101 special:
		This function send the SCPI Command "CONF:ARR" to the device.
		Then is possible to call the methods 'startMeasurementSequence' and 'getMeasurementSequenceHWTrigger' to get the power data.
		
		Note: The function is only available on PM103 and PM101 special.
		
		
		Args:
			trigSrc(c_uint16) : PM103:
			interval between two measurements in the array in µsec. The maximum resolution is 100 µsec without averaging.
			
			PM101 special:
			time to collect measurements.
			baseTime(c_uint32) : PM103:
			Sets the horizontal position of trigger condition in the scope catpure (Between 1 and 9999)
			
			PM101 special:
			Interval between measurements.
			hPos(c_uint32) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confPowerMeasurementSequenceHWTrigger(self.devSession, trigSrc, baseTime, hPos, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confCurrentMeasurementSequence(self, baseTime, channel):
		"""
		This function send the SCPI Command "CONF:ARR:CURR" to the device.
		Then is possible to call the method 'getMeasurementSequence' to get the power data.
		 
		Duration of measurement in µsec = Count* Interval
		The maximum capture time is 1 sec regardless of the used interval
		
		Set the bandwidth to high(setInputFilterState to OFF) and disable auto ranging(setPowerAutoRange to OFF)
		
		Note: The function is only available on PM103.
		
		
		Args:
			baseTime(c_uint32) : interval between two measurements in the array in µsec.
			The maximum resolution is 100µsec without averaging
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confCurrentMeasurementSequence(self.devSession, baseTime, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confCurrentMeasurementSequenceHWTrigger(self, trigSrc, baseTime, hPos, channel):
		"""
		This function send the SCPI Command "CONF:ARR:HWTrig:CURR" to the device.
		Then is possible to call the method 'getMeasurementSequenceHWTrigger' to get the current data.
		 
		Set the bandwidth to high (setInputFilterState to OFF) and disable auto ranging ( setPowerAutoRange to OFF)
		
		PM101 special:
		This function send the SCPI Command "CONF:ARR:CURR" to the device.
		Then is possible to call the methods 'startMeasurementSequence' and 'getMeasurementSequenceHWTrigger' to get the current data.
		
		Note: The function is only available on PM103 and PM101 special.
		
		
		Args:
			trigSrc(c_uint16) : PM103:
			interval between two measurements in the array in µsec. The maximum resolution is 100 µsec without averaging.
			
			PM101 special:
			time to collect measurements.
			baseTime(c_uint32) : PM103:
			Sets the horizontal position of trigger condition in the scope catpure (Between 1 and 9999)
			
			PM101 special:
			Interval between measurements.
			hPos(c_uint32) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confCurrentMeasurementSequenceHWTrigger(self.devSession, trigSrc, baseTime, hPos, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confVolatgeMeasurementSequence(self, baseTime, channel):
		"""
		
		Args:
			baseTime(c_uint32)
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confVolatgeMeasurementSequence(self.devSession, baseTime, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confVolatgeMeasurementSequenceHWTrigger(self, trigSrc, baseTime, hPos, channel):
		"""
		
		Args:
			trigSrc(c_uint16)
			baseTime(c_uint32)
			hPos(c_uint32)
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confVolatgeMeasurementSequenceHWTrigger(self.devSession, trigSrc, baseTime, hPos, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def startMeasurementSequence(self, autoTriggerDelay, triggerForced, channel):
		"""
		This function send the SCPI Command "INIT" to the device.
		
		PM103:
		Then it calls TLPM_readRegister for the register TLPM_REG_OPER_COND if there is new data to read
		
		If this method is successfull you can call getMeasurementSequence or getMeasurementSequenceHWTrigger
		
		PM101 special:
		Just the INIT command is send to the device.
		
		
		Note: The function is only available on PM103 and PM101 special. 
		
		
		
		Args:
			autoTriggerDelay(c_uint32) : PM103:
			The unit of this parameter is milliseconds.
			If this parameter bigger then zero, the method will
			wait the time in milliseconds to send the SCPI command:"TRIGer:ARRay:FORce".
			
			This command will force the measurement. 
			
			PM101 special:
			Not used.
			triggerForced(c_int16 use with byref) : PM103:
			Return parameter is TRUE if the command:"TRIGer:ARRay:FORce". was internally send to the device. See parameter "AutoTriggerDelay".
			
			PM101 special:
			Not used.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_startMeasurementSequence(self.devSession, autoTriggerDelay, triggerForced, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getMeasurementSequence(self, baseTime, timeStamps, values, values2, channel):
		"""
		 Should be called if the methods confPowerMeasurementSequence and startMeasurementSequence were called first.
		 
		This function filles the given array with (100 * baseTime) measurements from the device.
		
		Duration of measurement in µsec = Count* Interval
		The maximum capture time is 1 sec regardless of the used inteval
		Set the bandwidth to high(setInputFilterState to OFF) and disable auto ranging(setPowerAutoRange to OFF)
		
		Note: The function is only available on PM103.
		
		
		Args:
			baseTime(c_uint32) : The amount of samples to collect in the internal interation of the method.
			The value can be from 1 to 100.
			
			Every sample is 10µs for PM5020.
			timeStamps( (c_float * arrayLength)()) : Array of time stamps in ms. The size of this array is 100 * baseTime.
			values( (c_float * arrayLength)()) : Array of power/current measurements. The size of this array is 100 * baseTime.
			values2( (c_float * arrayLength)()) : Array of power/current measurements. The size of this array is 100 * baseTime.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getMeasurementSequence(self.devSession, baseTime, timeStamps, values, values2, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getMeasurementSequenceHWTrigger(self, baseTime, timeStamps, values, values2, channel):
		"""
		Should be called if the method confPowerMeasurementSequenceHWTrigger and startMeasurementSequence were called first, (or confCurrentMeasurementSequenceHWTrigger and startMeasurementSequence)
		
		PM103: 
		 This function fills the given array with (100 * baseTime) measurements from the device, external triggered.
		 Set the bandwidth to high(setInputFilterState to OFF) and disable auto ranging(setPowerAutoRange to OFF)
		 
		PM101 special:
		This function fills the Values array with measurements from the device, external triggered.
		The size of measurements to set in the array is in the parameter Base Time. Base Time is equal to the time of measurement through the intervall between each measurement. These parameters are set in the method confPowerMeasurementSequenceHWTrigger. 
		 
		
		 Note: The function is only available on PM103 and PM101 special (Not HWT). 
		
		
		Args:
			baseTime(c_uint32) : PM103:
			The amount of samples to collect in the internal interation of the method. The value can be from 1 to 100.
			PM101:
			Size of measuremnts to collect from the PM101. Time of measurement / intervall.
			timeStamps( (c_float * arrayLength)()) : PM103:
			Array of time stamps in ms. The size of this array is 100 * baseTime.
			
			PM101 special:
			Not used.
			values( (c_float * arrayLength)()) : PM103:
			Array of power/current measurements. The size of this array is 100 * baseTime.
			
			PM101:
			Array of power/current measurements. The size of this array is the time of measurement through the interval.
			
			values2( (c_float * arrayLength)()) : Array of power/current measurements. The size of this array is 100 * baseTime.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getMeasurementSequenceHWTrigger(self.devSession, baseTime, timeStamps, values, values2, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confBurstArrayMeasurementChannel(self, channel):
		"""
		This function is used to configure the burst array measurement of each channel.
		
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confBurstArrayMeasurementChannel(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confBurstArrayMeasPowerTrigger(self, initDelay, burstCount, averaging):
		"""
		
		Args:
			initDelay(c_uint32)
			burstCount(c_uint32)
			averaging(c_uint32)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confBurstArrayMeasPowerTrigger(self.devSession, initDelay, burstCount, averaging)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confBurstArrayMeasCurrentTrigger(self, initDelay, burstCount, averaging):
		"""
		
		Args:
			initDelay(c_uint32)
			burstCount(c_uint32)
			averaging(c_uint32)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confBurstArrayMeasCurrentTrigger(self.devSession, initDelay, burstCount, averaging)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def startBurstArrayMeasurement(self):
		"""
		Starts a burst array measurement
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_startBurstArrayMeasurement(self.devSession)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getBurstArraySamplesCount(self, samplesCount):
		"""
		Read the amount of samples in the burst array buffer
		
		Args:
			samplesCount(c_uint32 use with byref) : Amount of samples measure in burst mode.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getBurstArraySamplesCount(self.devSession, samplesCount)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getBurstArraySamples(self, startIndex, sampleCount, timeStamps, values, values2):
		"""
		Read scope buffer content at index 
		
		Args:
			startIndex(c_uint32)
			sampleCount(c_uint32)
			timeStamps( (c_float * arrayLength)()) : Buffer containing the samples.
			
			Buffer size: Samples Count * 2
			values( (c_float * arrayLength)())
			values2( (c_float * arrayLength)())
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getBurstArraySamples(self.devSession, startIndex, sampleCount, timeStamps, values, values2)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDigIoDirection(self, IO0, IO1, IO2, IO3):
		"""
		This function sets the digital I/O port direction.
		
		Note: The function is only available on PM200 and PM400.
		
		Args:
			IO0(c_int16) : This parameter specifies the I/O port #0 direction.
			
			Input:  VI_OFF (0)
			Output: VI_ON  (1)
			
			IO1(c_int16) : This parameter specifies the I/O port #1 direction.
			
			Input:  VI_OFF (0)
			Output: VI_ON  (1)
			
			IO2(c_int16) : This parameter specifies the I/O port #2 direction.
			
			Input:  VI_OFF (0)
			Output: VI_ON  (1)
			
			IO3(c_int16) : This parameter specifies the I/O port #3 direction.
			
			Input:  VI_OFF (0)
			Output: VI_ON  (1)
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDigIoDirection(self.devSession, IO0, IO1, IO2, IO3)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDigIoDirection(self, IO0, IO1, IO2, IO3):
		"""
		This function returns the digital I/O port direction.
		
		Note: The function is only available on PM200 and PM400.
		
		Args:
			IO0(c_int16 use with byref) : This parameter returns the I/O port #0 direction where VI_OFF (0) indicates input and VI_ON (1) indicates output.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO1(c_int16 use with byref) : This parameter returns the I/O port #1 direction where VI_OFF (0) indicates input and VI_ON (1) indicates output.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO2(c_int16 use with byref) : This parameter returns the I/O port #2 direction where VI_OFF (0) indicates input and VI_ON (1) indicates output.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO3(c_int16 use with byref) : This parameter returns the I/O port #3 direction where VI_OFF (0) indicates input and VI_ON (1) indicates output.
			
			Note: You may pass VI_NULL if you don't need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDigIoDirection(self.devSession, IO0, IO1, IO2, IO3)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDigIoOutput(self, IO0, IO1, IO2, IO3):
		"""
		This function sets the digital I/O outputs.
		
		Notes:
		(1) Only ports configured as outputs are affected by this function. Use <Set Digital I/O Direction> to configure ports as outputs.
		(2) The function is only available on PM200 and PM400.
		
		Args:
			IO0(c_int16) : This parameter specifies the I/O port #0 output.
			
			Low level:  VI_OFF (0)
			High level: VI_ON  (1)
			
			IO1(c_int16) : This parameter specifies the I/O port #1 output.
			
			Low level:  VI_OFF (0)
			High level: VI_ON  (1)
			
			IO2(c_int16) : This parameter specifies the I/O port #2 output.
			
			Low level:  VI_OFF (0)
			High level: VI_ON  (1)
			
			IO3(c_int16) : This parameter specifies the I/O port #3 output.
			
			Low level:  VI_OFF (0)
			High level: VI_ON  (1)
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDigIoOutput(self.devSession, IO0, IO1, IO2, IO3)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDigIoOutput(self, IO0, IO1, IO2, IO3):
		"""
		This function returns the digital I/O output settings.
		
		Note: The function is only available on PM200 and PM400.
		
		Args:
			IO0(c_int16 use with byref) : This parameter returns the I/O port #0 output where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO1(c_int16 use with byref) : This parameter returns the I/O port #1 output where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO2(c_int16 use with byref) : This parameter returns the I/O port #2 output where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO3(c_int16 use with byref) : This parameter returns the I/O port #3 output where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDigIoOutput(self.devSession, IO0, IO1, IO2, IO3)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDigIoPort(self, IO0, IO1, IO2, IO3):
		"""
		This function returns the actual digital I/O port level.
		
		Note: The function is only available on PM200 and PM400.
		
		Args:
			IO0(c_int16 use with byref) : This parameter returns the I/O port #0 level where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO1(c_int16 use with byref) : This parameter returns the I/O port #1 level where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO2(c_int16 use with byref) : This parameter returns the I/O port #2 level where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO3(c_int16 use with byref) : This parameter returns the I/O port #3 level where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDigIoPort(self.devSession, IO0, IO1, IO2, IO3)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDigIoPinMode(self, pinNumber, pinMode):
		"""
		This function sets the digital I/O port direction.
		
		Note: The function is only available on PM200, PM400 and PM103
		
		Args:
			pinNumber(c_int16) : Number of the Pin.
			
			Range: 1-7
			pinMode(c_uint16) : This parameter specifies the I/O port direction.
			
			Input:       DIGITAL_IO_CONFIG_INPUT   (0)
			Output:      DIGITAL_IO_CONFIG_OUTPUT  (1)
			Alternative: DIGITAL_IO_CONFIG_ALT     (2)
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDigIoPinMode(self.devSession, pinNumber, pinMode)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDigIoPinMode(self, pinNumber, pinMode):
		"""
		This function returns the digital I/O port direction.
		
		Note: The function is only available on PM200, PM400 and PM103
		
		Args:
			pinNumber(c_int16) : Number of the Pin.
			
			Range: 1-7
			pinMode(c_uint16 use with byref) : This parameter returns the I/O port #0 direction.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			Input:              DIGITAL_IO_CONFIG_INPUT      (0)
			Output:             DIGITAL_IO_CONFIG_OUTPUT     (1)
			Input Alternative:  DIGITAL_IO_CONFIG_INPUT_ALT  (2)
			Output Alternative: DIGITAL_IO_CONFIG_OUTPUT_ALT (3)
			
			
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDigIoPinMode(self.devSession, pinNumber, pinMode)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDigIoOutput2(self, IO0, IO1, IO2, IO3):
		"""
		
		Args:
			IO0(c_int16)
			IO1(c_int16)
			IO2(c_int16)
			IO3(c_int16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDigIoOutput(self.devSession, IO0, IO1, IO2, IO3)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDigIoOutput2(self, IO0, IO1, IO2, IO3):
		"""
		
		Args:
			IO0(c_int16 use with byref)
			IO1(c_int16 use with byref)
			IO2(c_int16 use with byref)
			IO3(c_int16 use with byref)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDigIoOutput(self.devSession, IO0, IO1, IO2, IO3)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDigIoPinInput(self, IO0, IO1, IO2, IO3):
		"""
		This function returns the actual digital I/O port level.
		
		Note: The function is only available on PM200 and PM400.
		
		Args:
			IO0(c_int16 use with byref) : This parameter returns the I/O port #0 level where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO1(c_int16 use with byref) : This parameter returns the I/O port #1 level where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO2(c_int16 use with byref) : This parameter returns the I/O port #2 level where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO3(c_int16 use with byref) : This parameter returns the I/O port #3 level where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDigIoPinInput(self.devSession, IO0, IO1, IO2, IO3)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getShutterInterlock(self, interlockState):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			interlockState(c_int16 use with byref)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getShutterInterlock(self.devSession, interlockState)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setShutterPosition(self, position):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			position(c_int16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setShutterPosition(self.devSession, position)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getShutterPosition(self, position):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			position(c_int16 use with byref)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getShutterPosition(self.devSession, position)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setI2CMode(self, mode):
		"""
		This setter changes the I2C speed and operating mode. By dafault I2C is controlled by the powermeter and SCPI I2C commands are disabled. It is mandatory to select a manual mode before SCPI I2C commands are enabled. The configuraiton is not stored for next boot. Be aware in manual mode the optional external environmental sensor will not longer be queried by the powermeter. The following modes are supported
		INTER: I2C controlled by powermeter. SCPI I2C disabled.
		SLOW: I2C controlled by SCPI commands in 100k standard speed. Powermeter does not access bus.
		FAST: I2C controlled by SCPI commands in 400k fast speed. Powermeter does not access bus.
		
		Note: The function is only available on PM5020
		
		Args:
			mode(c_uint16) : INTER,SLOW,FASTnew I2C operating mode and speed. See list in detail section.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setI2CMode(self.devSession, mode)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getI2CMode(self, mode):
		"""
		The command queries the I2C speed and operating mode. 
		INTER: I2C controlled by powermeter. SCPI I2C disabled.
		SLOW: I2C controlled by SCPI commands in 100k standard speed. Powermeter does not access bus.
		FAST: I2C controlled by SCPI commands in 400k fast speed. Powermeter does not access bus.
		
		Note: The function is only available on PM5020
		
		Args:
			mode(c_int16 use with byref) : INTER,SLOW,FASTI2C operating mode and speed
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getI2CMode(self.devSession, mode)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def I2CRead(self, address, count, dataRead):
		"""
		The command receives data from slave with given address. The function requires TLPMX_setI2CMode to be called once previously. The command returns data as integer. Data is read synchronously with the SCPI command.
		
		Note: The function is only available on PM5020
		
		Args:
			address(c_uint32) : I2C slave address. Address are bit 7 to bit 1. Bit 0 is ignored.
			count(c_uint32) : amount of bytes to read from address. Needs to be less than 128.
			dataRead(c_uint32 use with byref) : received data.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_I2CRead(self.devSession, address, count, dataRead)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def I2CWrite(self, address, hexData):
		"""
		The command transmits given data to slave with given address. The function requires TLPMX_setI2CMode  to be called once previously. The transmission data is given as hexadecimal string parameter. The length needs to be a multiple of two as two hex digits encode a single byte. Leading zeros are mandatory. So to transfer byte 2 and 75 use string 024B. Hex digits are support upper or lowercase letters. The maximal length are 128 Bytes. Data is transferred synchronously with the SCPI command. If you want to read after writing some data you may use TLPMX_I2CWriteRead.
		
		Note: The function is only available on PM5020
		
		Args:
			address(c_uint32) : I2C slave address. Address are bit 7 to bit 1. Bit 0 is ignored.
			hexData(c_char_p) : transmission data as hexadecimal string without byte separator. Length always multiple of 2.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_I2CWrite(self.devSession, address, hexData)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def I2CWriteRead(self, address, hexSendData, count, dataRead):
		"""
		The command transmits given data to slave with given address following a bus reception from same device if transmission was successful. This command is a convenience function for a CON:I2C#:WRIT followed by a CON:I2C#:READ? command sequence. The maximal transmission and reception byte count is 128. For closer details of hexString format read TLPMX_I2CWrite command description.
		
		Note: The function is only available on PM5020
		
		Args:
			address(c_uint32) : I2C slave address. Address are bit 7 to bit 1. Bit 0 is ignored.
			hexSendData(c_char_p) : transmission data as hexadecimal string without byte separator. Length always multiple of 2.
			count(c_uint32) : amount of bytes to read from address.
			dataRead(c_uint32 use with byref) : received data.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_I2CWriteRead(self.devSession, address, hexSendData, count, dataRead)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFanState(self, isRunning, channel):
		"""
		This function returns if the fan is running
		
		Note: The function is only available on PM5020
		
		Args:
			isRunning(c_int16 use with byref) : Returns the fan running state
			
			VI_OFF (0) Fan is still
			VI_ON  (1) Fan is running
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFanState(self.devSession, isRunning, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setFanMode(self, mode, channel):
		"""
		This function sets the state of the fan to 
		
		FAN_OPER_OFF         (0)
		FAN_OPER_FULL        (1)
		FAN_OPER_OPEN_LOOP   (2)
		FAN_OPER_CLOSED_LOOP (3)
		FAN_OPER_TEMPER_CTRL (4)
		
		Note: The function is only available on PM5020
		
		Args:
			mode(c_uint16)
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setFanMode(self.devSession, mode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFanMode(self, mode, channel):
		"""
		This function gets the state of the fan of
		
		FAN_OPER_OFF         (0)
		FAN_OPER_FULL        (1)
		FAN_OPER_OPEN_LOOP   (2)
		FAN_OPER_CLOSED_LOOP (3)
		FAN_OPER_TEMPER_CTRL (4)
		
		Note: The function is only available on PM5020
		
		Args:
			mode(c_uint16 use with byref)
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFanMode(self.devSession, mode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setFanVoltage(self, voltage, channel):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			voltage(c_double)
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setFanVoltage(self.devSession, voltage, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFanVoltage(self, voltage, channel):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			voltage(c_double use with byref)
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFanVoltage(self.devSession, voltage, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setFanRpm(self, maxRPM, targetRPM, channel):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			maxRPM(c_double) : Max RPM of the Fan
			targetRPM(c_double) : Target RPM of the Fan
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setFanRpm(self.devSession, maxRPM, targetRPM, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFanRpm(self, maxRPM, targetRPM, channel):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			maxRPM(c_double use with byref) : Max RPM of the fan
			targetRPM(c_double use with byref) : Target RPM of the fan
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFanRpm(self.devSession, maxRPM, targetRPM, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getActFanRpm(self, RPM, channel):
		"""
		Gets the current rpm of the fan
		
		Note: The function is only available on PM5020
		
		Args:
			RPM(c_double use with byref) : Current RPM of the fan
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getActFanRpm(self.devSession, RPM, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setFanTemperatureSource(self, source, channel):
		"""
		This function sets the source for the temperature control
		
		FAN_TEMPER_SRC_HEAD (0)    ///< Sensor head temper source
		FAN_TEMPER_SRC_EXT_NTC (1) ///< External NTC temper source
		
		Note: The function is only available on PM5020
		
		Args:
			source(c_uint16) : Source for the temperature control
			
			FAN_TEMPER_SRC_HEAD (0)    ///< Sensor head temper source
			FAN_TEMPER_SRC_EXT_NTC (1) ///< External NTC temper source
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setFanTemperatureSource(self.devSession, source, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFanTemperatureSource(self, source, channel):
		"""
		This function gets the source for the temperature control
		
		FAN_TEMPER_SRC_HEAD (0)    ///< Sensor head temper source
		FAN_TEMPER_SRC_EXT_NTC (1) ///< External NTC temper source
		
		Note: The function is only available on PM5020
		
		Args:
			source(c_uint16 use with byref) : Source for the temperature control
			
			FAN_TEMPER_SRC_HEAD (0)    ///< Sensor head temper source
			FAN_TEMPER_SRC_EXT_NTC (1) ///< External NTC temper source
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFanTemperatureSource(self.devSession, source, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setFanAdjustParameters(self, voltageMin, voltageMax, temperatureMin, temperatureMax, channel):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			voltageMin(c_double)
			voltageMax(c_double)
			temperatureMin(c_double)
			temperatureMax(c_double)
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setFanAdjustParameters(self.devSession, voltageMin, voltageMax, temperatureMin, temperatureMax, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFanAdjustParameters(self, voltageMin, voltageMax, temperatureMin, temperatureMax, channel):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			voltageMin(c_double use with byref)
			voltageMax(c_double use with byref)
			temperatureMin(c_double use with byref)
			temperatureMax(c_double use with byref)
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFanAdjustParameters(self.devSession, voltageMin, voltageMax, temperatureMin, temperatureMax, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def errorMessage(self, statusCode, description):
		"""
		This function takes the error code returned by the instrument driver functions interprets it and returns it as an user readable string. 
		
		Status/error codes and description:
		
		--- Instrument Driver Errors and Warnings ---
		Status      Description
		-------------------------------------------------
		         0  No error (the call was successful).
		0x3FFF0085  Unknown Status Code     - VI_WARN_UNKNOWN_STATUS
		0x3FFC0901  WARNING: Value overflow - VI_INSTR_WARN_OVERFLOW
		0x3FFC0902  WARNING: Value underrun - VI_INSTR_WARN_UNDERRUN
		0x3FFC0903  WARNING: Value is NaN   - VI_INSTR_WARN_NAN
		0xBFFC0001  Parameter 1 out of range. 
		0xBFFC0002  Parameter 2 out of range.
		0xBFFC0003  Parameter 3 out of range.
		0xBFFC0004  Parameter 4 out of range.
		0xBFFC0005  Parameter 5 out of range.
		0xBFFC0006  Parameter 6 out of range.
		0xBFFC0007  Parameter 7 out of range.
		0xBFFC0008  Parameter 8 out of range.
		0xBFFC0012  Error Interpreting instrument response.
		
		--- Instrument Errors --- 
		Range: 0xBFFC0700 .. 0xBFFC0CFF.
		Calculation: Device error code + 0xBFFC0900.
		Please see your device documentation for details.
		
		--- VISA Errors ---
		Please see your VISA documentation for details.
		
		
		Args:
			statusCode(c_int) : This parameter accepts the error codes returned from the instrument driver functions.
			
			Default Value: 0 - VI_SUCCESS
			description(create_string_buffer(1024)) : This parameter returns the interpreted code as an user readable message string.
			
			Notes:
			(1) The message buffer has to be initalized with 256 bytes.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_errorMessage(self.devSession, statusCode, description)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def errorQuery(self, errorNumber, errorMessage):
		"""
		This function queries the instrument's error queue manually. 
		Use this function to query the instrument's error queue if the driver's error query mode is set to manual query. 
		
		Notes:
		(1) The returned values are stored in the drivers error store. You may use <Error Message> to get a descriptive text at a later point of time.
		
		Args:
			errorNumber(c_int use with byref) : This parameter returns the instrument error number.
			
			Notes:
			(1) You may pass VI_NULL if you don't need this value.
			
			errorMessage(create_string_buffer(1024)) : This parameter returns the instrument error message.
			
			Notes:
			(1) The array must contain at least 256 elements ViChar[256] including the null byte.
			(2) You may pass VI_NULL if you do not need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_errorQuery(self.devSession, errorNumber, errorMessage)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def errorQueryMode(self, mode):
		"""
		This function selects the driver's error query mode.
		
		Args:
			mode(c_int16) : This parameter specifies the driver's error query mode. 
			
			If set to Automatic each driver function queries the instrument's error queue and in case an error occured returns the error number.
			
			If set to Manual the driver does not query the instrument for errors and therefore a driver function does not return instrument errors. You should use <Error Query> to manually query the instrument's error queue.
			
			VI_OFF (0): Manual error query.
			VI_ON  (1): Automatic error query (default).
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_errorQueryMode(self.devSession, mode)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def errorCount(self, count):
		"""
		This function returns the number of errors in the queue.
		
		Args:
			count(c_uint32 use with byref) : This parameter returns the instrument error number.
			
			Notes:
			(1) You may pass VI_NULL if you don't need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_errorCount(self.devSession, count)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def reset(self):
		"""
		Places the instrument in a default state.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_reset(self.devSession)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def selfTest(self, selfTestResult, description):
		"""
		This function runs the device self test routine and returns the test result.
		
		Args:
			selfTestResult(c_int16 use with byref) : This parameter contains the value returned from the device self test routine. A retured zero value indicates a successful run, a value other than zero indicates failure.
			description(create_string_buffer(1024)) : This parameter returns the interpreted code as an user readable message string.
			
			Notes:
			(1) The array must contain at least 256 elements ViChar[256].
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_selfTest(self.devSession, selfTestResult, description)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def revisionQuery(self, instrumentDriverRevision, firmwareRevision):
		"""
		This function returns the revision numbers of the instrument driver and the device firmware.
		
		Args:
			instrumentDriverRevision(create_string_buffer(1024)) : This parameter returns the Instrument Driver revision.
			
			Notes:
			(1) The array must contain at least 256 elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this value.
			
			firmwareRevision(create_string_buffer(1024)) : This parameter returns the device firmware revision. 
			
			Notes:
			(1) The array must contain at least 256 elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_revisionQuery(self.devSession, instrumentDriverRevision, firmwareRevision)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def identificationQuery(self, manufacturerName, deviceName, serialNumber, firmwareRevision):
		"""
		This function returns the device identification information.
		
		Args:
			manufacturerName(create_string_buffer(1024)) : This parameter returns the manufacturer name.
			
			Notes:
			(1) The array must contain at least 256 elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this value.
			
			deviceName(create_string_buffer(1024)) : This parameter returns the device name.
			
			Notes:
			(1) The array must contain at least 256 elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this value.
			
			serialNumber(create_string_buffer(1024)) : This parameter returns the device serial number.
			
			Notes:
			(1) The array must contain at least 256 elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this value.
			
			firmwareRevision(create_string_buffer(1024)) : This parameter returns the device firmware revision.
			
			Notes:
			(1) The array must contain at least 256 elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_identificationQuery(self.devSession, manufacturerName, deviceName, serialNumber, firmwareRevision)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getCalibrationMsg(self, message, channel):
		"""
		This function returns a human readable calibration message.
		
		
		Args:
			message(create_string_buffer(1024)) : This parameter returns the calibration message.
			
			Notes:
			(1) The array must contain at least TLPM_BUFFER_SIZE (256) elements ViChar[256].
			channel(c_uint16) : Number if the channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getCalibrationMsg(self.devSession, message, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDisplayName(self, name):
		"""
		This method send the SCPI command SYST:COMM:NET:HOST %S
		This name is used by the PM400 as custom display name
		and by the PM103E as network hostname.
		
		Args:
			name(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDisplayName(self.devSession, name)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDisplayName(self, name):
		"""
		This method send the SCPI command SYST:COMM:NET:HOST?
		This name is used by the PM400 as custom display name
		and by the PM103E as network hostname.
		
		Args:
			name(create_string_buffer(1024))
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDisplayName(self.devSession, name)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getChannels(self, channelCount):
		"""
		This function returns the number of supported sensor channels.
		
		Args:
			channelCount(c_uint16 use with byref) : Number of supported sensor channels.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getChannels(self.devSession, channelCount)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getSensorInfo(self, name, snr, message, pType, pStype, pFlags, channel):
		"""
		This function is used to obtain informations from the connected sensor like sensor name, serial number, calibration message, sensor type, sensor subtype and sensor flags.  
		
		Remark:
		The meanings of the obtained sensor type, subtype and flags are:
		
		Sensor Types:
		 SENSOR_TYPE_NONE               0x00 // No sensor
		 SENSOR_TYPE_PD_SINGLE          0x01 // Photodiode sensor
		 SENSOR_TYPE_THERMO             0x02 // Thermopile sensor
		 SENSOR_TYPE_PYRO               0x03 // Pyroelectric sensor
		
		Sensor Subtypes:
		 SENSOR_SUBTYPE_NONE            0x00 // No sensor
		 
		Sensor Subtypes Photodiode:
		 SENSOR_SUBTYPE_PD_ADAPTER      0x01 // Photodiode adapter
		 SENSOR_SUBTYPE_PD_SINGLE_STD   0x02 // Photodiode sensor
		 SENSOR_SUBTYPE_PD_SINGLE_FSR   0x03 // Photodiode sensor with 
		                                        integrated filter
		                                        identified by position 
		 SENSOR_SUBTYPE_PD_SINGLE_STD_T 0x12 // Photodiode sensor with
		                                        temperature sensor
		Sensor Subtypes Thermopile:
		 SENSOR_SUBTYPE_THERMO_ADAPTER  0x01 // Thermopile adapter
		 SENSOR_SUBTYPE_THERMO_STD      0x02 // Thermopile sensor
		 SENSOR_SUBTYPE_THERMO_STD_T    0x12 // Thermopile sensor with 
		                                        temperature sensor
		Sensor Subtypes Pyroelectric Sensor:
		 SENSOR_SUBTYPE_PYRO_ADAPTER    0x01 // Pyroelectric adapter
		 SENSOR_SUBTYPE_PYRO_STD        0x02 // Pyroelectric sensor
		 SENSOR_SUBTYPE_PYRO_STD_T      0x12 // Pyroelectric sensor with
		                                        temperature sensor
		Sensor Flags:
		 TLPM_SENS_FLAG_IS_POWER     0x0001 // Power sensor
		 TLPM_SENS_FLAG_IS_ENERGY    0x0002 // Energy sensor
		 TLPM_SENS_FLAG_IS_RESP_SET  0x0010 // Responsivity settable
		 TLPM_SENS_FLAG_IS_WAVEL_SET 0x0020 // Wavelength settable
		 TLPM_SENS_FLAG_IS_TAU_SET   0x0040 // Time constant settable
		 TLPM_SENS_FLAG_HAS_TEMP     0x0100 // With Temperature sensor 
		
		Args:
			name(create_string_buffer(1024)) : This parameter returns the name of the connected sensor.
			
			snr(create_string_buffer(1024)) : This parameter returns the serial number of the connected sensor.
			message(create_string_buffer(1024)) : This parameter returns the calibration message of the connected sensor.
			
			pType(c_int16 use with byref) : This parameter returns the sensor type of the connected sensor.
			
			Remark:
			The meanings of the obtained sensor type are:
			
			Sensor Types:
			 SENSOR_TYPE_NONE               0x00 // No sensor
			 SENSOR_TYPE_PD_SINGLE          0x01 // Photodiode sensor
			 SENSOR_TYPE_THERMO             0x02 // Thermopile sensor
			 SENSOR_TYPE_PYRO               0x03 // Pyroelectric sensor
			pStype(c_int16 use with byref) : This parameter returns the subtype of the connected sensor.
			
			Remark:
			The meanings of the obtained sensor subtype are:
			
			Sensor Subtypes:
			 SENSOR_SUBTYPE_NONE            0x00 // No sensor
			 
			Sensor Subtypes Photodiode:
			 SENSOR_SUBTYPE_PD_ADAPTER      0x01 // Photodiode adapter
			 SENSOR_SUBTYPE_PD_SINGLE_STD   0x02 // Photodiode sensor
			 SENSOR_SUBTYPE_PD_SINGLE_FSR   0x03 // Photodiode sensor with 
			                                        integrated filter
			                                        identified by position 
			 SENSOR_SUBTYPE_PD_SINGLE_STD_T 0x12 // Photodiode sensor with
			                                        temperature sensor
			Sensor Subtypes Thermopile:
			 SENSOR_SUBTYPE_THERMO_ADAPTER  0x01 // Thermopile adapter
			 SENSOR_SUBTYPE_THERMO_STD      0x02 // Thermopile sensor
			 SENSOR_SUBTYPE_THERMO_STD_T    0x12 // Thermopile sensor with 
			                                        temperature sensor
			Sensor Subtypes Pyroelectric Sensor:
			 SENSOR_SUBTYPE_PYRO_ADAPTER    0x01 // Pyroelectric adapter
			 SENSOR_SUBTYPE_PYRO_STD        0x02 // Pyroelectric sensor
			 SENSOR_SUBTYPE_PYRO_STD_T      0x12 // Pyroelectric sensor with
			                                        temperature sensor
			pFlags(c_int16 use with byref) : This parameter returns the flags of the connected sensor.
			
			Remark:
			The meanings of the obtained sensor flags are:
			
			Sensor Flags:
			 TLPM_SENS_FLAG_IS_POWER     0x0001 // Power sensor
			 TLPM_SENS_FLAG_IS_ENERGY    0x0002 // Energy sensor
			 TLPM_SENS_FLAG_IS_RESP_SET  0x0010 // Responsivity settable
			 TLPM_SENS_FLAG_IS_WAVEL_SET 0x0020 // Wavelength settable
			 TLPM_SENS_FLAG_IS_TAU_SET   0x0040 // Time constant settable
			 TLPM_SENS_FLAG_HAS_TEMP     0x0100 // With Temperature sensor
			channel(c_uint16) : Number if the channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getSensorInfo(self.devSession, name, snr, message, pType, pStype, pFlags, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def writeRaw(self, command):
		"""
		This function writes directly to the instrument.
		
		Args:
			command(c_char_p) : Null terminated command string to send to the instrument.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_writeRaw(self.devSession, command)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def readRaw(self, buffer, size, returnCount):
		"""
		This function reads directly from the instrument.
		
		
		Args:
			buffer(create_string_buffer(1024)) : Byte buffer that receives the data read from the instrument.
			
			Notes:
			(1) If received data is less than buffer size, the buffer is additionaly terminated with a '' character.
			(2) If received data is same as buffer size no '' character is appended. Its the caller's responsibility to make sure a buffer is '' terminated if the caller wants to interprete the buffer as string.
			size(c_uint32) : This parameter specifies the buffer size.
			
			returnCount(c_uint32 use with byref) : Number of bytes actually transferred and filled into Buffer. This number doesn't count the additional termination '' character. If Return Count == size the buffer content will not be '' terminated.
			
			Notes:
			(1) You may pass VI_NULL if you don't need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_readRaw(self.devSession, buffer, size, returnCount)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setTimeoutValue(self, value):
		"""
		This function sets the interface communication timeout value.
		
		Args:
			value(c_uint32) : This parameter specifies the communication timeout value in ms.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setTimeoutValue(self.devSession, value)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getTimeoutValue(self, value):
		"""
		This function gets the interface communication timeout value.
		
		
		Args:
			value(c_uint32 use with byref) : This parameter returns the communication timeout value in ms.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getTimeoutValue(self.devSession, value)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setIPAddress(self, IPAddress):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			IPAddress(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setIPAddress(self.devSession, IPAddress)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getIPAddress(self, IPAddress):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			IPAddress(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getIPAddress(self.devSession, IPAddress)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setIPMask(self, IPMask):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			IPMask(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setIPMask(self.devSession, IPMask)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getIPMask(self, IPMask):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			IPMask(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getIPMask(self.devSession, IPMask)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getMACAddress(self, MACAddress):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			MACAddress(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getMACAddress(self.devSession, MACAddress)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDHCP(self, DHCP):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			DHCP(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDHCP(self.devSession, DHCP)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDHCP(self, DHCP):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			DHCP(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDHCP(self.devSession, DHCP)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setHostname(self, hostname):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			hostname(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setHostname(self.devSession, hostname)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getHostname(self, hostname):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			hostname(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getHostname(self.devSession, hostname)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setWebPort(self, port):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			port(c_uint32) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setWebPort(self.devSession, port)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getWebPort(self, port):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			port(c_uint32 use with byref) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getWebPort(self.devSession, port)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setSCPIPort(self, port):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			port(c_uint32) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setSCPIPort(self.devSession, port)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getSCPIPort(self, port):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			port(c_uint32 use with byref) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getSCPIPort(self.devSession, port)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDFUPort(self, port):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			port(c_uint32) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDFUPort(self.devSession, port)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDFUPort(self, port):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			port(c_uint32 use with byref) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDFUPort(self.devSession, port)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDeviceBaudrate(self, baudrate):
		"""
		Tell the instrument which baudrate has to be used for the serial communication.
		This value is stored inside the instrument. 
		
		If the RS232 interface is currently used for the communication, call the function setDriverBaudrate to adapt to the new baudrate.
		
		Args:
			baudrate(c_uint32) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDeviceBaudrate(self.devSession, baudrate)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDeviceBaudrate(self, baudrate):
		"""
		This function returns the baudrate that is used for the serial communication inside the instrument
		
		
		Args:
			baudrate(c_uint32 use with byref) : This parameter returns the baudrate in bist/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDeviceBaudrate(self.devSession, baudrate)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDriverBaudrate(self, baudrate):
		"""
		This function sets the baudrate for the serial interface on the PC side
		
		Args:
			baudrate(c_uint32) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDriverBaudrate(self.devSession, baudrate)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDriverBaudrate(self, baudrate):
		"""
		This function returns the baudrate that is used for the serial communication on the PC side
		
		
		Args:
			baudrate(c_uint32 use with byref) : This parameter returns the baudrate in bist/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDriverBaudrate(self.devSession, baudrate)
		self.__testForError(pInvokeResult)
		return pInvokeResult




================================================
File: drivers/__init__.py
================================================
"""
Driver Module for Test and Measurement Equipment

This module provides a unified interface to all test equipment drivers.
All drivers follow consistent patterns and provide comprehensive functionality.
Supports multiple instances of the same instrument type with unique IDs.
"""

from .dfb13tk import DFB13TK, DFBMeasurement, DFBSweepConfig
from .pm101 import ThorlabsPowerMeter, Thorlabs_PMxxx, PowerMeterMeasurement, PowerMeterMonitorConfig
from .smu import AimTTi_SMU4000, SMUSweepConfig, SMUMeasurement
from .tti_qlp355 import TTi_QL355TP, PSUSweepConfig, PSUChannelMeasurement
from typing import Dict, List, Any, Optional

AVAILABLE_DRIVERS = {
    'dfb13tk': {
        'class': DFB13TK,
        'name': 'DFB13TK Laser',
        'interface': 'Serial',
        'description': 'DFB13TK 1310nm DFB Laser with comprehensive control',
        'supports_multiple': False,
        'connection_args': ['port'],
        'example_addresses': ['COM3', '/dev/ttyUSB0']
    },
    'thorlabs_pm': {
        'class': ThorlabsPowerMeter,
        'name': 'Thorlabs Power Meter',
        'interface': 'TLPMX/VISA',
        'description': 'Thorlabs Power Meter with TLPMX driver support',
        'supports_multiple': True,
        'connection_args': ['resource_address', 'unit_id'],
        'example_addresses': ['USB0::0x1313::0x8076::M01230612::0::INSTR']
    },
    'smu': {
        'class': AimTTi_SMU4000,
        'name': 'Aim-TTi SMU4000',
        'interface': 'VISA',
        'description': 'Source Measure Unit with sweep and I-V characterization',
        'supports_multiple': True,
        'connection_args': ['resource_address', 'unit_id'],
        'example_addresses': ['USB0::0x103E::0x4002::...::INSTR']
    },
    'psu': {
        'class': TTi_QL355TP,
        'name': 'TTi QL355TP Power Supply',
        'interface': 'VISA',
        'description': 'Dual channel power supply with load regulation testing',
        'supports_multiple': True,
        'connection_args': ['resource_address', 'unit_id'],
        'example_addresses': ['USB0::0x103E::0x0109::...::INSTR']
    }
}

class MultiInstrumentManager:
    """
    Manager for multiple instances of instruments
    Handles connection, coordination, and data collection from multiple units
    """
    
    def __init__(self):
        self.instruments: Dict[str, Any] = {}
        self.instrument_types: Dict[str, str] = {}
        
    def add_instrument(self, unit_id: str, driver_type: str, *args, **kwargs) -> bool:
        """
        Add an instrument instance to the manager
        
        Args:
            unit_id: Unique identifier for this instrument
            driver_type: Type of driver (key from AVAILABLE_DRIVERS)
            *args, **kwargs: Arguments to pass to driver constructor
            
        Returns:
            True if successful, False otherwise
        """
        if driver_type.lower() not in AVAILABLE_DRIVERS:
            print(f"Unknown driver type: {driver_type}")
            return False
            
        if unit_id in self.instruments:
            print(f"Unit ID '{unit_id}' already exists")
            return False
            
        driver_info = AVAILABLE_DRIVERS[driver_type.lower()]
        driver_class = driver_info['class']
        
        try:
            if driver_info['supports_multiple'] and 'unit_id' not in kwargs:
                kwargs['unit_id'] = unit_id
                
            instrument = driver_class(*args, **kwargs)
            self.instruments[unit_id] = instrument
            self.instrument_types[unit_id] = driver_type.lower()
            print(f"Successfully added {unit_id} ({driver_info['name']})")
            return True
            
        except Exception as e:
            print(f"Failed to add {unit_id}: {e}")
            return False
    
    def get_instrument(self, unit_id: str):
        """Get an instrument by unit ID"""
        return self.instruments.get(unit_id)
    
    def get_instruments_by_type(self, driver_type: str) -> Dict[str, Any]:
        """Get all instruments of a specific type"""
        return {uid: inst for uid, inst in self.instruments.items() 
                if self.instrument_types[uid] == driver_type.lower()}
    
    def list_instruments(self):
        """List all connected instruments"""
        print("Connected Instruments:")
        print("=" * 50)
        for unit_id, instrument in self.instruments.items():
            driver_type = self.instrument_types[unit_id]
            driver_info = AVAILABLE_DRIVERS[driver_type]
            print(f"{unit_id}: {driver_info['name']}")
            if hasattr(instrument, 'device_info'):
                model = instrument.device_info.get('model', 'Unknown')
                print(f"  Model: {model}")
            print()
    
    def disconnect_all(self):
        """Safely disconnect all instruments"""
        for unit_id, instrument in self.instruments.items():
            try:
                if hasattr(instrument, 'disconnect'):
                    instrument.disconnect()
                elif hasattr(instrument, 'close'):
                    instrument.close()
                print(f"Disconnected {unit_id}")
            except Exception as e:
                print(f"Error disconnecting {unit_id}: {e}")
        
        self.instruments.clear()
        self.instrument_types.clear()
    
    def get_all_status(self) -> Dict[str, Dict]:
        """Get status from all instruments"""
        status = {}
        for unit_id, instrument in self.instruments.items():
            try:
                if hasattr(instrument, 'get_status'):
                    status[unit_id] = instrument.get_status()
                else:
                    status[unit_id] = {'error': 'No status method available'}
            except Exception as e:
                status[unit_id] = {'error': str(e)}
        return status

def list_drivers():
    """List all available drivers with their information"""
    print("Available Drivers:")
    print("=" * 80)
    for key, info in AVAILABLE_DRIVERS.items():
        print(f"{key.upper()}:")
        print(f"  Name: {info['name']}")
        print(f"  Interface: {info['interface']}")
        print(f"  Description: {info['description']}")
        print(f"  Supports Multiple: {info['supports_multiple']}")
        print(f"  Connection Args: {', '.join(info['connection_args'])}")
        print(f"  Example Addresses: {info['example_addresses']}")
        print()

def get_driver(driver_name: str):
    """Get a driver class by name"""
    if driver_name.lower() in AVAILABLE_DRIVERS:
        return AVAILABLE_DRIVERS[driver_name.lower()]['class']
    else:
        available = ', '.join(AVAILABLE_DRIVERS.keys())
        raise ValueError(f"Driver '{driver_name}' not found. Available: {available}")

def create_production_setup() -> MultiInstrumentManager:
    """
    Create production multi-instrument setup with actual hardware addresses
    """
    manager = MultiInstrumentManager()
    
    production_config = {
        'SMU1': ('smu', 'TCPIP::10.11.83.58::INSTR'),
        'SMU2': ('smu', 'TCPIP::10.11.83.60::INSTR'),
        'PSU1': ('psu', 'TCPIP::10.11.83.57::INSTR'),
        'PSU2': ('psu', 'TCPIP::10.11.83.52::INSTR'),
        'PM1': ('thorlabs_pm', 'USB0::0x1313::0x8076::M01250277::0::INSTR'),
        'PM2': ('thorlabs_pm', 'USB0::0x1313::0x8076::M01250278::0::INSTR'),
        'LASER': ('dfb13tk', 'COM3')
    }
    
    print("PRODUCTION Multi-Instrument Setup:")
    print("Ready for actual hardware connection")
    print("=" * 60)
    
    for unit_id, (driver_type, address) in production_config.items():
        print(f"{unit_id}: {AVAILABLE_DRIVERS[driver_type]['name']}")
        print(f"  Address: {address}")
    
    return manager

def create_example_setup() -> MultiInstrumentManager:
    """
    Create an example multi-instrument setup for reference
    """
    manager = MultiInstrumentManager()
    
    example_config = {
        'SMU1': ('smu', 'TCPIP::10.11.83.58::INSTR'),
        'SMU2': ('smu', 'TCPIP::10.11.83.60::INSTR'),
        'PSU1': ('psu', 'TCPIP::10.11.83.57::INSTR'),
        'PSU2': ('psu', 'TCPIP::10.11.83.52::INSTR'),
        'PM1': ('thorlabs_pm', 'USB0::0x1313::0x8076::M01250277::0::INSTR'),
        'PM2': ('thorlabs_pm', 'USB0::0x1313::0x8076::M01250278::0::INSTR'),
        'LASER': ('dfb13tk', 'COM3')
    }
    
    print("Multi-Instrument Setup (Production Addresses):")
    print("=" * 60)
    
    for unit_id, (driver_type, address) in example_config.items():
        print(f"{unit_id}: {AVAILABLE_DRIVERS[driver_type]['name']}")
        print(f"  Address: {address}")
    
    return manager

__all__ = [
    'DFB13TK',
    'DFBMeasurement',
    'DFBSweepConfig',
    'ThorlabsPowerMeter', 
    'Thorlabs_PMxxx',
    'PowerMeterMeasurement',
    'PowerMeterMonitorConfig',
    'AimTTi_SMU4000',
    'TTi_QL355TP',
    'SMUSweepConfig',
    'SMUMeasurement', 
    'PSUSweepConfig',
    'PSUChannelMeasurement',
    'MultiInstrumentManager',
    'AVAILABLE_DRIVERS',
    'list_drivers',
    'get_driver',
    'create_example_setup',
    'create_production_setup'
]


================================================
File: drivers/dfb13tk.py
================================================
import serial
import time
import numpy as np
import pandas as pd
from datetime import datetime
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, asdict

@dataclass
class DFBMeasurement:
    timestamp: str
    current_ma: float
    temperature_actual_c: float
    temperature_setpoint_c: float
    wavelength_nm: float
    estimated_power_mw: float
    laser_state: int
    tec_adjustment_c: float
    laser_on: bool
    temperature_stable: bool
    
    def to_dict(self) -> Dict:
        return asdict(self)

@dataclass 
class DFBSweepConfig:
    parameter: str
    start_value: float
    stop_value: float
    steps: int
    step_delay: float = 1.0
    stabilization_timeout: float = 30.0
    stabilization_tolerance: float = 0.1

class DFB13TK:
    
    def __init__(self, port="COM3", baudrate=9600):
        self.port = port
        self.ser = serial.Serial(port, baudrate, timeout=1.0)
        self._current_ma = 150.0
        self._temp_setpoint = 25.0
        
    def close(self):
        if self.ser.is_open:
            self.ser.close()
    
    def _cmd(self, command):
        self.ser.reset_input_buffer()
        self.ser.write(f"{command}\r".encode())
        response = self.ser.readline().decode('utf-8').strip()
        
        if ':' in response:
            code, msg = response.split(':', 1)
            if code != "000":
                raise RuntimeError(f"Device error {code}: {msg}")
            return msg
        return response
    
    def laser_on(self):
        self._cmd("laser on")
    
    def laser_off(self):
        self._cmd("laser off")
    
    def get_laser_state(self):
        try:
            state = self._cmd("read_param laser_state")
            return int(state) if state else 61
        except:
            return 61
    
    def set_current(self, current_ma):
        if not 0 <= current_ma <= 450:
            raise ValueError("Current must be 0-450 mA")
        amps = current_ma / 1000.0
        self._cmd(f"write_param laser.current {amps}")
        self._current_ma = current_ma
    
    def get_current(self):
        try:
            current_str = self._cmd("read_param laser.current")
            if current_str:
                return float(current_str) * 1000
        except:
            pass
        return self._current_ma
    
    def set_temperature(self, temp_c):
        if not 15 <= temp_c <= 35:
            raise ValueError("Temperature must be 15-35Â°C")
        self._cmd(f"write_param laser_tec_ctrl.setpoint {temp_c}")
        self._temp_setpoint = temp_c
    
    def get_temperature_setpoint(self):
        """Get temperature setpoint in Â°C"""
        try:
            temp_str = self._cmd("read_param laser_tec_ctrl.setpoint")
            if temp_str:
                return float(temp_str)
        except:
            pass
        return self._temp_setpoint
    
    def get_temperature(self):
        """Get actual temperature reading in Â°C"""
        try:
            temp_str = self._cmd("read_param laser_tec_ctrl.temperature")
            if temp_str:
                return float(temp_str)
        except:
            pass
        return self._temp_setpoint
    
    def wait_temperature_stable(self, tolerance=0.1, timeout=60):
        """Wait for temperature to stabilize within tolerance"""
        start_time = time.time()
        setpoint = self.get_temperature_setpoint()
        
        while time.time() - start_time < timeout:
            if abs(self.get_temperature() - setpoint) <= tolerance:
                return True
            time.sleep(1)
        return False
    
    def enable_tec_adjustment(self):
        """Enable TEC adjustment for laser (121=Laser TEC, 120=None)"""
        self._cmd("write_param tec_adj.select 121")
    
    def disable_tec_adjustment(self):
        """Disable TEC adjustment"""
        self._cmd("write_param tec_adj.select 120")
    
    def set_tec_adjustment_range(self, range_c):
        """Set TEC adjustment range +/- in Â°C"""
        self._cmd(f"write_param tec_adj.range {range_c}")
    
    def get_tec_adjustment_range(self):
        """Get TEC adjustment range"""
        try:
            range_str = self._cmd("read_param tec_adj.range")
            return float(range_str) if range_str else 1.0
        except:
            return 1.0
    
    def get_tec_adjustment(self):
        """Get active TEC adjustment in Â°C"""
        try:
            adj_str = self._cmd("read_param tec_adj")
            return float(adj_str) if adj_str else 0.0
        except:
            return 0.0
    
    def calculate_wavelength(self, current_ma=None, temp_c=None):
        if current_ma is None:
            current_ma = self.get_current()
        if temp_c is None:
            temp_c = self.get_temperature()
        
        base_wavelength = 1310.0
        base_current = 200.0
        base_temp = 25.0
        
        current_shift = (current_ma - base_current) * 0.003
        temp_shift = (temp_c - base_temp) * 0.08
        
        return base_wavelength + current_shift + temp_shift
    
    def calculate_power(self, current_ma=None):
        if current_ma is None:
            current_ma = self.get_current()
        
        threshold_ma = 15.0
        slope_efficiency_w_per_a = 0.27
        
        if current_ma <= threshold_ma:
            return 0.0
        
        power_w = (current_ma - threshold_ma) / 1000.0 * slope_efficiency_w_per_a
        return power_w * 1000.0
    
    def get_firmware_version(self):
        return self._cmd("firmware_version")
    
    def get_serial_number(self):
        return self._cmd("read_string module_sn")
    
    def get_laser_serial(self):
        return self._cmd("read_string laser_sn")
    
    def get_oem_string(self):
        return self._cmd("read_string oem")
    
    def get_main_board_serial(self):
        return self._cmd("read_string main_board_sn")
    
    def get_clock(self):
        return self._cmd("get_clock")
    
    def save_config(self):
        self._cmd("savecfg")
    
    def save_parameter(self, tag):
        self._cmd(f"save_param {tag}")
    
    def read_parameter(self, tag):
        return self._cmd(f"read_param {tag}")
    
    def write_parameter(self, tag, value):
        self._cmd(f"write_param {tag} {value}")
    
    def reset_system(self):
        self._cmd("reset")
    
    def enter_update_mode(self):
        self._cmd("update")
    
    def get_status(self):
        current_ma = self.get_current()
        temp_actual = self.get_temperature()
        temp_setpoint = self.get_temperature_setpoint()
        
        return {
            'current_ma': current_ma,
            'temperature_actual_c': temp_actual,
            'temperature_setpoint_c': temp_setpoint,
            'wavelength_nm': self.calculate_wavelength(current_ma, temp_actual),
            'estimated_power_mw': self.calculate_power(current_ma),
            'laser_state': self.get_laser_state(),
            'tec_adjustment_c': self.get_tec_adjustment(),
            'tec_adjustment_range_c': self.get_tec_adjustment_range()
        }
    
    def get_device_info(self):
        """Get device information dictionary"""
        try:
            return {
                'firmware_version': self.get_firmware_version(),
                'module_serial': self.get_serial_number(),
                'laser_serial': self.get_laser_serial(),
                'main_board_serial': self.get_main_board_serial(),
                'oem_string': self.get_oem_string(),
                'system_clock': self.get_clock(),
                'port': self.port
            }
        except:
            return {'port': self.port}
    
    def get_modulation_specs(self):
        """Get external modulation specifications"""
        return {
            'ac_modulation': {
                'voltage_to_current': '10 mA/V',
                'wavelength_range': 'Â±0.15 nm',
                'power_range': 'Â±10 mW',
                'frequency_range': '2 kHz to 20 MHz',
                'input_voltage': '-5 V to 5 V',
                'input_impedance': '1 kÎ©'
            },
            'dc_modulation': {
                'voltage_to_current': '2 mA/V', 
                'wavelength_range': 'Â±0.03 nm',
                'power_range': 'Â±1 mW',
                'frequency_range': 'DC to 5 MHz',
                'input_voltage': '-5 V to 5 V',
                'input_impedance': '1 kÎ©'
            },
            'temperature_modulation': {
                'voltage_to_temperature': '0.2 Â°C/V (default)',
                'frequency_range': 'DC to 1 Hz',
                'input_voltage': '-5 V to 5 V',
                'input_impedance': '1 kÎ©'
            }
        }
    
    def get_specifications(self):
        """Get laser specifications from manual"""
        return {
            'center_wavelength_nm': {'min': 1305, 'max': 1315},
            'output_power_mw': {'min': 100},
            'linewidth_khz': {'typical': 100, 'max': 200},
            'mode_hop_free_current_ma': {'min': 50, 'max': 500},
            'mode_hop_free_power_mw': {'min': 15, 'max': 100},
            'smsr_db': {'min': 35, 'typical': 50},
            'threshold_current_ma': {'typical': 15},
            'slope_efficiency_w_per_a': {'typical': 0.27},
            'current_tuning_nm_per_ma': {'typical': 0.003},
            'temp_tuning_nm_per_c': {'typical': 0.08},
            'temp_range_c': {'min': 15, 'max': 35},
            'temp_tuning_range_nm': {'typical': 1.6},
            'rin_dbc_per_hz': {'typical': -150},
            'per_db': {'typical': 25},
            'isolation_db': {'typical': 25}
        }
    
    def tune_wavelength_by_current(self, target_wavelength_nm):
        """Tune to target wavelength using current (approximate)"""
        current_wavelength = self.calculate_wavelength()
        wavelength_diff = target_wavelength_nm - current_wavelength
        
        current_change_ma = wavelength_diff / 0.003
        new_current = self.get_current() + current_change_ma
        
        if 0 <= new_current <= 450:
            self.set_current(new_current)
            return True
        return False
    
    def tune_wavelength_by_temperature(self, target_wavelength_nm):
        """Tune to target wavelength using temperature (approximate)"""
        current_wavelength = self.calculate_wavelength()
        wavelength_diff = target_wavelength_nm - current_wavelength
        
        temp_change_c = wavelength_diff / 0.08
        new_temp = self.get_temperature_setpoint() + temp_change_c
        
        if 15 <= new_temp <= 35:
            self.set_temperature(new_temp)
            return True
        return False
    
    def get_mode_hop_free_range(self):
        """Check if current operation is in mode-hop-free range"""
        current_ma = self.get_current()
        power_mw = self.calculate_power(current_ma)
        
        specs = self.get_specifications()
        current_ok = specs['mode_hop_free_current_ma']['min'] <= current_ma <= specs['mode_hop_free_current_ma']['max']
        power_ok = specs['mode_hop_free_power_mw']['min'] <= power_mw <= specs['mode_hop_free_power_mw']['max']
        
        return {
            'in_range': current_ok and power_ok,
            'current_ok': current_ok,
            'power_ok': power_ok,
            'current_ma': current_ma,
            'power_mw': power_mw
        }
    
    def calculate_tuning_range(self):
        """Calculate available tuning ranges"""
        current_ma = self.get_current()
        temp_c = self.get_temperature_setpoint()
        
        max_current_change = min(450 - current_ma, current_ma)
        current_tuning_range_nm = max_current_change * 0.003
        
        max_temp_change = min(35 - temp_c, temp_c - 15)
        temp_tuning_range_nm = max_temp_change * 0.08
        
        return {
            'current_tuning_range_nm': current_tuning_range_nm,
            'temperature_tuning_range_nm': temp_tuning_range_nm,
            'total_range_nm': current_tuning_range_nm + temp_tuning_range_nm
        }
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        try:
            self.laser_off()
        except:
            pass
        self.close()

    def measure_all(self) -> DFBMeasurement:
        """Take comprehensive measurement of all laser parameters"""
        timestamp = datetime.now().isoformat()
        
        current_ma = self.get_current()
        temp_actual = self.get_temperature()
        temp_setpoint = self.get_temperature_setpoint()
        wavelength_nm = self.calculate_wavelength(current_ma, temp_actual)
        power_mw = self.calculate_power(current_ma)
        laser_state = self.get_laser_state()
        tec_adj = self.get_tec_adjustment()
        laser_on = laser_state == 60  # 60 = laser on state
        
        temp_stable = abs(temp_actual - temp_setpoint) <= 0.1
        
        measurement = DFBMeasurement(
            timestamp=timestamp,
            current_ma=current_ma,
            temperature_actual_c=temp_actual,
            temperature_setpoint_c=temp_setpoint,
            wavelength_nm=wavelength_nm,
            estimated_power_mw=power_mw,
            laser_state=laser_state,
            tec_adjustment_c=tec_adj,
            laser_on=laser_on,
            temperature_stable=temp_stable
        )
        
        return measurement

    def current_sweep(self, config: DFBSweepConfig) -> pd.DataFrame:
        """
        Perform current sweep with comprehensive data collection
        
        Returns:
            DataFrame ready for recorder.record_complete_dataset()
        """
        if config.parameter != 'current':
            raise ValueError("Use current_sweep for current parameter sweeps")
            
        print(f"Starting DFB current sweep: {config.start_value}mA to {config.stop_value}mA, {config.steps} steps")
        
        if not config.start_value <= config.stop_value:
            raise ValueError("Start value must be <= stop value")
        if not 0 <= config.start_value <= 450 or not 0 <= config.stop_value <= 450:
            raise ValueError("Current must be 0-450 mA")
        
        current_points = np.linspace(config.start_value, config.stop_value, config.steps)
        measurements = []
        
        self.laser_on()
        time.sleep(1.0)
        
        try:
            for i, current_ma in enumerate(current_points):
                self.set_current(current_ma)
                time.sleep(config.step_delay)
                
                start_time = time.time()
                while time.time() - start_time < config.stabilization_timeout:
                    measurement = self.measure_all()
                    if measurement.temperature_stable:
                        break
                    time.sleep(0.5)
                else:
                    measurement = self.measure_all()
                
                measurements.append(measurement)
                print(f"Step {i+1}/{config.steps}: I={current_ma:.1f}mA -> Î»={measurement.wavelength_nm:.3f}nm, P={measurement.estimated_power_mw:.2f}mW")
                
        finally:
            self.set_current(150.0)  # Safe operating current
        
        df = pd.DataFrame([m.to_dict() for m in measurements])
        df['unit_id'] = 'DFB_LASER'
        df['sweep_type'] = 'current'
        df['step_number'] = range(1, len(df) + 1)
        
        df['wavelength_shift_nm'] = df['wavelength_nm'] - df['wavelength_nm'].iloc[0]
        df['power_efficiency_mw_per_ma'] = df['estimated_power_mw'] / df['current_ma']
        df['temp_error_c'] = df['temperature_actual_c'] - df['temperature_setpoint_c']
        
        return df

    def temperature_sweep(self, config: DFBSweepConfig) -> pd.DataFrame:
        """
        Perform temperature sweep with comprehensive data collection
        
        Returns:
            DataFrame ready for recorder.record_complete_dataset()
        """
        if config.parameter != 'temperature':
            raise ValueError("Use temperature_sweep for temperature parameter sweeps")
            
        print(f"Starting DFB temperature sweep: {config.start_value}Â°C to {config.stop_value}Â°C, {config.steps} steps")
        
        if not 15 <= config.start_value <= 35 or not 15 <= config.stop_value <= 35:
            raise ValueError("Temperature must be 15-35Â°C")
        
        temp_points = np.linspace(config.start_value, config.stop_value, config.steps)
        measurements = []
        
        self.laser_on()
        time.sleep(1.0)
        
        try:
            for i, temp_c in enumerate(temp_points):
                self.set_temperature(temp_c)
                print(f"Step {i+1}/{config.steps}: Setting T={temp_c:.2f}Â°C, waiting for stabilization...")
                
                if not self.wait_temperature_stable(
                    tolerance=config.stabilization_tolerance,
                    timeout=config.stabilization_timeout
                ):
                    print(f"  Warning: Temperature may not be fully stable")
                
                time.sleep(config.step_delay)
                measurement = self.measure_all()
                measurements.append(measurement)
                
                print(f"  Result: T={measurement.temperature_actual_c:.2f}Â°C -> Î»={measurement.wavelength_nm:.3f}nm, P={measurement.estimated_power_mw:.2f}mW")
                
        finally:
            self.set_temperature(25.0)  # Safe operating temperature
        
        df = pd.DataFrame([m.to_dict() for m in measurements])
        df['unit_id'] = 'DFB_LASER'
        df['sweep_type'] = 'temperature'
        df['step_number'] = range(1, len(df) + 1)
        
        df['wavelength_shift_nm'] = df['wavelength_nm'] - df['wavelength_nm'].iloc[0]
        df['temp_tuning_nm_per_c'] = np.gradient(df['wavelength_nm']) / np.gradient(df['temperature_actual_c'])
        df['temp_error_c'] = df['temperature_actual_c'] - df['temperature_setpoint_c']
        
        return df

    def wavelength_characterization(self, current_range=(100, 400), current_steps=20,
                                   temp_range=(20, 30), temp_steps=6) -> pd.DataFrame:
        """
        Complete wavelength characterization across current and temperature
        
        Returns:
            Combined DataFrame ready for recorder
        """
        print("Starting complete DFB wavelength characterization")
        
        current_config = DFBSweepConfig(
            parameter='current',
            start_value=current_range[0],
            stop_value=current_range[1],
            steps=current_steps,
            step_delay=0.5,
            stabilization_timeout=10.0
        )
        
        self.set_temperature(25.0)  # Middle of range
        self.wait_temperature_stable(timeout=30)
        
        current_sweep_data = self.current_sweep(current_config)
        time.sleep(2.0)  # Brief pause between sweeps
        
        temp_config = DFBSweepConfig(
            parameter='temperature',
            start_value=temp_range[0],
            stop_value=temp_range[1],
            steps=temp_steps,
            step_delay=2.0,
            stabilization_timeout=45.0,
            stabilization_tolerance=0.1
        )
        
        self.set_current(200.0)  # Middle of range
        time.sleep(1.0)
        
        temp_sweep_data = self.temperature_sweep(temp_config)
        
        combined_df = pd.concat([current_sweep_data, temp_sweep_data], ignore_index=True)
        combined_df['characterization_type'] = 'wavelength_complete'
        
        return combined_df

    def power_vs_current_characterization(self, current_range=(50, 450), steps=25) -> pd.DataFrame:
        """
        Characterize power vs current relationship
        
        Returns:
            DataFrame ready for recorder
        """
        print("Starting DFB power vs current characterization")
        
        config = DFBSweepConfig(
            parameter='current',
            start_value=current_range[0],
            stop_value=current_range[1],
            steps=steps,
            step_delay=0.5,
            stabilization_timeout=10.0
        )
        
        self.set_temperature(25.0)
        self.wait_temperature_stable(timeout=30)
        
        power_data = self.current_sweep(config)
        power_data['characterization_type'] = 'power_vs_current'
        
        threshold_current = 15.0  # From specs
        above_threshold = power_data['current_ma'] > threshold_current
        
        if above_threshold.any():
            linear_region = power_data[above_threshold]
            if len(linear_region) > 3:
                slope_eff = np.polyfit(linear_region['current_ma'], linear_region['estimated_power_mw'], 1)[0]
                power_data['calculated_slope_efficiency_mw_per_ma'] = slope_eff
        
        return power_data

    def get_recorder_ready_data(self, measurements: List[DFBMeasurement] = None) -> pd.DataFrame:
        """
        Convert measurements to recorder-ready DataFrame format
        
        Args:
            measurements: Optional list of measurements
            
        Returns:
            DataFrame formatted for recorder.record_complete_dataset()
        """
        if measurements is None:
            measurement = self.measure_all()
            measurements = [measurement]
            
        df = pd.DataFrame([m.to_dict() for m in measurements])
        df['unit_id'] = 'DFB_LASER'
        
        df['wavelength_shift_nm'] = df['wavelength_nm'] - df['wavelength_nm'].iloc[0]
        df['power_efficiency_mw_per_ma'] = df['estimated_power_mw'] / df['current_ma']
        df['temp_error_c'] = df['temperature_actual_c'] - df['temperature_setpoint_c']
        df['measurement_index'] = range(len(df))
        
        return df





================================================
File: drivers/pm101.py
================================================
import os
import sys
import time
import numpy as np
import pandas as pd
from datetime import datetime
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, asdict
from ctypes import cdll, byref, create_string_buffer, c_bool, c_int16, c_double, c_char_p

@dataclass
class PowerMeterMeasurement:
    """Single power meter measurement data point"""
    timestamp: str
    power_w: float
    power_mw: float
    power_dbm: float
    wavelength_nm: float
    unit_id: str
    calibration_msg: str
    connection_method: str
    auto_range_enabled: bool
    
    def to_dict(self) -> Dict:
        return asdict(self)

@dataclass
class PowerMeterMonitorConfig:
    """Configuration for power meter monitoring operations"""
    duration_s: float
    sample_rate_hz: float = 10.0
    wavelength_nm: float = 1310.0
    power_unit: str = "W"
    auto_range: bool = True
    statistical_analysis: bool = True

sys.path.insert(0, os.path.dirname(__file__))

try:
    from TLPMX import TLPMX, TLPM_DEFAULT_CHANNEL
    TLPMX_AVAILABLE = True
except ImportError:
    TLPMX_AVAILABLE = False

try:
    import pyvisa
    PYVISA_AVAILABLE = True
except ImportError:
    PYVISA_AVAILABLE = False

class ThorlabsPowerMeter:
    def __init__(self, resource_address: str, use_tlpmx: bool = True, unit_id: str = 'PM1'):
        self.unit_id = unit_id
        self.resource_address = resource_address
        self.is_open = False
        self.last_cal_msg = ""
        self.wavelength = 1310.0
        self.use_tlpmx = use_tlpmx and TLPMX_AVAILABLE
        
        if self.use_tlpmx:
            self._init_tlpmx()
        elif PYVISA_AVAILABLE:
            self._init_pyvisa()
        else:
            raise RuntimeError("Neither TLPMX nor PyVISA is available")

    def _init_tlpmx(self):
        try:
            self.instrument_handle = TLPMX()
            resource_name_c = self.resource_address.encode('ascii')
            
            self.instrument_handle.open(resource_name_c, c_bool(True), c_bool(True))
            self.is_open = True
            
            self.instrument_handle.setPowerUnit(c_int16(0), TLPM_DEFAULT_CHANNEL)
            self.instrument_handle.setPowerAutoRange(c_int16(1), TLPM_DEFAULT_CHANNEL)
            
            cmsg = create_string_buffer(256)
            self.instrument_handle.getCalibrationMsg(cmsg, TLPM_DEFAULT_CHANNEL)
            self.last_cal_msg = cmsg.value.decode('utf-8')
            
        except Exception as e:
            if self.is_open:
                self.disconnect()
            raise ConnectionError(f"Could not connect via TLPMX: {e}")

    def _init_pyvisa(self):
        try:
            self.rm = pyvisa.ResourceManager()
            self.instrument = self.rm.open_resource(self.resource_address)
            self.instrument.read_termination = '\n'
            self.instrument.write_termination = '\n'
            self.is_open = True
            
        except Exception as e:
            raise ConnectionError(f"Could not connect via PyVISA: {e}")

    def get_idn(self) -> str:
        if not self.is_open:
            return "Device not connected"
            
        try:
            if self.use_tlpmx:
                model_name = create_string_buffer(256)
                serial_number = create_string_buffer(256)
                manufacturer = create_string_buffer(256)
                dummy_bool = c_bool(False)
                
                self.instrument_handle.getDevInfo(model_name, serial_number, manufacturer, byref(dummy_bool))
                
                return (f"Manufacturer: {manufacturer.value.decode('utf-8')}, "
                       f"Model: {model_name.value.decode('utf-8')}, "
                       f"S/N: {serial_number.value.decode('utf-8')}")
            else:
                return self.instrument.query("SYST:SENS:IDN?")
                
        except Exception as e:
            return f"Error retrieving ID: {e}"

    def set_wavelength(self, wavelength_nm: float):
        if not self.is_open:
            return
            
        try:
            self.wavelength = float(wavelength_nm)
            
            if self.use_tlpmx:
                self.instrument_handle.setWavelength(c_double(self.wavelength), TLPM_DEFAULT_CHANNEL)
            else:
                self.instrument.write(f"SENS:CORR:WAV {wavelength_nm}")
            
        except Exception as e:
            pass

    def set_power_unit(self, unit: str = "W"):
        if not self.is_open:
            return
            
        unit = unit.upper()
        if unit not in ["W", "DBM"]:
            raise ValueError("Unit must be 'W' or 'DBM'")
            
        try:
            if self.use_tlpmx:
                unit_code = 0 if unit == "W" else 1
                self.instrument_handle.setPowerUnit(c_int16(unit_code), TLPM_DEFAULT_CHANNEL)
            else:
                self.instrument.write(f"SENS:POW:UNIT {unit}")
                
        except Exception as e:
            pass

    def set_auto_range(self, enable: bool):
        if not self.is_open:
            return
            
        try:
            if self.use_tlpmx:
                self.instrument_handle.setPowerAutoRange(c_int16(1 if enable else 0), TLPM_DEFAULT_CHANNEL)
            else:
                state = "ON" if enable else "OFF"
                self.instrument.write(f"SENS:POW:RANG:AUTO {state}")
                
        except Exception as e:
            pass

    def read_power(self) -> float:
        if not self.is_open:
            return 0.0
            
        try:
            if self.use_tlpmx:
                power_c = c_double()
                self.instrument_handle.measPower(byref(power_c), TLPM_DEFAULT_CHANNEL)
                return power_c.value
            else:
                return float(self.instrument.query("MEAS:POW?"))
                
        except Exception as e:
            return 0.0

    def read_power_dbm(self) -> float:
        power_w = self.read_power()
        if power_w > 0:
            return 10 * np.log10(power_w * 1000)
        else:
            return -999.0

    def get_calibration_message(self) -> str:
        if self.use_tlpmx:
            return self.last_cal_msg
        else:
            try:
                return self.instrument.query("SYST:SENS:CAL:MESS?")
            except:
                return "Calibration message not available"

    def get_status(self) -> dict:
        power_w = self.read_power()
        return {
            'power_w': power_w,
            'power_mw': power_w * 1000,
            'power_dbm': self.read_power_dbm(),
            'wavelength_nm': self.wavelength,
            'calibration_msg': self.get_calibration_message(),
            'connection_method': 'TLPMX' if self.use_tlpmx else 'PyVISA',
            'resource_address': self.resource_address
        }

    def disconnect(self):
        if self.is_open:
            try:
                if self.use_tlpmx:
                    self.instrument_handle.close()
                else:
                    self.instrument.close()
                    self.rm.close()
                self.is_open = False
                
            except Exception as e:
                pass

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.disconnect()

    def measure_all(self, unit_id: str = None) -> PowerMeterMeasurement:
        if unit_id is None:
            unit_id = getattr(self, 'unit_id', 'PM1')
            
        timestamp = datetime.now().isoformat()
        
        power_w = self.read_power()
        power_mw = power_w * 1000
        power_dbm = self.read_power_dbm()
        
        measurement = PowerMeterMeasurement(
            timestamp=timestamp,
            power_w=power_w,
            power_mw=power_mw,
            power_dbm=power_dbm,
            wavelength_nm=self.wavelength,
            unit_id=unit_id,
            calibration_msg=self.get_calibration_message(),
            connection_method='TLPMX' if self.use_tlpmx else 'PyVISA',
            auto_range_enabled=True
        )
        
        return measurement

    def continuous_monitoring(self, config: PowerMeterMonitorConfig, unit_id: str = None) -> pd.DataFrame:
        if unit_id is None:
            unit_id = getattr(self, 'unit_id', 'PM1')
        
        self.set_wavelength(config.wavelength_nm)
        self.set_power_unit(config.power_unit)
        self.set_auto_range(config.auto_range)
        
        measurements = []
        sample_interval = 1.0 / config.sample_rate_hz
        num_samples = int(config.duration_s * config.sample_rate_hz)
        
        start_time = time.time()
        
        try:
            for i in range(num_samples):
                target_time = start_time + i * sample_interval
                sleep_time = target_time - time.time()
                if sleep_time > 0:
                    time.sleep(sleep_time)
                
                measurement = self.measure_all(unit_id)
                measurements.append(measurement)
                
        except KeyboardInterrupt:
            pass
        
        df = pd.DataFrame([m.to_dict() for m in measurements])
        df['sample_number'] = range(1, len(df) + 1)
        
        if len(df) > 1:
            df['elapsed_time_s'] = (pd.to_datetime(df['timestamp']) - pd.to_datetime(df['timestamp'].iloc[0])).dt.total_seconds()
        else:
            df['elapsed_time_s'] = 0.0
        
        if config.statistical_analysis and len(df) > 1:
            window_size = min(10, len(df))
            df['power_w_rolling_mean'] = df['power_w'].rolling(window=window_size, center=True).mean()
            df['power_w_rolling_std'] = df['power_w'].rolling(window=window_size, center=True).std()
            df['power_stability_percent'] = (df['power_w_rolling_std'] / df['power_w_rolling_mean']) * 100
        
        df['monitoring_type'] = 'continuous'
        
        return df

    def wavelength_response_measurement(self, wavelengths: List[float], 
                                       measurements_per_wavelength: int = 10,
                                       unit_id: str = None) -> pd.DataFrame:
        if unit_id is None:
            unit_id = getattr(self, 'unit_id', 'PM1')
        
        measurements = []
        
        for wavelength in wavelengths:
            self.set_wavelength(wavelength)
            time.sleep(0.5)
            
            for i in range(measurements_per_wavelength):
                measurement = self.measure_all(unit_id)
                measurements.append(measurement)
                time.sleep(0.1)
        
        df = pd.DataFrame([m.to_dict() for m in measurements])
        df['measurement_index'] = range(len(df))
        df['test_type'] = 'wavelength_response'
        
        df['wavelength_group'] = pd.cut(df['wavelength_nm'], bins=len(wavelengths), 
                                       labels=[f"WL_{wl}nm" for wl in wavelengths])
        
        return df

    def power_stability_test(self, duration_minutes: float = 10.0, 
                           sample_rate_hz: float = 1.0,
                           unit_id: str = None) -> pd.DataFrame:
        if unit_id is None:
            unit_id = getattr(self, 'unit_id', 'PM1')
            
        config = PowerMeterMonitorConfig(
            duration_s=duration_minutes * 60,
            sample_rate_hz=sample_rate_hz,
            statistical_analysis=True
        )
        
        stability_data = self.continuous_monitoring(config, unit_id)
        stability_data['test_type'] = 'power_stability'
        
        if len(stability_data) > 10:
            power_mean = stability_data['power_w'].mean()
            power_std = stability_data['power_w'].std()
            stability_percent = (power_std / power_mean) * 100
            
            stability_data['overall_power_mean_w'] = power_mean
            stability_data['overall_power_std_w'] = power_std
            stability_data['overall_stability_percent'] = stability_percent
        
        return stability_data

    def multi_wavelength_monitoring(self, wavelengths: List[float],
                                   duration_per_wavelength_s: float = 30.0,
                                   sample_rate_hz: float = 5.0,
                                   unit_id: str = None) -> pd.DataFrame:
        if unit_id is None:
            unit_id = getattr(self, 'unit_id', 'PM1')
        
        all_measurements = []
        
        for wl in wavelengths:
            config = PowerMeterMonitorConfig(
                duration_s=duration_per_wavelength_s,
                sample_rate_hz=sample_rate_hz,
                wavelength_nm=wl,
                statistical_analysis=True
            )
            
            wl_data = self.continuous_monitoring(config, unit_id)
            wl_data['wavelength_sequence'] = wl
            all_measurements.append(wl_data)
            
            time.sleep(1.0)
        
        combined_df = pd.concat(all_measurements, ignore_index=True)
        combined_df['test_type'] = 'multi_wavelength_monitoring'
        combined_df['global_sample_number'] = range(len(combined_df))
        
        return combined_df

    def get_recorder_ready_data(self, measurements: List[PowerMeterMeasurement] = None,
                               unit_id: str = None) -> pd.DataFrame:
        if measurements is None:
            if unit_id is None:
                unit_id = getattr(self, 'unit_id', 'PM1')
            measurement = self.measure_all(unit_id)
            measurements = [measurement]
            
        df = pd.DataFrame([m.to_dict() for m in measurements])
        
        df['power_uw'] = df['power_w'] * 1e6
        df['power_nw'] = df['power_w'] * 1e9
        df['measurement_index'] = range(len(df))
        
        power_ranges = ['<1nW', '1nW-1uW', '1uW-1mW', '1mW-10mW', '10mW-100mW', '>100mW']
        power_w = df['power_w']
        df['power_range'] = pd.cut(power_w, 
                                  bins=[0, 1e-9, 1e-6, 1e-3, 10e-3, 100e-3, float('inf')],
                                  labels=power_ranges,
                                  right=False)
        
        return df

Thorlabs_PMxxx = ThorlabsPowerMeter


================================================
File: drivers/smu.py
================================================
import pyvisa
import time
import numpy as np
import pandas as pd
from datetime import datetime
from typing import List, Dict, Optional, Tuple, Union, Any
from dataclasses import dataclass, asdict
import logging

@dataclass
class SMUMeasurement:
    """Single SMU measurement data point"""
    timestamp: str
    set_voltage: float
    set_current: float
    measured_voltage: float
    measured_current: float
    measured_power: float
    measured_resistance: float
    compliance_voltage: bool
    compliance_current: bool
    output_enabled: bool
    source_mode: str
    
    def to_dict(self) -> Dict:
        return asdict(self)

@dataclass
class SMUSweepConfig:
    """Configuration for SMU sweep operations"""
    start_value: float
    stop_value: float
    steps: int
    step_delay: float = 0.01
    compliance_limit: float = 10.0
    auto_range: bool = True
    measure_both: bool = True
    log_scale: bool = False

class AimTTi_SMU4000:
    def __init__(self, resource_address: str, unit_id: str = "SMU1"):
        self.resource_address = resource_address
        self.unit_id = unit_id
        self.rm = pyvisa.ResourceManager()
        self.instrument = self.rm.open_resource(resource_address)
        self.instrument.read_termination = '\n'
        self.instrument.write_termination = '\n'
        self.instrument.timeout = 10000  # 10 second timeout
        
        self.current_mode = "UNKNOWN"
        self.output_enabled = False
        self.last_measurement = None
        self.measurement_history: List[SMUMeasurement] = []
        
        self.device_info = self._get_device_info()
        
        self.reset()
        self.enable_output(False)

    def _get_device_info(self) -> Dict[str, str]:
        try:
            idn_parts = self.get_idn().split(',')
            return {
                'manufacturer': idn_parts[0].strip() if len(idn_parts) > 0 else 'Unknown',
                'model': idn_parts[1].strip() if len(idn_parts) > 1 else 'Unknown',
                'serial': idn_parts[2].strip() if len(idn_parts) > 2 else 'Unknown',
                'firmware': idn_parts[3].strip() if len(idn_parts) > 3 else 'Unknown',
                'resource_address': self.resource_address,
                'unit_id': self.unit_id
            }
        except Exception as e:
            return {'unit_id': self.unit_id, 'error': str(e)}

    def get_idn(self) -> str:
        return self.instrument.query("*IDN?")

    def reset(self):
        self.instrument.write("*RST")
        time.sleep(0.5)
        self.current_mode = "UNKNOWN"
        self.output_enabled = False

    def get_errors(self) -> List[str]:
        errors = []
        try:
            while True:
                error = self.instrument.query("SYST:ERR?").strip()
                if "No error" in error or error.startswith("0,"):
                    break
                errors.append(error)
        except:
            pass
        return errors

    def clear_errors(self):
        self.instrument.write("*CLS")

    def set_mode_source_current(self):
        self.instrument.write("SYST:FUNC:MODE SOURCECURR")
        self.current_mode = "CURRENT"
        time.sleep(0.1)

    def set_mode_source_voltage(self):
        self.instrument.write("SYST:FUNC:MODE SOURCEVOLT")
        self.current_mode = "VOLTAGE" 
        time.sleep(0.1)

    def get_source_mode(self) -> str:
        try:
            mode = self.instrument.query("SYST:FUNC:MODE?").strip()
            self.current_mode = mode
            return mode
        except:
            return self.current_mode

    def set_source_current(self, current: float):
        self.instrument.write(f"SOUR:CURR:LEV {current:.6f}")
        
    def get_source_current(self) -> float:
        return float(self.instrument.query("SOUR:CURR:LEV?"))
        
    def set_current_range(self, range_value: float):
        self.instrument.write(f"SOUR:CURR:RANG {range_value:.6f}")
        
    def set_current_auto_range(self, enable: bool):
        state = "ON" if enable else "OFF"
        self.instrument.write(f"SOUR:CURR:RANG:AUTO {state}")

    def set_source_voltage(self, voltage: float):
        self.instrument.write(f"SOUR:VOLT:LEV {voltage:.6f}")
        
    def get_source_voltage(self) -> float:
        return float(self.instrument.query("SOUR:VOLT:LEV?"))
        
    def set_voltage_range(self, range_value: float):
        self.instrument.write(f"SOUR:VOLT:RANG {range_value:.6f}")
        
    def set_voltage_auto_range(self, enable: bool):
        state = "ON" if enable else "OFF"
        self.instrument.write(f"SOUR:VOLT:RANG:AUTO {state}")

    def set_voltage_limit(self, voltage_limit: float):
        self.instrument.write(f"SOUR:CURR:VOLT:LIM {voltage_limit:.4f}")

    def get_voltage_limit(self) -> float:
        return float(self.instrument.query("SOUR:CURR:VOLT:LIM?"))
        
    def set_current_limit(self, current_limit: float):
        self.instrument.write(f"SOUR:VOLT:CURR:LIM {current_limit:.6f}")

    def get_current_limit(self) -> float:
        return float(self.instrument.query("SOUR:VOLT:CURR:LIM?"))

    def enable_output(self, enable: bool):
        state = "ON" if enable else "OFF"
        self.instrument.write(f"OUTP:STAT {state}")
        self.output_enabled = enable
        time.sleep(0.1)  # Allow settling

    def get_output_state(self) -> bool:
        """Get output enable state"""
        try:
            state = self.instrument.query("OUTP:STAT?").strip()
            self.output_enabled = state == "1" or state.upper() == "ON"
            return self.output_enabled
        except:
            return self.output_enabled

    def measure_voltage(self) -> float:
        """Measure voltage"""
        return float(self.instrument.query("MEAS:VOLT?"))
        
    def measure_current(self) -> float:
        """Measure current"""
        return float(self.instrument.query("MEAS:CURR?"))

    def measure_power(self) -> float:
        """Measure power (V * I)"""
        voltage = self.measure_voltage()
        current = self.measure_current()
        return voltage * current

    def measure_resistance(self) -> float:
        """Measure resistance (V / I)"""
        voltage = self.measure_voltage()
        current = self.measure_current()
        if abs(current) < 1e-12:  # Avoid division by zero
            return float('inf')
        return voltage / current

    def measure_all(self) -> SMUMeasurement:
        """Take comprehensive measurement"""
        timestamp = datetime.now().isoformat()
        
        if self.current_mode == "CURRENT":
            set_current = self.get_source_current()
            set_voltage = 0.0
        elif self.current_mode == "VOLTAGE":
            set_voltage = self.get_source_voltage()
            set_current = 0.0
        else:
            set_voltage = set_current = 0.0

        measured_voltage = self.measure_voltage()
        measured_current = self.measure_current()
        measured_power = measured_voltage * measured_current
        
        if abs(measured_current) < 1e-12:
            measured_resistance = float('inf')
        else:
            measured_resistance = measured_voltage / measured_current

        compliance_voltage = False
        compliance_current = False
        measurement = SMUMeasurement(
            timestamp=timestamp,
            set_voltage=set_voltage,
            set_current=set_current,
            measured_voltage=measured_voltage,
            measured_current=measured_current,
            measured_power=measured_power,
            measured_resistance=measured_resistance,
            compliance_voltage=compliance_voltage,
            compliance_current=compliance_current,
            output_enabled=self.get_output_state(),
            source_mode=self.get_source_mode()
        )
        
        self.last_measurement = measurement
        self.measurement_history.append(measurement)
        
        return measurement

    def voltage_sweep(self, config: SMUSweepConfig) -> pd.DataFrame:
        
        self.set_mode_source_voltage()
        self.set_current_limit(config.compliance_limit)
        
        if config.log_scale:
            if config.start_value <= 0 or config.stop_value <= 0:
                raise ValueError("Log scale requires positive start and stop values")
            sweep_points = np.logspace(np.log10(config.start_value), np.log10(config.stop_value), config.steps)
        else:
            sweep_points = np.linspace(config.start_value, config.stop_value, config.steps)
        
        measurements = []
        self.enable_output(True)
        
        try:
            for i, voltage in enumerate(sweep_points):
                self.set_source_voltage(voltage)
                time.sleep(config.step_delay)
                
                measurement = self.measure_all()
                measurements.append(measurement)
                
        finally:
            self.enable_output(False)
        
        df = pd.DataFrame([m.to_dict() for m in measurements])
        df['unit_id'] = self.unit_id
        df['sweep_type'] = 'voltage'
        df['step_number'] = range(1, len(df) + 1)
        
        return df

    def current_sweep(self, config: SMUSweepConfig) -> pd.DataFrame:
        
        self.set_mode_source_current()
        self.set_voltage_limit(config.compliance_limit)
        
        if config.log_scale:
            if config.start_value <= 0 or config.stop_value <= 0:
                raise ValueError("Log scale requires positive start and stop values")
            sweep_points = np.logspace(np.log10(config.start_value), np.log10(config.stop_value), config.steps)
        else:
            sweep_points = np.linspace(config.start_value, config.stop_value, config.steps)
        
        measurements = []
        self.enable_output(True)
        
        try:
            for i, current in enumerate(sweep_points):
                self.set_source_current(current)
                time.sleep(config.step_delay)
                
                measurement = self.measure_all()
                measurements.append(measurement)
                
        finally:
            self.enable_output(False)
        
        df = pd.DataFrame([m.to_dict() for m in measurements])
        df['unit_id'] = self.unit_id
        df['sweep_type'] = 'current'
        df['step_number'] = range(1, len(df) + 1)
        
        return df

    def iv_characterization(self, voltage_range: Tuple[float, float], voltage_steps: int, 
                           current_range: Tuple[float, float], current_steps: int,
                           step_delay: float = 0.02) -> pd.DataFrame:
        
        v_config = SMUSweepConfig(
            start_value=voltage_range[0],
            stop_value=voltage_range[1], 
            steps=voltage_steps,
            step_delay=step_delay,
            compliance_limit=max(abs(current_range[0]), abs(current_range[1]))
        )
        
        i_config = SMUSweepConfig(
            start_value=current_range[0],
            stop_value=current_range[1],
            steps=current_steps,
            step_delay=step_delay,
            compliance_limit=max(abs(voltage_range[0]), abs(voltage_range[1]))
        )
        
        v_sweep_data = self.voltage_sweep(v_config)
        time.sleep(1.0)  # Brief pause between sweeps
        i_sweep_data = self.current_sweep(i_config)
        
        combined_df = pd.concat([v_sweep_data, i_sweep_data], ignore_index=True)
        combined_df['characterization_type'] = 'iv_complete'
        
        return combined_df

    def get_recorder_ready_data(self, measurements: List[SMUMeasurement] = None) -> pd.DataFrame:
        """
        Convert measurements to recorder-ready DataFrame format
        
        Args:
            measurements: Optional list of measurements, uses history if None
            
        Returns:
            DataFrame formatted for recorder.record_complete_dataset()
        """
        if measurements is None:
            measurements = self.measurement_history
            
        if not measurements:
            return pd.DataFrame()
        
        df = pd.DataFrame([m.to_dict() for m in measurements])
        df['unit_id'] = self.unit_id
        
        df['power_mw'] = df['measured_power'] * 1000
        df['current_ma'] = df['measured_current'] * 1000
        df['resistance_kohm'] = df['measured_resistance'] / 1000
        
        df['measurement_index'] = range(len(df))
        
        return df

    def get_status(self) -> Dict[str, Any]:
        """Get comprehensive SMU status"""
        try:
            errors = self.get_errors()
            return {
                'unit_id': self.unit_id,
                'device_info': self.device_info,
                'output_enabled': self.get_output_state(),
                'source_mode': self.get_source_mode(),
                'source_voltage_v': self.get_source_voltage() if self.current_mode == "VOLTAGE" else None,
                'source_current_a': self.get_source_current() if self.current_mode == "CURRENT" else None,
                'voltage_limit_v': self.get_voltage_limit() if self.current_mode == "CURRENT" else None,
                'current_limit_a': self.get_current_limit() if self.current_mode == "VOLTAGE" else None,
                'last_measurement': self.last_measurement.to_dict() if self.last_measurement else None,
                'total_measurements': len(self.measurement_history),
                'errors': errors,
                'connected': True
            }
        except Exception as e:
            return {
                'unit_id': self.unit_id,
                'error': str(e),
                'connected': False
            }

    def clear_measurement_history(self):
        """Clear measurement history"""
        self.measurement_history.clear()
        self.last_measurement = None

    def disconnect(self):
        """Safely disconnect SMU"""
        try:
            self.enable_output(False)
            time.sleep(0.1)
            self.instrument.close()
            self.rm.close()
            print(f"{self.unit_id} disconnected safely")
        except Exception as e:
            print(f"Error disconnecting {self.unit_id}: {e}")

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.disconnect()




================================================
File: drivers/tti_qlp355.py
================================================
import pyvisa
import time
import numpy as np
import pandas as pd
from datetime import datetime
from typing import List, Dict, Tuple, Any
from dataclasses import dataclass, asdict
import logging

@dataclass
class PSUChannelMeasurement:
    timestamp: str
    channel: int
    set_voltage: float
    set_current_limit: float
    measured_voltage: float
    measured_current: float
    measured_power: float
    output_enabled: bool
    in_cv_mode: bool
    in_cc_mode: bool
    over_voltage_protection: bool
    over_current_protection: bool
    
    def to_dict(self) -> Dict:
        return asdict(self)

@dataclass
class PSUSweepConfig:
    channel: int
    start_voltage: float
    stop_voltage: float
    steps: int
    current_limit: float
    step_delay: float = 0.1
    measure_settling_time: float = 0.05
    log_scale: bool = False
    auto_range: bool = True

class TTi_QL355TP:
    def __init__(self, resource_address: str, unit_id: str = "PSU1"):
        self.resource_address = resource_address
        self.unit_id = unit_id
        self.rm = pyvisa.ResourceManager()
        self.instrument = self.rm.open_resource(resource_address)
        self.instrument.read_termination = '\n'
        self.instrument.write_termination = '\n'
        self.instrument.timeout = 5000  # 5 second timeout
        
        self.channel_states = {1: {'enabled': False, 'voltage': 0.0, 'current_limit': 0.0},
                              2: {'enabled': False, 'voltage': 0.0, 'current_limit': 0.0}}
        self.measurement_history: List[PSUChannelMeasurement] = []
        self.last_measurements = {1: None, 2: None}
        
        self.device_info = self._get_device_info()
        
        self.reset()

    def _get_device_info(self) -> Dict[str, str]:
        try:
            idn_parts = self.get_idn().split(',')
            return {
                'manufacturer': idn_parts[0].strip() if len(idn_parts) > 0 else 'Unknown',
                'model': idn_parts[1].strip() if len(idn_parts) > 1 else 'Unknown',
                'serial': idn_parts[2].strip() if len(idn_parts) > 2 else 'Unknown',
                'firmware': idn_parts[3].strip() if len(idn_parts) > 3 else 'Unknown',
                'resource_address': self.resource_address,
                'unit_id': self.unit_id
            }
        except Exception as e:
            return {'unit_id': self.unit_id, 'error': str(e)}

    def get_idn(self) -> str:
        return self.instrument.query("*IDN?")

    def reset(self):
        self.enable_output(1, False)
        self.enable_output(2, False)
        time.sleep(0.1)
        
        self.instrument.write("*RST")
        time.sleep(0.5)
        
        for channel in [1, 2]:
            self.channel_states[channel] = {'enabled': False, 'voltage': 0.0, 'current_limit': 0.0}

    def get_errors(self) -> List[str]:
        """Get any system errors"""
        errors = []
        try:
            while True:
                try:
                    error = self.instrument.query("SYST:ERR?").strip()
                    if "No error" in error or error.startswith("0,"):
                        break
                    errors.append(error)
                except:
                    break
        except:
            pass
        return errors

    def _validate_channel(self, channel: int):
        """Validate channel number"""
        if channel not in [1, 2]:
            raise ValueError(f"Channel must be 1 or 2, got {channel}")

    def set_voltage(self, channel: int, voltage: float):
        """Set channel voltage"""
        self._validate_channel(channel)
        self.instrument.write(f"V{channel} {voltage:.4f}")
        self.channel_states[channel]['voltage'] = voltage
        time.sleep(0.01)  # Brief settling

    def get_set_voltage(self, channel: int) -> float:
        """Get voltage setting for channel"""
        self._validate_channel(channel)
        try:
            response = self.instrument.query(f"V{channel}?")
            voltage = float(response)
            self.channel_states[channel]['voltage'] = voltage
            return voltage
        except:
            return self.channel_states[channel]['voltage']

    def get_output_voltage(self, channel: int) -> float:
        """Get actual output voltage"""
        self._validate_channel(channel)
        response = self.instrument.query(f"V{channel}O?")
        return float(response)

    def set_current_limit(self, channel: int, current: float):
        """Set channel current limit"""
        self._validate_channel(channel)
        self.instrument.write(f"I{channel} {current:.4f}")
        self.channel_states[channel]['current_limit'] = current
        time.sleep(0.01)

    def get_set_current_limit(self, channel: int) -> float:
        """Get current limit setting"""
        self._validate_channel(channel)
        try:
            response = self.instrument.query(f"I{channel}?")
            current = float(response)
            self.channel_states[channel]['current_limit'] = current
            return current
        except:
            return self.channel_states[channel]['current_limit']

    def get_output_current(self, channel: int) -> float:
        """Get actual output current"""
        self._validate_channel(channel)
        response = self.instrument.query(f"I{channel}O?")
        return float(response)

    def enable_output(self, channel: int, enable: bool):
        """Enable/disable channel output"""
        self._validate_channel(channel)
        state = 1 if enable else 0
        self.instrument.write(f"OP{channel} {state}")
        self.channel_states[channel]['enabled'] = enable
        time.sleep(0.1)  # Allow settling

    def get_output_state(self, channel: int) -> bool:
        """Get output enable state"""
        self._validate_channel(channel)
        try:
            response = self.instrument.query(f"OP{channel}?")
            enabled = int(response) == 1
            self.channel_states[channel]['enabled'] = enabled
            return enabled
        except:
            return self.channel_states[channel]['enabled']

    def enable_all_outputs(self, enable: bool):
        """Enable/disable all outputs"""
        for channel in [1, 2]:
            self.enable_output(channel, enable)

    def measure_power(self, channel: int) -> float:
        """Measure channel power (V * I)"""
        voltage = self.get_output_voltage(channel)
        current = self.get_output_current(channel)
        return voltage * current

    def get_channel_mode(self, channel: int) -> Dict[str, bool]:
        """Get channel operating mode (CV/CC)"""
        self._validate_channel(channel)
        voltage = self.get_output_voltage(channel)
        current = self.get_output_current(channel)
        set_voltage = self.get_set_voltage(channel)
        current_limit = self.get_set_current_limit(channel)
        
        in_cc_mode = abs(current - current_limit) < 0.01
        in_cv_mode = not in_cc_mode
        
        return {
            'cv_mode': in_cv_mode,
            'cc_mode': in_cc_mode,
            'voltage_regulation': in_cv_mode,
            'current_regulation': in_cc_mode
        }

    def measure_channel_all(self, channel: int) -> PSUChannelMeasurement:
        """Take comprehensive measurement for one channel"""
        self._validate_channel(channel)
        timestamp = datetime.now().isoformat()
        
        set_voltage = self.get_set_voltage(channel)
        set_current_limit = self.get_set_current_limit(channel)
        
        measured_voltage = self.get_output_voltage(channel)
        measured_current = self.get_output_current(channel)
        measured_power = measured_voltage * measured_current
        
        output_enabled = self.get_output_state(channel)
        channel_mode = self.get_channel_mode(channel)
        
        measurement = PSUChannelMeasurement(
            timestamp=timestamp,
            channel=channel,
            set_voltage=set_voltage,
            set_current_limit=set_current_limit,
            measured_voltage=measured_voltage,
            measured_current=measured_current,
            measured_power=measured_power,
            output_enabled=output_enabled,
            in_cv_mode=channel_mode['cv_mode'],
            in_cc_mode=channel_mode['cc_mode'],
            over_voltage_protection=False,  # Would need instrument query
            over_current_protection=False   # Would need instrument query
        )
        
        self.last_measurements[channel] = measurement
        self.measurement_history.append(measurement)
        
        return measurement

    def measure_all_channels(self) -> Dict[int, PSUChannelMeasurement]:
        """Take measurements for all channels"""
        measurements = {}
        for channel in [1, 2]:
            measurements[channel] = self.measure_channel_all(channel)
        return measurements

    def voltage_sweep(self, config: PSUSweepConfig) -> pd.DataFrame:
        """
        Perform voltage sweep on specified channel
        
        Returns:
            DataFrame ready for recorder.record_complete_dataset()
        """
        print(f"Starting voltage sweep on {self.unit_id} CH{config.channel}: {config.start_voltage}V to {config.stop_voltage}V, {config.steps} steps")
        
        self._validate_channel(config.channel)
        
        self.set_current_limit(config.channel, config.current_limit)
        
        if config.log_scale:
            if config.start_voltage <= 0 or config.stop_voltage <= 0:
                raise ValueError("Log scale requires positive start and stop voltages")
            sweep_points = np.logspace(np.log10(config.start_voltage), np.log10(config.stop_voltage), config.steps)
        else:
            sweep_points = np.linspace(config.start_voltage, config.stop_voltage, config.steps)
        
        measurements = []
        self.enable_output(config.channel, True)
        
        try:
            for i, voltage in enumerate(sweep_points):
                self.set_voltage(config.channel, voltage)
                time.sleep(config.step_delay)
                
                if config.measure_settling_time > 0:
                    time.sleep(config.measure_settling_time)
                
                measurement = self.measure_channel_all(config.channel)
                measurements.append(measurement)
                
                print(f"Step {i+1}/{config.steps}: V={voltage:.4f}V -> I={measurement.measured_current*1000:.3f}mA, P={measurement.measured_power*1000:.3f}mW")
                
        finally:
            self.enable_output(config.channel, False)
        
        df = pd.DataFrame([m.to_dict() for m in measurements])
        df['unit_id'] = self.unit_id
        df['sweep_type'] = 'voltage'
        df['step_number'] = range(1, len(df) + 1)
        
        return df

    def load_regulation_test(self, channel: int, voltage: float, 
                           current_steps: List[float], 
                           step_delay: float = 0.2) -> pd.DataFrame:
        """
        Test load regulation by varying current draw
        
        Args:
            channel: PSU channel to test
            voltage: Fixed voltage to maintain
            current_steps: List of current limits to test
            step_delay: Delay between steps
            
        Returns:
            DataFrame ready for recorder
        """
        print(f"Starting load regulation test on {self.unit_id} CH{channel} at {voltage}V")
        
        self._validate_channel(channel)
        self.set_voltage(channel, voltage)
        
        measurements = []
        self.enable_output(channel, True)
        
        try:
            for i, current_limit in enumerate(current_steps):
                self.set_current_limit(channel, current_limit)
                time.sleep(step_delay)
                
                measurement = self.measure_channel_all(channel)
                measurements.append(measurement)
                
                print(f"Step {i+1}/{len(current_steps)}: Ilim={current_limit*1000:.1f}mA -> V={measurement.measured_voltage:.4f}V, I={measurement.measured_current*1000:.3f}mA")
                
        finally:
            self.enable_output(channel, False)
        
        df = pd.DataFrame([m.to_dict() for m in measurements])
        df['unit_id'] = self.unit_id
        df['test_type'] = 'load_regulation'
        df['step_number'] = range(1, len(df) + 1)
        
        return df

    def dual_channel_tracking_test(self, voltage_steps: List[float],
                                  current_limit: float = 1.0,
                                  step_delay: float = 0.2) -> pd.DataFrame:
        """
        Test dual channel tracking by setting both channels to same voltage
        
        Returns:
            DataFrame with measurements from both channels
        """
        print(f"Starting dual channel tracking test on {self.unit_id}")
        
        measurements = []
        
        for channel in [1, 2]:
            self.set_current_limit(channel, current_limit)
        
        self.enable_all_outputs(True)
        
        try:
            for i, voltage in enumerate(voltage_steps):
                self.set_voltage(1, voltage)
                self.set_voltage(2, voltage)
                time.sleep(step_delay)
                
                ch1_measurement = self.measure_channel_all(1)
                ch2_measurement = self.measure_channel_all(2)
                
                measurements.extend([ch1_measurement, ch2_measurement])
                
                print(f"Step {i+1}/{len(voltage_steps)}: V={voltage:.3f}V -> CH1: {ch1_measurement.measured_voltage:.4f}V, CH2: {ch2_measurement.measured_voltage:.4f}V")
                
        finally:
            self.enable_all_outputs(False)
        
        df = pd.DataFrame([m.to_dict() for m in measurements])
        df['unit_id'] = self.unit_id
        df['test_type'] = 'dual_channel_tracking'
        df['step_number'] = [i//2 + 1 for i in range(len(df))]  # Each step has 2 measurements
        
        return df

    def get_recorder_ready_data(self, measurements: List[PSUChannelMeasurement] = None) -> pd.DataFrame:
        """
        Convert measurements to recorder-ready DataFrame format
        
        Args:
            measurements: Optional list of measurements, uses history if None
            
        Returns:
            DataFrame formatted for recorder.record_complete_dataset()
        """
        if measurements is None:
            measurements = self.measurement_history
            
        if not measurements:
            return pd.DataFrame()
        
        df = pd.DataFrame([m.to_dict() for m in measurements])
        df['unit_id'] = self.unit_id
        
        df['power_mw'] = df['measured_power'] * 1000
        df['current_ma'] = df['measured_current'] * 1000
        df['voltage_error_mv'] = (df['measured_voltage'] - df['set_voltage']) * 1000
        df['load_resistance_ohm'] = np.where(df['measured_current'] > 1e-6, 
                                           df['measured_voltage'] / df['measured_current'], 
                                           np.inf)
        
        df['measurement_index'] = range(len(df))
        
        return df

    def get_status(self) -> Dict[str, Any]:
        """Get comprehensive PSU status"""
        try:
            errors = self.get_errors()
            
            channels_status = {}
            for channel in [1, 2]:
                measurement = self.measure_channel_all(channel)
                channels_status[f'channel_{channel}'] = {
                    'set_voltage_v': measurement.set_voltage,
                    'set_current_limit_a': measurement.set_current_limit,
                    'measured_voltage_v': measurement.measured_voltage,
                    'measured_current_a': measurement.measured_current,
                    'measured_power_w': measurement.measured_power,
                    'output_enabled': measurement.output_enabled,
                    'cv_mode': measurement.in_cv_mode,
                    'cc_mode': measurement.in_cc_mode
                }
            
            return {
                'unit_id': self.unit_id,
                'device_info': self.device_info,
                'channels': channels_status,
                'total_measurements': len(self.measurement_history),
                'errors': errors,
                'connected': True
            }
        except Exception as e:
            return {
                'unit_id': self.unit_id,
                'error': str(e),
                'connected': False
            }

    def clear_measurement_history(self):
        """Clear measurement history"""
        self.measurement_history.clear()
        self.last_measurements = {1: None, 2: None}

    def disconnect(self):
        """Safely disconnect PSU"""
        try:
            self.enable_all_outputs(False)
            time.sleep(0.1)
            self.instrument.close()
            self.rm.close()
            print(f"{self.unit_id} disconnected safely")
        except Exception as e:
            print(f"Error disconnecting {self.unit_id}: {e}")

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.disconnect()

TTi_QL355T = TTi_QL355TP



================================================
File: tests/TLPMX.py
================================================
import os
from ctypes import cdll,c_long,c_uint32,c_uint16,c_uint8,byref,create_string_buffer,c_bool, c_char, c_char_p,c_int,c_int16,c_int8,c_double,c_float,sizeof,c_voidp, Structure

_VI_ERROR = (-2147483647-1)
VI_ON = 1
VI_OFF = 0
TLPM_VID_THORLABS = (0x1313)  # Thorlabs
TLPM_PID_TLPM_DFU = (0x8070)  # PM100D with DFU interface enabled
TLPM_PID_PM100A_DFU = (0x8071)  # PM100A with DFU interface enabled
TLPM_PID_PM100USB = (0x8072)  # PM100USB with DFU interface enabled
TLPM_PID_PM160USB_DFU = (0x8073)  # PM160 on USB with DFU interface enabled
TLPM_PID_PM160TUSB_DFU = (0x8074)  # PM160T on USB with DFU interface enabled
TLPM_PID_PM400_DFU = (0x8075)  # PM400 on USB with DFU interface enabled
TLPM_PID_PM101_DFU = (0x8076)  # PM101 on USB with DFU interface enabled (Interface 0 TMC, Interface 1 DFU)
TLPM_PID_PM102_DFU = (0x8077)  # PM102 on USB with DFU interface enabled (Interface 0 TMC, Interface 1 DFU)
TLPM_PID_PM103_DFU = (0x807A)  # PM103 on USB with DFU interface enabled (Interface 0 TMC, Interface 1 DFU)
TLPM_PID_PM100D = (0x8078)  # PM100D w/o DFU interface
TLPM_PID_PM100A = (0x8079)  # PM100A w/o DFU interface
TLPM_PID_PM160USB = (0x807B)  # PM160 on USB w/o DFU interface
TLPM_PID_PM160TUSB = (0x807C)  # PM160T on USB w/o DFU interface
TLPM_PID_PM400 = (0x807D)  # PM400 on USB w/o DFU interface
TLPM_PID_PM101 = (0x807E)  # reserved
TLPM_PID_PMTest = (0x807F)  # PM Test Platform
TLPM_PID_PM200 = (0x80B0)  # PM200
TLPM_PID_PM5020 = (0x80BB)  # PM5020 1 channel benchtop powermeter (Interface 0 TMC, Interface 1 DFU)
TLPM_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x8070 || VI_ATTR_MODEL_CODE==0x8078)}"
PM100A_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x8071 || VI_ATTR_MODEL_CODE==0x8079)}"
PM100USB_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && VI_ATTR_MODEL_CODE==0x8072}"
PM160USB_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x8073 || VI_ATTR_MODEL_CODE==0x807B)}"
PM160TUSB_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x8074 || VI_ATTR_MODEL_CODE==0x807C)}"
PM200_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && VI_ATTR_MODEL_CODE==0x80B0}"
PM400_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x8075 || VI_ATTR_MODEL_CODE==0x807D)}"
PM101_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x8076)}"
PM102_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x8077)}"
PM103_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && VI_ATTR_MODEL_CODE==0x807A}"
PMTest_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && VI_ATTR_MODEL_CODE==0x807F}"
PM100_FIND_PATTERN = "USB?*::0x1313::0x807?::?*::INSTR"
PM5020_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && VI_ATTR_MODEL_CODE==0x80BB}"
PMxxx_FIND_PATTERN = "USB?*INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x8070 || VI_ATTR_MODEL_CODE==0x8078 || " \
"VI_ATTR_MODEL_CODE==0x8071 || VI_ATTR_MODEL_CODE==0x8079 || " \
"VI_ATTR_MODEL_CODE==0x8072 || " \
"VI_ATTR_MODEL_CODE==0x8073 || VI_ATTR_MODEL_CODE==0x807B || " \
"VI_ATTR_MODEL_CODE==0x8074 || VI_ATTR_MODEL_CODE==0x807C || " \
"VI_ATTR_MODEL_CODE==0x8075 || VI_ATTR_MODEL_CODE==0x807D || " \
"VI_ATTR_MODEL_CODE==0x8076 || VI_ATTR_MODEL_CODE==0x807E || " \
"VI_ATTR_MODEL_CODE==0x8077 || VI_ATTR_MODEL_CODE==0x807F || " \
"VI_ATTR_MODEL_CODE==0x807A || VI_ATTR_MODEL_CODE==0x80BB ||" \
"VI_ATTR_MODEL_CODE==0x80B0)}"
PMBT_FIND_PATTERN = "ASRL?*::INSTR{VI_ATTR_MANF_ID==0x1313 && (VI_ATTR_MODEL_CODE==0x807C || VI_ATTR_MODEL_CODE==0x807B)}"
PMUART_FIND_PATTERN_VISA = "ASRL?*::INSTR"
PMUART_FIND_PATTERN_COM = "COM?*"
TLPM_BUFFER_SIZE = 256  # General buffer size
TLPM_ERR_DESCR_BUFFER_SIZE = 512  # Buffer size for error messages
VI_INSTR_WARNING_OFFSET = (0x3FFC0900 )
VI_INSTR_ERROR_OFFSET = (_VI_ERROR + 0x3FFC0900 )
VI_INSTR_ERROR_NOT_SUPP_INTF = (VI_INSTR_ERROR_OFFSET + 0x01 )
VI_INSTR_WARN_OVERFLOW = (VI_INSTR_WARNING_OFFSET + 0x01 )
VI_INSTR_WARN_UNDERRUN = (VI_INSTR_WARNING_OFFSET + 0x02 )
VI_INSTR_WARN_NAN = (VI_INSTR_WARNING_OFFSET + 0x03 )
TLPM_ATTR_SET_VAL = (0)
TLPM_ATTR_MIN_VAL = (1)
TLPM_ATTR_MAX_VAL = (2)
TLPM_ATTR_DFLT_VAL = (3)
TLPM_ATTR_AUTO_VAL = (9)
TLPM_DEFAULT_CHANNEL = (1)
TLPM_SENSOR_CHANNEL1 = (1)
TLPM_SENSOR_CHANNEL2 = (2)
TLPM_INDEX_1 = (1)
TLPM_INDEX_2 = (2)
TLPM_INDEX_3 = (3)
TLPM_INDEX_4 = (4)
TLPM_INDEX_5 = (5)
TLPM_PEAK_FILTER_NONE = (0)
TLPM_PEAK_FILTER_OVER = (1)
TLPM_REG_STB = (0)  # < Status Byte Register
TLPM_REG_SRE = (1)  # < Service Request Enable
TLPM_REG_ESB = (2)  # < Standard Event Status Register
TLPM_REG_ESE = (3)  # < Standard Event Enable
TLPM_REG_OPER_COND = (4)  # < Operation Condition Register
TLPM_REG_OPER_EVENT = (5)  # < Operation Event Register
TLPM_REG_OPER_ENAB = (6)  # < Operation Event Enable Register
TLPM_REG_OPER_PTR = (7)  # < Operation Positive Transition Filter
TLPM_REG_OPER_NTR = (8)  # < Operation Negative Transition Filter
TLPM_REG_QUES_COND = (9)  # < Questionable Condition Register
TLPM_REG_QUES_EVENT = (10)  # < Questionable Event Register
TLPM_REG_QUES_ENAB = (11)  # < Questionable Event Enable Reg.
TLPM_REG_QUES_PTR = (12)  # < Questionable Positive Transition Filter
TLPM_REG_QUES_NTR = (13)  # < Questionable Negative Transition Filter
TLPM_REG_MEAS_COND = (14)  # < Measurement Condition Register
TLPM_REG_MEAS_EVENT = (15)  # < Measurement Event Register
TLPM_REG_MEAS_ENAB = (16)  # < Measurement Event Enable Register
TLPM_REG_MEAS_PTR = (17)  # < Measurement Positive Transition Filter
TLPM_REG_MEAS_NTR = (18)  # < Measurement Negative Transition Filter
TLPM_REG_AUX_COND = (19)  # < Auxiliary Condition Register
TLPM_REG_AUX_EVENT = (20)  # < Auxiliary Event Register
TLPM_REG_AUX_ENAB = (21)  # < Auxiliary Event Enable Register
TLPM_REG_AUX_PTR = (22)  # < Auxiliary Positive Transition Filter
TLPM_REG_AUX_NTR = (23)  # < Auxiliary Negative Transition Filter
TLPM_REG_OPER_COND_1 = (24)  # < Operation Condition Register Channel 1
TLPM_REG_OPER_COND_2 = (25)  # < Operation Condition Register Channel 2
TLPM_REG_AUX_DET_COND = (26)  # < Auxiliary Condition Register DET
TLPM_STATBIT_STB_AUX = (0x01)  # < Auxiliary summary
TLPM_STATBIT_STB_MEAS = (0x02)  # < Device Measurement Summary
TLPM_STATBIT_STB_EAV = (0x04)  # < Error available
TLPM_STATBIT_STB_QUES = (0x08)  # < Questionable Status Summary
TLPM_STATBIT_STB_MAV = (0x10)  # < Message available
TLPM_STATBIT_STB_ESB = (0x20)  # < Event Status Bit
TLPM_STATBIT_STB_MSS = (0x40)  # < Master summary status
TLPM_STATBIT_STB_OPER = (0x80)  # < Operation Status Summary
TLPM_STATBIT_ESR_OPC = (0x01)  # < Operation complete
TLPM_STATBIT_ESR_RQC = (0x02)  # < Request control
TLPM_STATBIT_ESR_QYE = (0x04)  # < Query error
TLPM_STATBIT_ESR_DDE = (0x08)  # < Device-Specific error
TLPM_STATBIT_ESR_EXE = (0x10)  # < Execution error
TLPM_STATBIT_ESR_CME = (0x20)  # < Command error
TLPM_STATBIT_ESR_URQ = (0x40)  # < User request
TLPM_STATBIT_ESR_PON = (0x80)  # < Power on
TLPM_STATBIT_QUES_VOLT = (0x0001)  # < questionable voltage measurement
TLPM_STATBIT_QUES_CURR = (0x0002)  # < questionable current measurement
TLPM_STATBIT_QUES_TIME = (0x0004)  # < questionable time measurement
TLPM_STATBIT_QUES_POW = (0x0008)  # < questionable power measurement
TLPM_STATBIT_QUES_TEMP = (0x0010)  # < questionable temperature measurement
TLPM_STATBIT_QUES_FREQ = (0x0020)  # < questionable frequency measurement
TLPM_STATBIT_QUES_PHAS = (0x0040)  # < questionable phase measurement
TLPM_STATBIT_QUES_MOD = (0x0080)  # < questionable modulation measurement
TLPM_STATBIT_QUES_CAL = (0x0100)  # < questionable calibration
TLPM_STATBIT_QUES_ENER = (0x0200)  # < questionable energy measurement
TLPM_STATBIT_QUES_10 = (0x0400)  # < reserved
TLPM_STATBIT_QUES_11 = (0x0800)  # < reserved
TLPM_STATBIT_QUES_12 = (0x1000)  # < reserved
TLPM_STATBIT_QUES_INST = (0x2000)  # < instrument summary
TLPM_STATBIT_QUES_WARN = (0x4000)  # < command warning
TLPM_STATBIT_QUES_15 = (0x8000)  # < reserved
TLPM_STATBIT_OPER_CAL = (0x0001)  # < The instrument is currently performing a calibration.
TLPM_STATBIT_OPER_SETT = (0x0002)  # < The instrument is waiting for signals it controls to stabilize enough to begin measurements.
TLPM_STATBIT_OPER_RANG = (0x0004)  # < The instrument is currently changing its range.
TLPM_STATBIT_OPER_SWE = (0x0008)  # < A sweep is in progress.
TLPM_STATBIT_OPER_MEAS = (0x0010)  # < The instrument is actively measuring.
TLPM_STATBIT_OPER_TRIG = (0x0020)  # < The instrument is in a �wait for trigger� state of the trigger model.
TLPM_STATBIT_OPER_ARM = (0x0040)  # < The instrument is in a �wait for arm� state of the trigger model.
TLPM_STATBIT_OPER_CORR = (0x0080)  # < The instrument is currently performing a correction (Auto-PID tune).
TLPM_STATBIT_OPER_SENS = (0x0100)  # < Optical powermeter sensor connected and operable.
TLPM_STATBIT_OPER_DATA = (0x0200)  # < Measurement data ready for fetch.
TLPM_STATBIT_OPER_THAC = (0x0400)  # < Thermopile accelerator active.
TLPM_STATBIT_OPER_11 = (0x0800)  # < reserved
TLPM_STATBIT_OPER_12 = (0x1000)  # < reserved
TLPM_STATBIT_OPER_INST = (0x2000)  # < One of n multiple logical instruments is reporting OPERational status.
TLPM_STATBIT_OPER_PROG = (0x4000)  # < A user-defined programming is currently in the run state.
TLPM_STATBIT_OPER_15 = (0x8000)  # < reserved
TLPM_STATBIT_MEAS_0 = (0x0001)  # < reserved
TLPM_STATBIT_MEAS_1 = (0x0002)  # < reserved
TLPM_STATBIT_MEAS_2 = (0x0004)  # < reserved
TLPM_STATBIT_MEAS_3 = (0x0008)  # < reserved
TLPM_STATBIT_MEAS_4 = (0x0010)  # < reserved
TLPM_STATBIT_MEAS_5 = (0x0020)  # < reserved
TLPM_STATBIT_MEAS_6 = (0x0040)  # < reserved
TLPM_STATBIT_MEAS_7 = (0x0080)  # < reserved
TLPM_STATBIT_MEAS_8 = (0x0100)  # < reserved
TLPM_STATBIT_MEAS_9 = (0x0200)  # < reserved
TLPM_STATBIT_MEAS_10 = (0x0400)  # < reserved
TLPM_STATBIT_MEAS_11 = (0x0800)  # < reserved
TLPM_STATBIT_MEAS_12 = (0x1000)  # < reserved
TLPM_STATBIT_MEAS_13 = (0x2000)  # < reserved
TLPM_STATBIT_MEAS_14 = (0x4000)  # < reserved
TLPM_STATBIT_MEAS_15 = (0x8000)  # < reserved
TLPM_STATBIT_AUX_NTC = (0x0001)  # < Auxiliary NTC temperature sensor connected.
TLPM_STATBIT_AUX_EMM = (0x0002)  # < External measurement module connected.
TLPM_STATBIT_AUX_UPCS = (0x0004)  # < User Power Calibration supported by this instrument
TLPM_STATBIT_AUX_UPCA = (0x0008)  # < User Power Calibration active status
TLPM_STATBIT_AUX_EXPS = (0x0010)  # < External power supply connected
TLPM_STATBIT_AUX_BATC = (0x0020)  # < Battery charging
TLPM_STATBIT_AUX_BATL = (0x0040)  # < Battery low
TLPM_STATBIT_AUX_IPS = (0x0080)  # < Apple(tm) authentification supported. True if an authentification co-processor is installed.
TLPM_STATBIT_AUX_IPF = (0x0100)  # < Apple(tm) authentification failed. True if the authentification setup procedure failed.
TLPM_STATBIT_AUX_9 = (0x0200)  # < reserved
TLPM_STATBIT_AUX_10 = (0x0400)  # < reserved
TLPM_STATBIT_AUX_11 = (0x0800)  # < reserved
TLPM_STATBIT_AUX_12 = (0x1000)  # < reserved
TLPM_STATBIT_AUX_13 = (0x2000)  # < reserved
TLPM_STATBIT_AUX_14 = (0x4000)  # < reserved
TLPM_STATBIT_AUX_15 = (0x8000)  # < reserved
TLPM_WINTERTIME = (0)
TLPM_SUMMERTIME = (1)
TLPM_LINE_FREQ_50 = (50)  # < line frequency in Hz
TLPM_LINE_FREQ_60 = (60)  # < line frequency in Hz
TLPM_INPUT_FILTER_STATE_OFF = (0)
TLPM_INPUT_FILTER_STATE_ON = (1)
TLPM_ACCELERATION_STATE_OFF = (0)
TLPM_ACCELERATION_STATE_ON = (1)
TLPM_ACCELERATION_MANUAL = (0)
TLPM_ACCELERATION_AUTO = (1)
TLPM_STAT_DARK_ADJUST_FINISHED = (0)
TLPM_STAT_DARK_ADJUST_RUNNING = (1)
TLPM_AUTORANGE_CURRENT_OFF = (0)
TLPM_AUTORANGE_CURRENT_ON = (1)
TLPM_CURRENT_REF_OFF = (0)
TLPM_CURRENT_REF_ON = (1)
TLPM_ENERGY_REF_OFF = (0)
TLPM_ENERGY_REF_ON = (1)
TLPM_FREQ_MODE_CW = (0)
TLPM_FREQ_MODE_PEAK = (1)
TLPM_AUTORANGE_POWER_OFF = (0)
TLPM_AUTORANGE_POWER_ON = (1)
TLPM_POWER_REF_OFF = (0)
TLPM_POWER_REF_ON = (1)
TLPM_POWER_UNIT_WATT = (0)
TLPM_POWER_UNIT_DBM = (1)
SENSOR_SWITCH_POS_1 = (1)
SENSOR_SWITCH_POS_2 = (2)
TLPM_AUTORANGE_VOLTAGE_OFF = (0)
TLPM_AUTORANGE_VOLTAGE_ON = (1)
TLPM_VOLTAGE_REF_OFF = (0)
TLPM_VOLTAGE_REF_ON = (1)
TLPM_ANALOG_ROUTE_PUR = (0)
TLPM_ANALOG_ROUTE_CBA = (1)
TLPM_ANALOG_ROUTE_CMA = (2)
TLPM_ANALOG_ROUTE_GEN = (3)
TLPM_IODIR_INP = (VI_OFF)
TLPM_IODIR_OUTP = (VI_ON)
TLPM_IOLVL_LOW = (VI_OFF)
TLPM_IOLVL_HIGH = (VI_ON)
DIGITAL_IO_CONFIG_INPUT = (0)
DIGITAL_IO_CONFIG_OUTPUT = (1)
DIGITAL_IO_CONFIG_INPUT_ALT = (2)
DIGITAL_IO_CONFIG_OUTPUT_ALT = (3)
I2C_OPER_INTER = (0)
I2C_OPER_SLOW = (1)
I2C_OPER_FAST = (2)
FAN_OPER_OFF = (0)
FAN_OPER_FULL = (1)
FAN_OPER_OPEN_LOOP = (2)
FAN_OPER_CLOSED_LOOP = (3)
FAN_OPER_TEMPER_CTRL = (4)
FAN_TEMPER_SRC_HEAD = (0)
FAN_TEMPER_SRC_EXT_NTC = (1)
SENSOR_TYPE_NONE = 0x0  # No sensor. This value is used to mark sensor data for 'no sensor connected'.
SENSOR_TYPE_PD_SINGLE = 0x1  # Single photodiode sensor. Only one ipd input active at the same time.
SENSOR_TYPE_THERMO = 0x2  # Thermopile sensor
SENSOR_TYPE_PYRO = 0x3  # Pyroelectric sensor
SENSOR_TYPE_4Q = 0x4  # 4Q Sensor
SENSOR_SUBTYPE_NONE = 0x0  # No sensor. This value is used to mark RAM data structure for 'no sensor connected'. Do not write this value to the EEPROM.
SENSOR_SUBTYPE_PD_ADAPTER = 0x01  # Photodiode adapter (no temperature sensor)
SENSOR_SUBTYPE_PD_SINGLE_STD = 0x02  # Standard single photodiode sensor (no temperature sensor)
SENSOR_SUBTYPE_PD_SINGLE_FSR = 0x03  # One single photodiode. Filter position set by a slide on the sensor selects responsivity data set to use. (no temperature sensor)
SENSOR_SUBTYPE_PD_SINGLE_STD_T = 0x12  # Standard single photodiode sensor (with temperature sensor)
SENSOR_SUBTYPE_THERMO_ADAPTER = 0x01  # Thermopile adapter (no temperature sensor)
SENSOR_SUBTYPE_THERMO_STD = 0x02  # Standard thermopile sensor (no temperature sensor)
SENSOR_SUBTYPE_THERMO_STD_T = 0x12  # Standard thermopile sensor (with temperature sensor)
SENSOR_SUBTYPE_PYRO_ADAPTER = 0x01  # Pyroelectric adapter (no temperature sensor)
SENSOR_SUBTYPE_PYRO_STD = 0x02  # Standard pyroelectric sensor (no temperature sensor)
SENSOR_SUBTYPE_PYRO_STD_T = 0x12  # Standard pyroelectric sensor (with temperature sensor)
TLPM_SENS_FLAG_IS_POWER = 0x0001  # Power sensor
TLPM_SENS_FLAG_IS_ENERGY = 0x0002  # Energy sensor
TLPM_SENS_FLAG_IS_RESP_SET = 0x0010  # Responsivity settable
TLPM_SENS_FLAG_IS_WAVEL_SET = 0x0020  # Wavelength settable
TLPM_SENS_FLAG_IS_TAU_SET = 0x0040  # Time constant tau settable
TLPM_SENS_FLAG_HAS_TEMP = 0x0100  # Temperature sensor included

class TLPMX:

	def __init__(self, resourceName = None, IDQuery = False, resetDevice = False):
		"""
		This function initializes the instrument driver session and performs the following initialization actions:
		
		(1) Opens a session to the Default Resource Manager resource and a session to the specified device using the Resource Name.
		(2) Performs an identification query on the instrument.
		(3) Resets the instrument to a known state.
		(4) Sends initialization commands to the instrument.
		(5) Returns an instrument handle which is used to distinguish between different sessions of this instrument driver.
		
		Notes:
		(1) Each time this function is invoked a unique session is opened.  
		
		Args:
			resourceName (create_string_buffer)
			IDQuery (c_bool):This parameter specifies whether an identification query is performed during the initialization process.
			
			VI_TRUE  (1): Do query (default).
			VI_FALSE (0): Skip query.
			
			
			resetDevice (c_bool):This parameter specifies whether the instrument is reset during the initialization process.
			
			VI_TRUE  (1) - instrument is reset (default)
			VI_FALSE (0) - no reset 
			
			
		"""
		if sizeof(c_voidp) == 4:
			dll_name = "TLPMX_32.dll"
			dllabspath = os.path.dirname(os.path.abspath(__file__)) + os.path.sep + dll_name
			self.dll = cdll.LoadLibrary(dllabspath)
		else:
			dll_name = "TLPMX_64.dll"
			dllabspath = os.path.dirname(os.path.abspath(__file__)) + os.path.sep + dll_name
			self.dll = cdll.LoadLibrary(dllabspath)

		self.devSession = c_long()
		self.devSession.value = 0
		if resourceName!= None:
			pInvokeResult = self.dll.TLPMX_init(resourceName, IDQuery, resetDevice, byref(self.devSession))
			self.__testForError(pInvokeResult)


	def __testForError(self, status):
		if status < 0:
			self.__throwError(status)
		return status

	def __throwError(self, code):
		msg = create_string_buffer(1024)
		self.dll.TLPMX_errorMessage(self.devSession, c_int(code), msg)
		raise NameError(c_char_p(msg.raw).value)

	def open(self, resourceName, IDQuery, resetDevice):
		"""
		This function initializes the instrument driver session and performs the following initialization actions:
		
		(1) Opens a session to the Default Resource Manager resource and a session to the specified device using the Resource Name.
		(2) Performs an identification query on the instrument.
		(3) Resets the instrument to a known state.
		(4) Sends initialization commands to the instrument.
		(5) Returns an instrument handle which is used to distinguish between different sessions of this instrument driver.
		
		Notes:
		(1) Each time this function is invoked a unique session is opened.  
		
		Args:
			resourceName (create_string_buffer)
			IDQuery (c_bool):This parameter specifies whether an identification query is performed during the initialization process.
			
			VI_TRUE  (1): Do query (default).
			VI_FALSE (0): Skip query.
			
			
			resetDevice (c_bool):This parameter specifies whether the instrument is reset during the initialization process.
			
			VI_TRUE  (1) - instrument is reset (default)
			VI_FALSE (0) - no reset 
			
			
		Returns:
			int: The return value, 0 is for success
		"""
		self.dll.TLPMX_close(self.devSession)
		self.devSession.value = 0
		pInvokeResult = self.dll.TLPMX_init(resourceName, IDQuery, resetDevice, byref(self.devSession))
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def close(self):
		"""
		This function closes the instrument driver session.
		
		Note: The instrument must be reinitialized to use it again.
		
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_close(self.devSession)
		return pInvokeResult

	def findRsrc(self, resourceCount):
		"""
		This function finds all driver compatible devices attached to the PC and returns the number of found devices.
		
		Note:
		(1) The function additionally stores information like system name about the found resources internally. This information can be retrieved with further functions from the class, e.g. <Get Resource Description> and <Get Resource Information>.
		
		
		Args:
			resourceCount(c_uint32 use with byref) : The number of connected devices that are supported by this driver.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_findRsrc(self.devSession, resourceCount)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getRsrcName(self, index, resourceName):
		"""
		This function gets the resource name string needed to open a device with <Initialize>.
		
		Notes:
		(1) The data provided by this function was updated at the last call of <Find Resources>.
		
		Args:
			index(c_uint32) : This parameter accepts the index of the device to get the resource descriptor from.
			
			Notes: 
			(1) The index is zero based. The maximum index to be used here is one less than the number of devices found by the last call of <Find Resources>.
			
			resourceName(create_string_buffer(1024)) : This parameter returns the resource descriptor. Use this descriptor to specify the device in <Initialize>.
			
			Notes:
			(1) The array must contain at least TLPM_BUFFER_SIZE (256) elements ViChar[256].
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getRsrcName(self.devSession, index, resourceName)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getRsrcInfo(self, index, modelName, serialNumber, manufacturer, deviceAvailable):
		"""
		This function gets information about a connected resource.
		
		Notes:
		(1) The data provided by this function was updated at the last call of <Find Resources>.
		
		Args:
			index(c_uint32) : This parameter accepts the index of the device to get the resource descriptor from.
			
			Notes: 
			(1) The index is zero based. The maximum index to be used here is one less than the number of devices found by the last call of <Find Resources>.
			
			modelName(create_string_buffer(1024)) : This parameter returns the model name of the device.
			
			Notes:
			(1) The array must contain at least TLPM_BUFFER_SIZE (256) elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this parameter.
			(3) Serial interfaces over Bluetooth will return the interface name instead of the device model name.
			serialNumber(create_string_buffer(1024)) : This parameter returns the serial number of the device.
			
			Notes:
			(1) The array must contain at least TLPM_BUFFER_SIZE (256) elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this parameter.
			(3) The serial number is not available for serial interfaces over Bluetooth.
			manufacturer(create_string_buffer(1024)) : This parameter returns the manufacturer name of the device.
			
			Notes:
			(1) The array must contain at least TLPM_BUFFER_SIZE (256) elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this parameter.
			(3) The manufacturer name is not available for serial interfaces over Bluetooth.
			deviceAvailable(c_int16 use with byref) : Returns the information if the device is available.
			Devices that are not available are used by other applications.
			
			Notes:
			(1) You may pass VI_NULL if you do not need this parameter.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getRsrcInfo(self.devSession, index, modelName, serialNumber, manufacturer, deviceAvailable)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def writeRegister(self, reg, value):
		"""
		This function writes the content of any writable instrument register. Refer to your instrument's user's manual for more details on status structure registers.
		
		
		Args:
			reg(c_int16) : Specifies the register to be used for operation. This parameter can be any of the following constants:
			
			  TLPM_REG_SRE         (1): Service Request Enable
			  TLPM_REG_ESE         (3): Standard Event Enable
			  TLPM_REG_OPER_ENAB   (6): Operation Event Enable Register
			  TLPM_REG_OPER_PTR    (7): Operation Positive Transition
			  TLPM_REG_OPER_NTR    (8): Operation Negative Transition
			  TLPM_REG_QUES_ENAB  (11): Questionable Event Enable Reg.
			  TLPM_REG_QUES_PTR   (12): Questionable Positive Transition
			  TLPM_REG_QUES_NTR   (13): Questionable Negative Transition
			  TLPM_REG_MEAS_ENAB  (16): Measurement Event Enable Register
			  TLPM_REG_MEAS_PTR   (17): Measurement Positive Transition
			  TLPM_REG_MEAS_NTR   (18): Measurement Negative Transition
			  TLPM_REG_AUX_ENAB   (21): Auxiliary Event Enable Register
			  TLPM_REG_AUX_PTR    (22): Auxiliary Positive Transition
			  TLPM_REG_AUX_NTR    (23): Auxiliary Negative Transition 
			
			value(c_int16) : This parameter specifies the new value of the selected register.
			
			These register bits are defined:
			
			STATUS BYTE bits (see IEEE488.2-1992 §11.2)
			TLPM_STATBIT_STB_AUX        (0x01): Auxiliary summary
			TLPM_STATBIT_STB_MEAS       (0x02): Device Measurement Summary
			TLPM_STATBIT_STB_EAV        (0x04): Error available
			TLPM_STATBIT_STB_QUES       (0x08): Questionable Status Summary
			TLPM_STATBIT_STB_MAV        (0x10): Message available
			TLPM_STATBIT_STB_ESB        (0x20): Event Status Bit
			TLPM_STATBIT_STB_MSS        (0x40): Master summary status
			TLPM_STATBIT_STB_OPER       (0x80): Operation Status Summary
			
			STANDARD EVENT STATUS REGISTER bits (see IEEE488.2-1992 §11.5.1)
			TLPM_STATBIT_ESR_OPC        (0x01): Operation complete
			TLPM_STATBIT_ESR_RQC        (0x02): Request control
			TLPM_STATBIT_ESR_QYE        (0x04): Query error
			TLPM_STATBIT_ESR_DDE        (0x08): Device-Specific error
			TLPM_STATBIT_ESR_EXE        (0x10): Execution error
			TLPM_STATBIT_ESR_CME        (0x20): Command error
			TLPM_STATBIT_ESR_URQ        (0x40): User request
			TLPM_STATBIT_ESR_PON        (0x80): Power on
			
			QUESTIONABLE STATUS REGISTER bits (see SCPI 99.0 §9)
			TLPM_STATBIT_QUES_VOLT      (0x0001): Questionable voltage measurement
			TLPM_STATBIT_QUES_CURR      (0x0002): Questionable current measurement
			TLPM_STATBIT_QUES_TIME      (0x0004): Questionable time measurement
			TLPM_STATBIT_QUES_POW       (0x0008): Questionable power measurement
			TLPM_STATBIT_QUES_TEMP      (0x0010): Questionable temperature measurement
			TLPM_STATBIT_QUES_FREQ      (0x0020): Questionable frequency measurement
			TLPM_STATBIT_QUES_PHAS      (0x0040): Questionable phase measurement
			TLPM_STATBIT_QUES_MOD       (0x0080): Questionable modulation measurement
			TLPM_STATBIT_QUES_CAL       (0x0100): Questionable calibration
			TLPM_STATBIT_QUES_ENER      (0x0200): Questionable energy measurement
			TLPM_STATBIT_QUES_10        (0x0400): Reserved
			TLPM_STATBIT_QUES_11        (0x0800): Reserved
			TLPM_STATBIT_QUES_12        (0x1000): Reserved
			TLPM_STATBIT_QUES_INST      (0x2000): Instrument summary
			TLPM_STATBIT_QUES_WARN      (0x4000): Command warning
			TLPM_STATBIT_QUES_15        (0x8000): Reserved
			
			OPERATION STATUS REGISTER bits (see SCPI 99.0 §9)
			TLPM_STATBIT_OPER_CAL       (0x0001): The instrument is currently performing a calibration.
			TLPM_STATBIT_OPER_SETT      (0x0002): The instrument is waiting for signals to stabilize for measurements.
			TLPM_STATBIT_OPER_RANG      (0x0004): The instrument is currently changing its range.
			TLPM_STATBIT_OPER_SWE       (0x0008): A sweep is in progress.
			TLPM_STATBIT_OPER_MEAS      (0x0010): The instrument is actively measuring.
			TLPM_STATBIT_OPER_TRIG      (0x0020): The instrument is in a “wait for trigger” state of the trigger model.
			TLPM_STATBIT_OPER_ARM       (0x0040): The instrument is in a “wait for arm” state of the trigger model.
			TLPM_STATBIT_OPER_CORR      (0x0080): The instrument is currently performing a correction (Auto-PID tune).
			TLPM_STATBIT_OPER_SENS      (0x0100): Optical powermeter sensor connected and operable.
			TLPM_STATBIT_OPER_DATA      (0x0200): Measurement data ready for fetch.
			TLPM_STATBIT_OPER_THAC      (0x0400): Thermopile accelerator active.
			TLPM_STATBIT_OPER_11        (0x0800): Reserved
			TLPM_STATBIT_OPER_12        (0x1000): Reserved
			TLPM_STATBIT_OPER_INST      (0x2000): One of n multiple logical instruments is reporting OPERational status.
			TLPM_STATBIT_OPER_PROG      (0x4000): A user-defined programming is currently in the run state.
			TLPM_STATBIT_OPER_15        (0x8000): Reserved
			
			Thorlabs defined MEASRUEMENT STATUS REGISTER bits
			TLPM_STATBIT_MEAS_0         (0x0001): Reserved
			TLPM_STATBIT_MEAS_1         (0x0002): Reserved
			TLPM_STATBIT_MEAS_2         (0x0004): Reserved
			TLPM_STATBIT_MEAS_3         (0x0008): Reserved
			TLPM_STATBIT_MEAS_4         (0x0010): Reserved
			TLPM_STATBIT_MEAS_5         (0x0020): Reserved
			TLPM_STATBIT_MEAS_6         (0x0040): Reserved
			TLPM_STATBIT_MEAS_7         (0x0080): Reserved
			TLPM_STATBIT_MEAS_8         (0x0100): Reserved
			TLPM_STATBIT_MEAS_9         (0x0200): Reserved
			TLPM_STATBIT_MEAS_10        (0x0400): Reserved
			TLPM_STATBIT_MEAS_11        (0x0800): Reserved
			TLPM_STATBIT_MEAS_12        (0x1000): Reserved
			TLPM_STATBIT_MEAS_13        (0x2000): Reserved
			TLPM_STATBIT_MEAS_14        (0x4000): Reserved
			TLPM_STATBIT_MEAS_15        (0x8000): Reserved
			
			Thorlabs defined Auxiliary STATUS REGISTER bits
			TLPM_STATBIT_AUX_NTC        (0x0001): Auxiliary NTC temperature sensor connected.
			TLPM_STATBIT_AUX_EMM        (0x0002): External measurement module connected.
			TLPM_STATBIT_AUX_2          (0x0004): Reserved
			TLPM_STATBIT_AUX_3          (0x0008): Reserved
			TLPM_STATBIT_AUX_EXPS       (0x0010): External power supply connected
			TLPM_STATBIT_AUX_BATC       (0x0020): Battery charging
			TLPM_STATBIT_AUX_BATL       (0x0040): Battery low
			TLPM_STATBIT_AUX_IPS        (0x0080): Apple(tm) authentification supported.
			TLPM_STATBIT_AUX_IPF        (0x0100): Apple(tm) authentification failed.
			TLPM_STATBIT_AUX_9          (0x0200): Reserved
			TLPM_STATBIT_AUX_10         (0x0400): Reserved
			TLPM_STATBIT_AUX_11         (0x0800): Reserved
			TLPM_STATBIT_AUX_12         (0x1000): Reserved
			TLPM_STATBIT_AUX_13         (0x2000): Reserved
			TLPM_STATBIT_AUX_14         (0x4000): Reserved
			TLPM_STATBIT_AUX_15         (0x8000): Reserved
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_writeRegister(self.devSession, reg, value)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def readRegister(self, reg, value):
		"""
		This function reads the content of any readable instrument register. Refer to your instrument's user's manual for more details on status structure registers.
		
		
		Args:
			reg(c_int16) : Specifies the register to be used for operation. This parameter can be any of the following constants:
			
			  TLPM_REG_STB         (0): Status Byte Register
			  TLPM_REG_SRE         (1): Service Request Enable
			  TLPM_REG_ESB         (2): Standard Event Status Register
			  TLPM_REG_ESE         (3): Standard Event Enable
			  TLPM_REG_OPER_COND   (4): Operation Condition Register
			  TLPM_REG_OPER_EVENT  (5): Operation Event Register
			  TLPM_REG_OPER_ENAB   (6): Operation Event Enable Register
			  TLPM_REG_OPER_PTR    (7): Operation Positive Transition
			  TLPM_REG_OPER_NTR    (8): Operation Negative Transition
			  TLPM_REG_QUES_COND   (9): Questionable Condition Register
			  TLPM_REG_QUES_EVENT (10): Questionable Event Register
			  TLPM_REG_QUES_ENAB  (11): Questionable Event Enable Reg.
			  TLPM_REG_QUES_PTR   (12): Questionable Positive Transition
			  TLPM_REG_QUES_NTR   (13): Questionable Negative Transition
			  TLPM_REG_MEAS_COND  (14): Measurement Condition Register
			  TLPM_REG_MEAS_EVENT (15): Measurement Event Register
			  TLPM_REG_MEAS_ENAB  (16): Measurement Event Enable Register
			  TLPM_REG_MEAS_PTR   (17): Measurement Positive Transition
			  TLPM_REG_MEAS_NTR   (18): Measurement Negative Transition
			  TLPM_REG_AUX_COND   (19): Auxiliary Condition Register
			  TLPM_REG_AUX_EVENT  (20): Auxiliary Event Register
			  TLPM_REG_AUX_ENAB   (21): Auxiliary Event Enable Register
			  TLPM_REG_AUX_PTR    (22): Auxiliary Positive Transition
			  TLPM_REG_AUX_NTR    (23): Auxiliary Negative Transition 
			
			value(c_int16 use with byref) : This parameter returns the value of the selected register.
			
			These register bits are defined:
			
			STATUS BYTE bits (see IEEE488.2-1992 §11.2)
			TLPM_STATBIT_STB_AUX        (0x01): Auxiliary summary
			TLPM_STATBIT_STB_MEAS       (0x02): Device Measurement Summary
			TLPM_STATBIT_STB_EAV        (0x04): Error available
			TLPM_STATBIT_STB_QUES       (0x08): Questionable Status Summary
			TLPM_STATBIT_STB_MAV        (0x10): Message available
			TLPM_STATBIT_STB_ESB        (0x20): Event Status Bit
			TLPM_STATBIT_STB_MSS        (0x40): Master summary status
			TLPM_STATBIT_STB_OPER       (0x80): Operation Status Summary
			
			STANDARD EVENT STATUS REGISTER bits (see IEEE488.2-1992 §11.5.1)
			TLPM_STATBIT_ESR_OPC        (0x01): Operation complete
			TLPM_STATBIT_ESR_RQC        (0x02): Request control
			TLPM_STATBIT_ESR_QYE        (0x04): Query error
			TLPM_STATBIT_ESR_DDE        (0x08): Device-Specific error
			TLPM_STATBIT_ESR_EXE        (0x10): Execution error
			TLPM_STATBIT_ESR_CME        (0x20): Command error
			TLPM_STATBIT_ESR_URQ        (0x40): User request
			TLPM_STATBIT_ESR_PON        (0x80): Power on
			
			QUESTIONABLE STATUS REGISTER bits (see SCPI 99.0 §9)
			TLPM_STATBIT_QUES_VOLT      (0x0001): Questionable voltage measurement
			TLPM_STATBIT_QUES_CURR      (0x0002): Questionable current measurement
			TLPM_STATBIT_QUES_TIME      (0x0004): Questionable time measurement
			TLPM_STATBIT_QUES_POW       (0x0008): Questionable power measurement
			TLPM_STATBIT_QUES_TEMP      (0x0010): Questionable temperature measurement
			TLPM_STATBIT_QUES_FREQ      (0x0020): Questionable frequency measurement
			TLPM_STATBIT_QUES_PHAS      (0x0040): Questionable phase measurement
			TLPM_STATBIT_QUES_MOD       (0x0080): Questionable modulation measurement
			TLPM_STATBIT_QUES_CAL       (0x0100): Questionable calibration
			TLPM_STATBIT_QUES_ENER      (0x0200): Questionable energy measurement
			TLPM_STATBIT_QUES_10        (0x0400): Reserved
			TLPM_STATBIT_QUES_11        (0x0800): Reserved
			TLPM_STATBIT_QUES_12        (0x1000): Reserved
			TLPM_STATBIT_QUES_INST      (0x2000): Instrument summary
			TLPM_STATBIT_QUES_WARN      (0x4000): Command warning
			TLPM_STATBIT_QUES_15        (0x8000): Reserved
			
			OPERATION STATUS REGISTER bits (see SCPI 99.0 §9)
			TLPM_STATBIT_OPER_CAL       (0x0001): The instrument is currently performing a calibration.
			TLPM_STATBIT_OPER_SETT      (0x0002): The instrument is waiting for signals to stabilize for measurements.
			TLPM_STATBIT_OPER_RANG      (0x0004): The instrument is currently changing its range.
			TLPM_STATBIT_OPER_SWE       (0x0008): A sweep is in progress.
			TLPM_STATBIT_OPER_MEAS      (0x0010): The instrument is actively measuring.
			TLPM_STATBIT_OPER_TRIG      (0x0020): The instrument is in a “wait for trigger” state of the trigger model.
			TLPM_STATBIT_OPER_ARM       (0x0040): The instrument is in a “wait for arm” state of the trigger model.
			TLPM_STATBIT_OPER_CORR      (0x0080): The instrument is currently performing a correction (Auto-PID tune).
			TLPM_STATBIT_OPER_SENS      (0x0100): Optical powermeter sensor connected and operable.
			TLPM_STATBIT_OPER_DATA      (0x0200): Measurement data ready for fetch.
			TLPM_STATBIT_OPER_THAC      (0x0400): Thermopile accelerator active.
			TLPM_STATBIT_OPER_11        (0x0800): Reserved
			TLPM_STATBIT_OPER_12        (0x1000): Reserved
			TLPM_STATBIT_OPER_INST      (0x2000): One of n multiple logical instruments is reporting OPERational status.
			TLPM_STATBIT_OPER_PROG      (0x4000): A user-defined programming is currently in the run state.
			TLPM_STATBIT_OPER_15        (0x8000): Reserved
			
			Thorlabs defined MEASRUEMENT STATUS REGISTER bits
			TLPM_STATBIT_MEAS_0         (0x0001): Reserved
			TLPM_STATBIT_MEAS_1         (0x0002): Reserved
			TLPM_STATBIT_MEAS_2         (0x0004): Reserved
			TLPM_STATBIT_MEAS_3         (0x0008): Reserved
			TLPM_STATBIT_MEAS_4         (0x0010): Reserved
			TLPM_STATBIT_MEAS_5         (0x0020): Reserved
			TLPM_STATBIT_MEAS_6         (0x0040): Reserved
			TLPM_STATBIT_MEAS_7         (0x0080): Reserved
			TLPM_STATBIT_MEAS_8         (0x0100): Reserved
			TLPM_STATBIT_MEAS_9         (0x0200): Reserved
			TLPM_STATBIT_MEAS_10        (0x0400): Reserved
			TLPM_STATBIT_MEAS_11        (0x0800): Reserved
			TLPM_STATBIT_MEAS_12        (0x1000): Reserved
			TLPM_STATBIT_MEAS_13        (0x2000): Reserved
			TLPM_STATBIT_MEAS_14        (0x4000): Reserved
			TLPM_STATBIT_MEAS_15        (0x8000): Reserved
			
			Thorlabs defined Auxiliary STATUS REGISTER bits
			TLPM_STATBIT_AUX_NTC        (0x0001): Auxiliary NTC temperature sensor connected.
			TLPM_STATBIT_AUX_EMM        (0x0002): External measurement module connected.
			TLPM_STATBIT_AUX_2          (0x0004): Reserved
			TLPM_STATBIT_AUX_3          (0x0008): Reserved
			TLPM_STATBIT_AUX_EXPS       (0x0010): External power supply connected
			TLPM_STATBIT_AUX_BATC       (0x0020): Battery charging
			TLPM_STATBIT_AUX_BATL       (0x0040): Battery low
			TLPM_STATBIT_AUX_IPS        (0x0080): Apple(tm) authentification supported.
			TLPM_STATBIT_AUX_IPF        (0x0100): Apple(tm) authentification failed.
			TLPM_STATBIT_AUX_9          (0x0200): Reserved
			TLPM_STATBIT_AUX_10         (0x0400): Reserved
			TLPM_STATBIT_AUX_11         (0x0800): Reserved
			TLPM_STATBIT_AUX_12         (0x1000): Reserved
			TLPM_STATBIT_AUX_13         (0x2000): Reserved
			TLPM_STATBIT_AUX_14         (0x4000): Reserved
			TLPM_STATBIT_AUX_15         (0x8000): Reserved
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_readRegister(self.devSession, reg, value)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def presetRegister(self):
		"""
		This function presets all status registers to default.
		
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_presetRegister(self.devSession)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def sendNTPRequest(self, timeMode, timeZone, IPAddress):
		"""
		This function sets the system date and time of the powermeter.
		
		Notes:
		(1) Date and time are displayed on instruments screen and are used as timestamp for data saved to memory card.
		(2) The function is only available on PM100D, PM200, PM400.
		
		Args:
			timeMode(c_int16)
			timeZone(c_int16)
			IPAddress(create_string_buffer(1024))
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_sendNTPRequest(self.devSession, timeMode, timeZone, IPAddress)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setTime(self, year, month, day, hour, minute, second):
		"""
		This function sets the system date and time of the powermeter.
		
		Notes:
		(1) Date and time are displayed on instruments screen and are used as timestamp for data saved to memory card.
		(2) The function is only available on PM100D, PM200, PM400.
		
		Args:
			year(c_int16) : This parameter specifies the actual year in the format yyyy e.g. 2009.
			month(c_int16) : This parameter specifies the actual month in the format mm e.g. 01.
			day(c_int16) : This parameter specifies the actual day in the format dd e.g. 15.
			
			hour(c_int16) : This parameter specifies the actual hour in the format hh e.g. 14.
			
			minute(c_int16) : This parameter specifies the actual minute in the format mm e.g. 43.
			
			second(c_int16) : This parameter specifies the actual second in the format ss e.g. 50.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setTime(self.devSession, year, month, day, hour, minute, second)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getTime(self, year, month, day, hour, minute, second):
		"""
		This function returns the system date and time of the powermeter.
		
		Notes:
		(1) Date and time are displayed on instruments screen and are used as timestamp for data saved to memory card.
		(2) The function is only available on PM100D, PM200, PM400.
		
		Args:
			year(c_int16 use with byref) : This parameter specifies the actual year in the format yyyy.
			month(c_int16 use with byref) : This parameter specifies the actual month in the format mm.
			day(c_int16 use with byref) : This parameter specifies the actual day in the format dd.
			hour(c_int16 use with byref) : This parameter specifies the actual hour in the format hh.
			minute(c_int16 use with byref) : This parameter specifies the actual minute in the format mm.
			second(c_int16 use with byref) : This parameter specifies the actual second in the format ss.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getTime(self.devSession, year, month, day, hour, minute, second)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setSummertime(self, timeMode):
		"""
		This function sets the clock to summertime.
		
		Notes:
		(1) Date and time are displayed on instruments screen and are used as timestamp for data saved to memory card.
		(2) The function is only available on PM5020
		
		Args:
			timeMode(c_int16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setSummertime(self.devSession, timeMode)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getSummertime(self, timeMode):
		"""
		This function returns if the device uses the summertime.
		
		Notes:
		(1) Date and time are displayed on instruments screen and are used as timestamp for data saved to memory card.
		(2) The function is only available on PM5020.
		
		Args:
			timeMode(c_int16 use with byref)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getSummertime(self.devSession, timeMode)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setLineFrequency(self, lineFrequency):
		"""
		This function selects the line frequency.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200.
		
		
		Args:
			lineFrequency(c_int16) : This parameter specifies the line frequency.
			
			Accepted values:
			  TLPM_LINE_FREQ_50 (50): 50Hz
			  TLPM_LINE_FREQ_60 (60): 60Hz
			
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setLineFrequency(self.devSession, lineFrequency)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getLineFrequency(self, lineFrequency):
		"""
		This function returns the selected line frequency.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200.
		
		
		Args:
			lineFrequency(c_int16 use with byref) : This parameter returns the selected line frequency in Hz.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getLineFrequency(self.devSession, lineFrequency)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getBatteryVoltage(self, voltage):
		"""
		This function is used to obtain the battery voltage readings from the instrument.
		
		Remark:
		(1) This function is only supported with the PM160 and PM160T.
		(2) This function obtains the latest battery voltage measurement result.
		(3) With the USB cable connected this function will obtain the loading voltage. Only with USB cable disconnected (Bluetooth connection) the actual battery voltage can be read. 
		
		Args:
			voltage(c_double use with byref) : This parameter returns the battery voltage in volts [V].
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getBatteryVoltage(self.devSession, voltage)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDispBrightness(self, val):
		"""
		This function sets the display brightness.
		
		Args:
			val(c_double) : This parameter specifies the display brightness.
			
			Range   : 0.0 .. 1.0
			Default : 1.0
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDispBrightness(self.devSession, val)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDispBrightness(self, pVal):
		"""
		This function returns the display brightness.
		
		
		Args:
			pVal(c_double use with byref) : This parameter returns the display brightness. Value range is 0.0 to 1.0.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDispBrightness(self.devSession, pVal)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDispContrast(self, val):
		"""
		This function sets the display contrast of a PM100D.
		
		Note: The function is available on PM100D only.
		
		Args:
			val(c_double) : This parameter specifies the display contrast.
			
			Range   : 0.0 .. 1.0
			Default : 0.5
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDispContrast(self.devSession, val)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDispContrast(self, pVal):
		"""
		This function returns the display contrast of a PM100D.
		
		Note: This function is available on PM100D only
		
		Args:
			pVal(c_double use with byref) : This parameter returns the display contrast (0..1).
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDispContrast(self.devSession, pVal)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def beep(self):
		"""
		Plays a beep sound.
		
		Note: Only supported by PM5020.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_beep(self.devSession)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setInputFilterState(self, inputFilterState, channel):
		"""
		This function sets the instrument's photodiode input filter state.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			inputFilterState(c_int16) : This parameter specifies the input filter mode.
			
			Acceptable values:
			  TLPM_INPUT_FILTER_STATE_OFF (0) input filter off
			  TLPM_INPUT_FILTER_STATE_ON  (1) input filter on
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setInputFilterState(self.devSession, inputFilterState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getInputFilterState(self, inputFilterState, channel):
		"""
		This function returns the instrument's photodiode input filter state.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			inputFilterState(c_int16 use with byref) : This parameter returns the input filter state.
			
			Return values:
			  TLPM_INPUT_FILTER_STATE_OFF (0) input filter off
			  TLPM_INPUT_FILTER_STATE_ON  (1) input filter on
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getInputFilterState(self.devSession, inputFilterState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAccelState(self, accelState, channel):
		"""
		This function sets the thermopile acceleration state.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200.
		
		
		Args:
			accelState(c_int16) : This parameter specifies the thermopile acceleration mode.
			
			Acceptable values:
			  TLPM_ACCELERATION_STATE_OFF (0): thermopile acceleration off
			  TLPM_ACCELERATION_STATE_ON  (1): thermopile acceleration on
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAccelState(self.devSession, accelState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAccelState(self, accelState, channel):
		"""
		This function returns the thermopile acceleration state.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			accelState(c_int16 use with byref) : This parameter returns the thermopile acceleration mode.
			
			Return values:
			  TLPM_ACCELERATION_STATE_OFF (0): thermopile acceleration off
			  TLPM_ACCELERATION_STATE_ON  (1): thermopile acceleration on
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAccelState(self.devSession, accelState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAccelMode(self, accelMode, channel):
		"""
		This function sets the thermopile acceleration auto mode.
		
		While thermopile acceleration improves displaying changing measurement values it unfortunately adds extra noise which can become noticeable on constant values measurements. With acceleration mode set to AUTO the instrument enables the acceleration circuitry after big measurement value changes for five times of "Tau". See also functions <Set Thermopile Accelerator Tau> and <Set Thermopile Accelerator State>.
		
		With calling <Set Thermopile Accelerator State> the accelerator mode will always be reset to MANUAL.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			accelMode(c_int16) : This parameter specifies the thermopile acceleration mode.
			
			Acceptable values:
			  TLPM_ACCELERATION_MANUAL (0): auto acceleration off
			  TLPM_ACCELERATION_AUTO   (1): auto acceleration on
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAccelMode(self.devSession, accelMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAccelMode(self, accelMode, channel):
		"""
		This function returns the thermopile acceleration mode.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			accelMode(c_int16 use with byref) : This parameter returns the thermopile acceleration mode.
			
			Return values:
			  TLPM_ACCELERATION_MANUAL (0): auto acceleration off
			  TLPM_ACCELERATION_AUTO   (1): auto acceleration on
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAccelMode(self.devSession, accelMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAccelTau(self, accelTau, channel):
		"""
		This function sets the thermopile acceleration time constant in seconds [s].
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			accelTau(c_double) : This parameter specifies the thermopile acceleration time constant in seconds [s].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAccelTau(self.devSession, accelTau, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAccelTau(self, attribute, accelTau, channel):
		"""
		This function returns the thermopile acceleration time constant in seconds [s].
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			accelTau(c_double use with byref) : This parameter returns the thermopile acceleration time constant in seconds [s].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAccelTau(self.devSession, attribute, accelTau, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setInputAdapterType(self, type, channel):
		"""
		This function sets the sensor type to assume for custom sensors without calibration data memory connected to the instrument.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			type(c_int16) : This parameter specifies the custom sensor type.
			
			Acceptable values:
			 SENSOR_TYPE_PD_SINGLE (1): Photodiode sensor
			 SENSOR_TYPE_THERMO    (2): Thermopile sensor
			 SENSOR_TYPE_PYRO      (3): Pyroelectric sensor
			
			Value SENSOR_TYPE_PYRO is only available for energy meter instruments.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setInputAdapterType(self.devSession, type, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getInputAdapterType(self, type, channel):
		"""
		This function returns the assumed sensor type for custom sensors without calibration data memory connected to the instrument.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			type(c_int16 use with byref) : This parameter returns the custom sensor type.
			
			Remark:
			The meanings of the obtained sensor type are:
			
			Sensor Types:
			 SENSOR_TYPE_PD_SINGLE (1): Photodiode sensor
			 SENSOR_TYPE_THERMO    (2): Thermopile sensor
			 SENSOR_TYPE_PYRO      (3): Pyroelectric sensor
			 SENSOR_TYPE_4Q        (4): 4 Quadrant sensor
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getInputAdapterType(self.devSession, type, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAvgTime(self, avgTime, channel):
		"""
		This function sets the average time for measurement value generation.
		
		Args:
			avgTime(c_double) : This parameter specifies the average time in seconds.
			
			The value will be rounded to the closest multiple of the device's internal sampling rate.
			
			Remark: 
			To get an measurement value from the device the timeout in your application has to be longer than the average time.
			
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAvgTime(self.devSession, avgTime, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAvgTime(self, attribute, avgTime, channel):
		"""
		This function returns the average time for measurement value generation.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			avgTime(c_double use with byref) : This parameter returns the specified average time in seconds.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAvgTime(self.devSession, attribute, avgTime, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAvgCnt(self, averageCount, channel):
		"""
		This function sets the average count for measurement value generation.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		(2) The function is deprecated and kept for legacy reasons. Its recommended to use TLPM_setAvgTime() instead.
		
		
		Args:
			averageCount(c_int16) : This parameter specifies the average count.
			The default value is 1.
			
			Remark: 
			Depending on the powermeter model internal there are taken up to 3000 measurements per second.
			In this example   Average Time = Average Count / 3000 [s].
			To get an measurement value from the device the timeout in your application has to be longer than the calculated average time.
			
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAvgCnt(self.devSession, averageCount, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAvgCnt(self, averageCount, channel):
		"""
		This function returns the average count for measurement value generation.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		(2) The function is deprecated and kept for legacy reasons. Its recommended to use TLPM_getAvgTime() instead.
		
		
		Args:
			averageCount(c_int16 use with byref) : This parameter returns the actual Average Count.
			
			Remark: 
			Depending on the powermeter model internal there are taken up to 3000 measurements per second.
			In this example   Average Time = Average Count / 3000 [s].
			To get an measurement value from the device the timeout in your application has to be longer than the calculated average time.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAvgCnt(self.devSession, averageCount, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAttenuation(self, attenuation, channel):
		"""
		This function sets the input attenuation.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			attenuation(c_double) : This parameter specifies the input attenuation in dezibel [dB].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAttenuation(self.devSession, attenuation, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAttenuation(self, attribute, attenuation, channel):
		"""
		This function returns the input attenuation.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			attenuation(c_double use with byref) : This parameter returns the specified input attenuation in dezibel [dB].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAttenuation(self.devSession, attribute, attenuation, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def startDarkAdjust(self, channel):
		"""
		This function starts the dark current/zero offset adjustment procedure.
		
		Remark: 
		(1) You have to darken the input before starting dark/zero adjustment.
		(2) You can get the state of dark/zero adjustment with <Get Dark Adjustment State>
		(3) You can stop dark/zero adjustment with <Cancel Dark Adjustment>
		(4) You get the dark/zero value with <Get Dark Offset>
		(5) Energy sensors do not support this function
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_startDarkAdjust(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def cancelDarkAdjust(self, channel):
		"""
		This function cancels a running dark current/zero offset adjustment procedure.
		
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_cancelDarkAdjust(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDarkAdjustState(self, state, channel):
		"""
		This function returns the state of a dark current/zero offset adjustment procedure previously initiated by <Start Dark Adjust>.
		
		
		Args:
			state(c_int16 use with byref) : This parameter returns the dark adjustment state.
			
			Possible return values are:
			TLPM_STAT_DARK_ADJUST_FINISHED (0) : no dark adjustment running
			TLPM_STAT_DARK_ADJUST_RUNNING  (1) : dark adjustment is running
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDarkAdjustState(self.devSession, state, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDarkOffset(self, darkOffset, channel):
		"""
		This function returns the dark/zero offset.
		
		The function is not supported with energy sensors.
		
		Args:
			darkOffset(c_double) : This parameter returns the dark/zero offset.
			
			The unit of the returned offset value depends on the sensor type. Photodiodes return the dark offset in ampere [A]. Thermal sensors return the dark offset in volt [V].
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDarkOffset(self.devSession, darkOffset, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDarkOffset(self, darkOffset, channel):
		"""
		This function returns the dark/zero offset.
		
		The function is not supported with energy sensors.
		
		Args:
			darkOffset(c_double use with byref) : This parameter returns the dark/zero offset.
			
			The unit of the returned offset value depends on the sensor type. Photodiodes return the dark offset in ampere [A]. Thermal sensors return the dark offset in volt [V].
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDarkOffset(self.devSession, darkOffset, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setBeamDia(self, beamDiameter, channel):
		"""
		This function sets the users beam diameter in millimeter [mm].
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		(2) Beam diameter set value is used for calculating power and energy density.
		
		
		Args:
			beamDiameter(c_double) : This parameter specifies the users beam diameter in millimeter [mm].
			
			Remark:
			Beam diameter set value is used for calculating power and energy density.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setBeamDia(self.devSession, beamDiameter, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getBeamDia(self, attribute, beamDiameter, channel):
		"""
		This function returns the users beam diameter in millimeter [mm].
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM101, PM102, PM400.
		(2) Beam diameter set value is used for calculating power and energy density.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			
			beamDiameter(c_double use with byref) : This parameter returns the specified beam diameter in millimeter [mm].
			
			Remark:
			Beam diameter set value is used for calculating power and energy density.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getBeamDia(self.devSession, attribute, beamDiameter, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setWavelength(self, wavelength, channel):
		"""
		This function sets the users wavelength in nanometer [nm].
		
		Remark:
		Wavelength set value is used for calculating power.
		
		
		Args:
			wavelength(c_double) : This parameter specifies the users wavelength in nanometer [nm].
			
			Remark:
			Wavelength set value is used for calculating power.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setWavelength(self.devSession, wavelength, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getWavelength(self, attribute, wavelength, channel):
		"""
		This function returns the users wavelength in nanometer [nm].
		
		Remark:
		Wavelength set value is used for calculating power.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			
			wavelength(c_double use with byref) : This parameter returns the specified wavelength in nanometer [nm].
			
			Remark:
			Wavelength set value is used for calculating power.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getWavelength(self.devSession, attribute, wavelength, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPhotodiodeResponsivity(self, response, channel):
		"""
		This function sets the photodiode responsivity in ampere per watt [A/W].
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			response(c_double) : This parameter specifies the photodiode responsivity in ampere per watt [A/W].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPhotodiodeResponsivity(self.devSession, response, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPhotodiodeResponsivity(self, attribute, responsivity, channel):
		"""
		This function returns the photodiode responsivity in ampere per watt [A/W].
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			responsivity(c_double use with byref) : This parameter returns the specified photodiode responsivity in ampere per watt [A/W].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPhotodiodeResponsivity(self.devSession, attribute, responsivity, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setThermopileResponsivity(self, response, channel):
		"""
		This function sets the thermopile responsivity in volt per watt [V/W]
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			response(c_double) : This parameter specifies the thermopile responsivity in volt per watt [V/W]
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setThermopileResponsivity(self.devSession, response, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getThermopileResponsivity(self, attribute, responsivity, channel):
		"""
		This function returns the thermopile responsivity in volt per watt [V/W]
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			responsivity(c_double use with byref) : This parameter returns the specified thermopile responsivity in volt per watt [V/W]
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getThermopileResponsivity(self.devSession, attribute, responsivity, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPyrosensorResponsivity(self, response, channel):
		"""
		This function sets the pyrosensor responsivity in volt per joule [V/J]
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			response(c_double) : This parameter specifies the pyrosensor responsivity in volt per joule [V/J]
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPyrosensorResponsivity(self.devSession, response, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPyrosensorResponsivity(self, attribute, responsivity, channel):
		"""
		This function returns the pyrosensor responsivity in volt per joule [V/J]
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			responsivity(c_double use with byref) : This parameter returns the specified pyrosensor responsivity in volt per joule [V/J]
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPyrosensorResponsivity(self.devSession, attribute, responsivity, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setCurrentAutoRange(self, currentAutorangeMode, channel):
		"""
		This function sets the current auto range mode.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			currentAutorangeMode(c_int16) : This parameter specifies the current auto range mode.
			
			Acceptable values:
			  TLPM_AUTORANGE_CURRENT_OFF (0): current auto range disabled
			  TLPM_AUTORANGE_CURRENT_ON  (1): current auto range enabled
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setCurrentAutoRange(self.devSession, currentAutorangeMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getCurrentAutorange(self, currentAutorangeMode, channel):
		"""
		This function returns the current auto range mode.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			currentAutorangeMode(c_int16 use with byref) : This parameter returns the current auto range mode.
			
			Return values:
			  TLPM_AUTORANGE_CURRENT_OFF (0): current auto range disabled
			  TLPM_AUTORANGE_CURRENT_ON  (1): current auto range enabled
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getCurrentAutorange(self.devSession, currentAutorangeMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setCurrentRange(self, current_to_Measure, channel):
		"""
		This function sets the sensor's current range.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			current_to_Measure(c_double) : This parameter specifies the current value to be measured in ampere [A].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setCurrentRange(self.devSession, current_to_Measure, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getCurrentRange(self, attribute, currentValue, channel):
		"""
		This function returns the actual current range value.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			
			currentValue(c_double use with byref) : This parameter returns the specified current range value in ampere [A].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getCurrentRange(self.devSession, attribute, currentValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getCurrentRanges(self, currentValues, rangeCount, channel):
		"""
		This function returns the actual voltage range value.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			currentValues( (c_double * arrayLength)()) : This parameter returns the specified voltage range value in volts [V].
			
			rangeCount(c_uint16 use with byref)
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getCurrentRanges(self.devSession, currentValues, rangeCount, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setCurrentRangeSearch(self, channel):
		"""
		This function returns the actual voltage range value.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setCurrentRangeSearch(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setCurrentRef(self, currentReferenceValue, channel):
		"""
		This function sets the current reference value.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			currentReferenceValue(c_double) : This parameter specifies the current reference value in amperes [A].
			
			Remark:
			This value is used for calculating differences between the actual current value and this current reference value if Current Reference State is ON.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setCurrentRef(self.devSession, currentReferenceValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getCurrentRef(self, attribute, currentReferenceValue, channel):
		"""
		This function returns the current reference value.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			currentReferenceValue(c_double use with byref) : This parameter returns the specified current reference value in amperes [A].
			
			Remark:
			This value is used for calculating differences between the actual current value and this current reference value if Current Reference State is ON.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getCurrentRef(self.devSession, attribute, currentReferenceValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setCurrentRefState(self, currentReferenceState, channel):
		"""
		This function sets the current reference state.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			currentReferenceState(c_int16) : This parameter specifies the current reference state.
			
			Acceptable values:
			  TLPM_CURRENT_REF_OFF (0): Current reference disabled. Absolute measurement.
			  TLPM_CURRENT_REF_ON  (1): Current reference enabled. Relative measurement.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setCurrentRefState(self.devSession, currentReferenceState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getCurrentRefState(self, currentReferenceState, channel):
		"""
		This function returns the current reference state.
		
		Notes:
		(1) The function is only available on PM100A, PM100D, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			currentReferenceState(c_int16 use with byref) : This parameter returns the current reference state.
			
			Return values:
			  TLPM_CURRENT_REF_OFF (0): Current reference disabled. Absolute measurement.
			  TLPM_CURRENT_REF_ON  (1): Current reference enabled. Relative measurement.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getCurrentRefState(self.devSession, currentReferenceState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setEnergyRange(self, energyToMeasure, channel):
		"""
		This function sets the pyro sensor's energy range.
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			energyToMeasure(c_double) : This parameter specifies the energy value in joule [J] to be measured.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setEnergyRange(self.devSession, energyToMeasure, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getEnergyRange(self, attribute, energyValue, channel):
		"""
		This function returns the pyro sensor's energy range.
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			
			energyValue(c_double use with byref) : This parameter returns the specified pyro sensor's energy value in joule [J].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getEnergyRange(self.devSession, attribute, energyValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setEnergyRef(self, energyReferenceValue, channel):
		"""
		This function sets the pyro sensor's energy reference value
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		(2) This value is used for calculating differences between the actual energy value and this energy reference value.
		
		
		Args:
			energyReferenceValue(c_double) : This parameter specifies the pyro sensor's energy reference value in joule [J].
			
			Remark:
			This value is used for calculating differences between the actual energy value and this energy reference value if Energy Reference State is ON.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setEnergyRef(self.devSession, energyReferenceValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getEnergyRef(self, attribute, energyReferenceValue, channel):
		"""
		This function returns the specified pyro sensor's energy reference value.
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		(2) The set value is used for calculating differences between the actual energy value and this energy reference value.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			energyReferenceValue(c_double use with byref) : This parameter returns the specified pyro sensor's energy reference value in joule [J].
			
			Remark:
			The set value is used for calculating differences between the actual energy value and this energy reference value if Energy Reference State is ON.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getEnergyRef(self.devSession, attribute, energyReferenceValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setEnergyRefState(self, energyReferenceState, channel):
		"""
		This function sets the instrument's energy reference state.
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			energyReferenceState(c_int16) : This parameter specifies the energy reference state.
			
			Acceptable values:
			  TLPM_ENERGY_REF_OFF (0): Energy reference disabled. Absolute measurement.
			  TLPM_ENERGY_REF_ON  (1): Energy reference enabled. Relative measurement.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setEnergyRefState(self.devSession, energyReferenceState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getEnergyRefState(self, energyReferenceState, channel):
		"""
		This function returns the instrument's energy reference state.
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			energyReferenceState(c_int16 use with byref) : This parameter returns the energy reference state.
			
			Return values:
			  TLPM_ENERGY_REF_OFF (0): Energy reference disabled. Absolute measurement.
			  TLPM_ENERGY_REF_ON  (1): Energy reference enabled. Relative measurement.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getEnergyRefState(self.devSession, energyReferenceState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFreqRange(self, lowerFrequency, upperFrequency, channel):
		"""
		This function returns the instruments frequency measurement range.
		
		Remark:
		The frequency of the input signal is calculated over at least 0.3s. So it takes at least 0.3s to get a new frequency value from the instrument.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, and PM100USB.
		
		
		Args:
			lowerFrequency(c_double use with byref) : This parameter returns the lower instruments frequency in [Hz].
			
			upperFrequency(c_double use with byref) : This parameter returns the upper instruments frequency in [Hz].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFreqRange(self.devSession, lowerFrequency, upperFrequency, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setFreqMode(self, frequencyMode, channel):
		"""
		This function sets the instruments frequency measurement mode. Only for photodiodes.
		
		Notes:
		(1) The function is only available on PM103
		
		
		Args:
			frequencyMode(c_uint16) : This parameter returns the frequency mode.
			
			CW (0)
			PEAK (1)
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setFreqMode(self.devSession, frequencyMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFreqMode(self, frequencyMode, channel):
		"""
		This function returns the instruments frequency measurement mode. 
		
		Notes:
		(1) The function is only available on PM103
		
		
		Args:
			frequencyMode(c_uint16 use with byref) : This parameter returns the frequency mode.
			
			CW (0)
			PEAK (1)
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFreqMode(self.devSession, frequencyMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPowerAutoRange(self, powerAutorangeMode, channel):
		"""
		This function sets the power auto range mode.
		
		
		Args:
			powerAutorangeMode(c_int16) : This parameter specifies the power auto range mode.
			
			Acceptable values:
			  TLPM_AUTORANGE_POWER_OFF (0): power auto range disabled
			  TLPM_AUTORANGE_POWER_ON  (1): power auto range enabled
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPowerAutoRange(self.devSession, powerAutorangeMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPowerAutorange(self, powerAutorangeMode, channel):
		"""
		This function returns the power auto range mode.
		
		
		Args:
			powerAutorangeMode(c_int16 use with byref) : This parameter returns the power auto range mode.
			
			Return values:
			  TLPM_AUTORANGE_POWER_OFF (0): power auto range disabled
			  TLPM_AUTORANGE_POWER_ON  (0): power auto range enabled
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPowerAutorange(self.devSession, powerAutorangeMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPowerRange(self, power_to_Measure, channel):
		"""
		This function sets the sensor's power range.
		
		
		Args:
			power_to_Measure(c_double) : This parameter specifies the most positive signal level expected for the sensor input in watt [W].
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPowerRange(self.devSession, power_to_Measure, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPowerRange(self, attribute, powerValue, channel):
		"""
		This function returns the actual power range value.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			
			powerValue(c_double use with byref) : This parameter returns the specified power range value in watt [W].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPowerRange(self.devSession, attribute, powerValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPowerRef(self, powerReferenceValue, channel):
		"""
		This function sets the power reference value.
		
		
		Args:
			powerReferenceValue(c_double) : This parameter specifies the power reference value.
			
			Remark:
			(1) The power reference value has the unit specified with <Set Power Unit>.
			(2) This value is used for calculating differences between the actual power value and this power reference value if Power Reference State is ON.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPowerRef(self.devSession, powerReferenceValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPowerRef(self, attribute, powerReferenceValue, channel):
		"""
		This function returns the power reference value.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			powerReferenceValue(c_double use with byref) : This parameter returns the specified power reference value.
			
			Remark:
			(1) The power reference value has the unit specified with <Set Power Unit>.
			(2) This value is used for calculating differences between the actual power value and this power reference value if Power Reference State is ON.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPowerRef(self.devSession, attribute, powerReferenceValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPowerRefState(self, powerReferenceState, channel):
		"""
		This function sets the power reference state.
		
		
		Args:
			powerReferenceState(c_int16) : This parameter specifies the power reference state.
			
			Acceptable values:
			  TLPM_POWER_REF_OFF (0): Power reference disabled. Absolute measurement.
			  TLPM_POWER_REF_ON  (1): Power reference enabled. Relative measurement.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPowerRefState(self.devSession, powerReferenceState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPowerRefState(self, powerReferenceState, channel):
		"""
		This function returns the power reference state.
		
		
		Args:
			powerReferenceState(c_int16 use with byref) : This parameter returns the power reference state.
			
			Return values:
			  TLPM_POWER_REF_OFF (0): Power reference disabled. Absolute measurement.
			  TLPM_POWER_REF_ON  (1): Power reference enabled. Relative measurement.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPowerRefState(self.devSession, powerReferenceState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPowerUnit(self, powerUnit, channel):
		"""
		This function sets the unit of the power value.
		
		
		Args:
			powerUnit(c_int16) : This parameter specifies the unit of the pover value.
			
			Acceptable values:
			  TLPM_POWER_UNIT_WATT (0): power in Watt
			  TLPM_POWER_UNIT_DBM  (1): power in dBm
			
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPowerUnit(self.devSession, powerUnit, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPowerUnit(self, powerUnit, channel):
		"""
		This function returns the unit of the power value.
		
		
		Args:
			powerUnit(c_int16 use with byref) : This parameter returns the unit of the power value.
			
			Return values:
			  TLPM_POWER_UNIT_WATT (0): power in Watt
			  TLPM_POWER_UNIT_DBM  (1): power in dBm
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPowerUnit(self.devSession, powerUnit, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPowerCalibrationPointsInformation(self, index, serialNumber, calibrationDate, calibrationPointsCount, author, sensorPosition, channel):
		"""
		Queries the customer adjustment header like serial nr, cal date, nr of points at given index
		
		
		Args:
			index(c_uint16) : Index of the power calibration (range 1...5)
			serialNumber(create_string_buffer(1024)) : Serial Number of the sensor.
			Please provide a buffer of 256 characters.
			calibrationDate(create_string_buffer(1024)) : Last calibration date of this sensor
			Please provide a buffer of 256 characters.
			calibrationPointsCount(c_uint16 use with byref) : Number of calibration points of the power calibration with this sensor
			author(create_string_buffer(1024))
			sensorPosition(c_uint16 use with byref) : The position of the sencor switch of a Thorlabs S130C
			1 = 5mW
			2 = 500mW
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPowerCalibrationPointsInformation(self.devSession, index, serialNumber, calibrationDate, calibrationPointsCount, author, sensorPosition, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPowerCalibrationPointsState(self, index, state, channel):
		"""
		Queries the state if the power calibration of this sensor is activated.
		
		
		Args:
			index(c_uint16)
			state(c_int16 use with byref) : State if the user power calibration is activated and used for the power measurements.
			
			VI_ON: The user power calibration is used
			VI_OFF: The user power calibration is ignored in the power measurements
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPowerCalibrationPointsState(self.devSession, index, state, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPowerCalibrationPointsState(self, index, state, channel):
		"""
		This function activates/inactivates the power calibration of this sensor.
		
		
		Args:
			index(c_uint16) : Index of the power calibration (range 1...5)
			state(c_int16) : State if the user power calibration is activated and used for the power measurements.
			
			VI_ON: The user power calibration is used
			VI_OFF: The user power calibration is ignored in the power measurements
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPowerCalibrationPointsState(self.devSession, index, state, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPowerCalibrationPoints(self, index, pointCounts, wavelengths, powerCorrectionFactors, channel):
		"""
		Returns a list of wavelength and the corresponding power correction factor.
		
		
		Args:
			index(c_uint16)
			pointCounts(c_uint16) : Number of points that are submitted in the wavelength and power correction factors arrays.
			Maximum of 8 wavelength - power correction factors pairs can be calibrated for each sensor.
			wavelengths( (c_double * arrayLength)()) : Array of wavelengths in nm. Requires ascending wavelength order.
			The array must contain <points counts> entries.
			powerCorrectionFactors( (c_double * arrayLength)()) : Array of power correction factorw that correspond to the wavelength array. 
			The array must contain <points counts> entries, same as wavelenght to build wavelength - power correction factors pairs.
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPowerCalibrationPoints(self.devSession, index, pointCounts, wavelengths, powerCorrectionFactors, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPowerCalibrationPoints(self, index, pointCounts, wavelengths, powerCorrectionFactors, author, sensorPosition, channel):
		"""
		Sumbits a list of wavelength and the corresponding measured power correction factors to calibrate the power measurement.
		
		
		Args:
			index(c_uint16) : Index of the power calibration (range 1...5)
			pointCounts(c_uint16) : Number of points that are submitted in the wavelength and power correction factors arrays.
			Maximum of 8 wavelength - power correction factors  pairs can be calibrated for each sensor.
			wavelengths( (c_double * arrayLength)()) : Array of wavelengths in nm. Requires ascending wavelength order.
			The array must contain <points counts> entries.
			powerCorrectionFactors( (c_double * arrayLength)()) : Array of powers correction factors that correspond to the wavelength array. 
			The array must contain <points counts> entries, same as wavelenght to build wavelength - power correction factors  pairs.
			author(create_string_buffer(1024)) : Buffer that contains the name of the editor of the calibration.
			Name of Author limited to 19 chars + ''
			sensorPosition(c_uint16) : The position of the sencor switch of a Thorlabs S130C
			1 = 5mW
			2 = 500mW
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPowerCalibrationPoints(self.devSession, index, pointCounts, wavelengths, powerCorrectionFactors, author, sensorPosition, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def reinitSensor(self, channel):
		"""
		To use the user power calibration, the sensor has to be reconnected.
		Either manually remove and reconnect the sensor to the instrument or use this funtion.
		
		This function will wait 2 seconds until the sensor has been reinitialized.
		
		Args:
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_reinitSensor(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setVoltageAutoRange(self, voltageAutorangeMode, channel):
		"""
		This function sets the voltage auto range mode.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			voltageAutorangeMode(c_int16) : This parameter specifies the voltage auto range mode.
			
			Acceptable values:
			  TLPM_AUTORANGE_VOLTAGE_OFF (0): voltage auto range disabled
			  TLPM_AUTORANGE_VOLTAGE_ON  (1): voltage auto range enabled
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setVoltageAutoRange(self.devSession, voltageAutorangeMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getVoltageAutorange(self, voltageAutorangeMode, channel):
		"""
		This function returns the voltage auto range mode.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			voltageAutorangeMode(c_int16 use with byref) : This parameter returns the voltage auto range mode.
			
			Return values:
			  TLPM_AUTORANGE_VOLTAGE_OFF (0): voltage auto range disabled
			  TLPM_AUTORANGE_VOLTAGE_ON  (1): voltage auto range enabled
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getVoltageAutorange(self.devSession, voltageAutorangeMode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setVoltageRange(self, voltage_to_Measure, channel):
		"""
		This function sets the sensor's voltage range.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			voltage_to_Measure(c_double) : This parameter specifies the voltage value to be measured in volts [V].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setVoltageRange(self.devSession, voltage_to_Measure, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getVoltageRange(self, attribute, voltageValue, channel):
		"""
		This function returns the actual voltage range value.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			
			voltageValue(c_double use with byref) : This parameter returns the specified voltage range value in volts [V].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getVoltageRange(self.devSession, attribute, voltageValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getVoltageRanges(self, voltageValues, rangeCount, channel):
		"""
		This function returns the actual voltage range value.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			voltageValues( (c_double * arrayLength)()) : This parameter returns the specified voltage range value in volts [V].
			
			rangeCount(c_uint16 use with byref)
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getVoltageRanges(self.devSession, voltageValues, rangeCount, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setVoltageRangeSearch(self, channel):
		"""
		This function returns the actual voltage range value.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setVoltageRangeSearch(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setVoltageRef(self, voltageReferenceValue, channel):
		"""
		This function sets the voltage reference value.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			voltageReferenceValue(c_double) : This parameter specifies the voltage reference value in volts [V].
			
			Remark:
			This value is used for calculating differences between the actual voltage value and this voltage reference value if Voltage Reference State is ON.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setVoltageRef(self.devSession, voltageReferenceValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getVoltageRef(self, attribute, voltageReferenceValue, channel):
		"""
		This function returns the voltage reference value.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			voltageReferenceValue(c_double use with byref) : This parameter returns the specified voltage reference value in volts [V].
			
			Remark:
			This value is used for calculating differences between the actual voltage value and this voltage reference value if Voltage Reference State is ON.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getVoltageRef(self.devSession, attribute, voltageReferenceValue, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setVoltageRefState(self, voltageReferenceState, channel):
		"""
		This function sets the voltage reference state.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			voltageReferenceState(c_int16) : This parameter specifies the voltage reference state.
			
			Acceptable values:
			  TLPM_VOLTAGE_REF_OFF (0): Voltage reference disabled. Absolute measurement.
			  TLPM_VOLTAGE_REF_ON  (1): Voltage reference enabled. Relative measurement.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setVoltageRefState(self.devSession, voltageReferenceState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getVoltageRefState(self, voltageReferenceState, channel):
		"""
		This function returns the voltage reference state.
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			voltageReferenceState(c_int16 use with byref) : This parameter returns the voltage reference state.
			
			Return values:
			  TLPM_VOLTAGE_REF_OFF (0): Voltage reference disabled. Absolute measurement.
			  TLPM_VOLTAGE_REF_ON  (1): Voltage reference enabled. Relative measurement.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getVoltageRefState(self.devSession, voltageReferenceState, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPeakThreshold(self, peakThreshold, channel):
		"""
		This function sets the peak detector threshold.
		
		Remark:
		Peak detector threshold is in percent [%] of the maximum from the actual measurements range.
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			peakThreshold(c_double) : This parameter specifies the peak detector threshold.
			
			Remark:
			Peak detector threshold is in percent [%] of the maximum from the actual measurements range.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPeakThreshold(self.devSession, peakThreshold, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPeakThreshold(self, attribute, peakThreshold, channel):
		"""
		This function returns the peak detector threshold.
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			peakThreshold(c_double use with byref) : This parameter returns the peak detector threshold.
			
			Remark:
			Peak detector threshold is in percent [%] of the maximum from the actual measurements range.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPeakThreshold(self.devSession, attribute, peakThreshold, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def startPeakDetector(self, channel):
		"""
		Starts peak finder. For pyro or photodiode in pulse mode.
		
		Notes:
		(1) The function is only available on PM103
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_startPeakDetector(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def isPeakDetectorRunning(self, isRunning, channel):
		"""
		Tests if peak finder is active at the moment. Same as polling status operation register of sensor and checking for bit 3.
		
		Notes:
		(1) The function is only available on PM103
		
		Args:
			isRunning(c_int16 use with byref) : returns the running state of the peak detector.
			
			VI_TRUE: peak detector is running
			VI_FALSE: peak detector is stopped.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_isPeakDetectorRunning(self.devSession, isRunning, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPeakFilter(self, filter, channel):
		"""
		
		Args:
			filter(c_int16) : Valid valus for this parameter are
			0 = NONE
			1 = OVER
			Use OVER if the signal measured is a rectangular signal.
			If it is a sinus or triangle signal use NONE.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPeakFilter(self.devSession, filter, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPeakFilter(self, filter, channel):
		"""
		
		Args:
			filter(c_int16 use with byref) : Valid valus for this parameter are
			0 = NONE
			1 = OVER
			Use OVER if the signal measured is a rectangular signal.
			If it is a sinus or triangle signal use NONE.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPeakFilter(self.devSession, filter, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setExtNtcParameter(self, r0Coefficient, betaCoefficient, channel):
		"""
		This function sets the temperature calculation coefficients for the NTC sensor externally connected to the instrument (NTC IN).
		
		Notes:
		(1) The function is only available on PM400.
		
		
		Args:
			r0Coefficient(c_double) : This parameter specifies the R0 coefficient in [Ohm] for calculating the temperature from the sensor's resistance by the beta parameter equation. R0 is the NTC's resistance at T0 (25 °C = 298.15 K).
			betaCoefficient(c_double) : This parameter specifies the B coefficient in [K] for calculating the temperature from the sensor's resistance by the beta parameter equation.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setExtNtcParameter(self.devSession, r0Coefficient, betaCoefficient, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getExtNtcParameter(self, attribute, r0Coefficient, betaCoefficient, channel):
		"""
		This function gets the temperature calculation coefficients for the NTC sensor externally connected to the instrument (NTC IN).
		
		Notes:
		(1) The function is only available on PM400.
		
		
		Args:
			attribute(c_int16) : This parameter specifies the values to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			r0Coefficient(c_double use with byref) : This parameter returns the specified R0 coefficient in [Ohm].
			betaCoefficient(c_double use with byref) : This parameter returns the specified B coefficient in [K].
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getExtNtcParameter(self.devSession, attribute, r0Coefficient, betaCoefficient, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setFilterPosition(self, filterPosition):
		"""
		This function sets the current filter position
		
		Notes:
		(1) The function is only available on PM160 with firmware version 1.5.4 and higher
		
		
		Args:
			filterPosition(c_int16) : This parameter specifies the current filter position
			
			Acceptable values:
			  VI_OFF (0): Filter position OFF. The filter value will not be used in the power calculation
			  VI_ON  (1): Filter position ON, The filter value will be used in the power correction
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setFilterPosition(self.devSession, filterPosition)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFilterPosition(self, filterPosition):
		"""
		This function returns the current filter position
		
		Notes:
		(1) The function is only available on PM160 with firmware version 1.5.4 and higher
		
		
		Args:
			filterPosition(c_int16 use with byref) : This parameter returns the current filter position
			
			Acceptable values:
			  VI_OFF (0): Filter position OFF. The filter value will not be used in the power calculation
			  VI_ON  (1): Filter position ON, The filter value will be used in the power correction
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFilterPosition(self.devSession, filterPosition)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setFilterAutoMode(self, filterAutoPositionDetection):
		"""
		This function enables / disables the automatic filter position detection
		
		Notes:
		(1) The function is only available on PM160 with firmware version 1.5.4 and higher
		
		
		Args:
			filterAutoPositionDetection(c_int16) : This parameter specifies if the automatic filter position detection is enabled/disabled
			
			Acceptable values:
			  VI_OFF (0): Filter position detection is OFF. The manual set fitler position is used
			  VI_ON  (1): Filter position detection is ON, The filter position will be automatically detected
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setFilterAutoMode(self.devSession, filterAutoPositionDetection)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFilterAutoMode(self, filterAutoPositionDetection):
		"""
		This function returns if the automatic filter position detection is used
		
		Notes:
		(1) The function is only available on PM160 with firmware version 1.5.4 and higher
		
		
		Args:
			filterAutoPositionDetection(c_int16 use with byref) : This parameter returns if the automatic filter position detection is enabled/disabled
			
			Acceptable values:
			  VI_OFF (0): Filter position detection is OFF. The manual set fitler position is used
			  VI_ON  (1): Filter position detection is ON, The filter position will be automatically detected
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFilterAutoMode(self.devSession, filterAutoPositionDetection)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAnalogOutputSlopeRange(self, minSlope, maxSlope, channel):
		"""
		This function returns range of the responsivity in volts per watt [V/W] for the analog output.
		
		Notes:
		(1) The function is only available on PM101 and PM102
		
		
		
		Args:
			minSlope(c_double use with byref) : This parameter returns the minimum voltage in Volt [V/W] of the analog output.
			Lower voltage is clipped to the minimum.
			
			maxSlope(c_double use with byref) : This parameter returns the maximum voltage in Volt [V/W] of the analog output.
			Higher voltage values are clipped to the maximum.
			
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAnalogOutputSlopeRange(self.devSession, minSlope, maxSlope, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAnalogOutputSlope(self, slope, channel):
		"""
		This function sets the responsivity in volts per watt [V/W] for the analog output.
		
		Notes:
		(1) The function is only available on PM101 and PM102
		
		
		Args:
			slope(c_double) : This parameter specifies the responsivity in volts per watt [V/W].
			
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAnalogOutputSlope(self.devSession, slope, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAnalogOutputSlope(self, attribute, slope, channel):
		"""
		This function returns the responsivity in volts per watt [V/W] for the analog output.
		
		Notes:
		(1) The function is only available on PM101 and PM102
		
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			slope(c_double use with byref) : This parameter returns the specified responsivity in volts per watt [V/W].
			
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAnalogOutputSlope(self.devSession, attribute, slope, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAnalogOutputVoltageRange(self, minVoltage, maxVoltage, channel):
		"""
		This function returns the range in Volt [V] of the analog output.
		
		Notes:
		(1) The function is only available on PM101 and PM102
		
		
		
		Args:
			minVoltage(c_double use with byref) : This parameter returns the minimum voltage in Volt [V] of the analog output.
			Lower voltage is clipped to the minimum.
			
			maxVoltage(c_double use with byref) : This parameter returns the maximum voltage in Volt [V] of the analog output.
			Higher voltage values are clipped to the maximum.
			
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAnalogOutputVoltageRange(self.devSession, minVoltage, maxVoltage, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAnalogOutputVoltage(self, attribute, voltage, channel):
		"""
		This function returns the analog output in Volt [V].
		
		Notes:
		(1) The function is only available on PM101 and PM102
		
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			voltage(c_double use with byref) : This parameter returns the analog output in Volt [V].
			
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAnalogOutputVoltage(self.devSession, attribute, voltage, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAnalogOutputGainRange(self, gainRangeIndex, channel):
		"""
		This function returns the analog output hub in Volt [V].
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			gainRangeIndex(c_int16 use with byref)
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAnalogOutputGainRange(self.devSession, gainRangeIndex, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAnalogOutputGainRange(self, gainRangeIndex, channel):
		"""
		This function returns the analog output hub in Volt [V].
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			gainRangeIndex(c_int16)
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAnalogOutputGainRange(self.devSession, gainRangeIndex, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getAnalogOutputRoute(self, routeName, channel):
		"""
		This function returns the analog output hub in Volt [V].
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			routeName(create_string_buffer(1024))
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getAnalogOutputRoute(self.devSession, routeName, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setAnalogOutputRoute(self, routeStrategy, channel):
		"""
		This function returns the analog output hub in Volt [V].
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			routeStrategy(c_uint16) : TLPM_ANALOG_ROUTE_PUR  (0)  (Direct Route): The raw amplified signal is output. This signal is related to the photo current or voltage. It is not wavelength or zero compensated.
			TLPM_ANALOG_ROUTE_CBA  (1)  (Compensated Base Unit): The raw amplified signal is multiplied with a correction factor in hardware to compensate the dark current/voltage. The signal is the photo current or voltage and is not wavelength compensated.
			TLPM_ANALOG_ROUTE_CMA  (2) (Compensated Main Unit): The raw amplified signal is multiplied with a correction factor in hardware to output a analogue voltage related to power or energy. The signal is zero and wavelength compensated.
			channel(c_uint16) : Number of the Pin
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setAnalogOutputRoute(self.devSession, routeStrategy, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPositionAnalogOutputSlopeRange(self, minSlope, maxSlope, channel):
		"""
		This function returns range of the responsivity in volts per µm [V/µm] for the analog output.
		
		Notes:
		(1) The function is only available on PM102
		
		
		
		Args:
			minSlope(c_double use with byref) : This parameter returns the minimum slope in [V/µm] of the analog output.
			
			maxSlope(c_double use with byref) : This parameter returns the maximum slope in [V/µm] of the analog output.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPositionAnalogOutputSlopeRange(self.devSession, minSlope, maxSlope, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPositionAnalogOutputSlope(self, slope, channel):
		"""
		This function sets the responsivity in volts per µm [V/µm] for the analog output.
		
		Notes:
		(1) The function is only available on PM102
		
		
		Args:
			slope(c_double) : This parameter specifies the responsivity in volts per µm [V/µm] for the AO2 and AO3 channel 
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPositionAnalogOutputSlope(self.devSession, slope, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPositionAnalogOutputSlope(self, attribute, slope, channel):
		"""
		This function returns the responsivity in volts per µm [V/µm] for the analog output channels.
		
		Notes:
		(1) The function is only available on PM102
		
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			slope(c_double use with byref) : This parameter returns the specified responsivity in volts per µm [V/µm] for the AO2 and AO3 channel 
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPositionAnalogOutputSlope(self.devSession, attribute, slope, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPositionAnalogOutputVoltageRange(self, minVoltage, maxVoltage, channel):
		"""
		This function returns the range in Volt [V] of the analog output.
		
		Notes:
		(1) The function is only available on PM102
		
		
		
		Args:
			minVoltage(c_double use with byref) : This parameter returns the minimum voltage in Volt [V] of the analog output.
			Lower voltage is clipped to the minimum.
			
			maxVoltage(c_double use with byref) : This parameter returns the maximum voltage in Volt [V] of the analog output.
			Higher voltage values are clipped to the maximum.
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPositionAnalogOutputVoltageRange(self.devSession, minVoltage, maxVoltage, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getPositionAnalogOutputVoltage(self, attribute, voltageX, voltageY, channel):
		"""
		This function returns the analog output in Volt [V].
		
		Notes:
		(1) The function is only available on PM102
		
		
		
		Args:
			attribute(c_int16) : This parameter specifies the value to be queried.
			
			Acceptable values:
			  TLPM_ATTR_SET_VAL  (0): Set value
			  TLPM_ATTR_MIN_VAL  (1): Minimum value
			  TLPM_ATTR_MAX_VAL  (2): Maximum value
			  TLPM_ATTR_DFLT_VAL (3): Default value
			
			voltageX(c_double use with byref) : This parameter returns the analog output in Volt [V] for the AO2 channel ( x direction)
			
			voltageY(c_double use with byref) : This parameter returns the analog output in Volt [V] for the AO3 channel ( y direction)
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getPositionAnalogOutputVoltage(self.devSession, attribute, voltageX, voltageY, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getMeasPinMode(self, state, channel):
		"""
		This function returns the meas pin state
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			state(c_int16 use with byref) : This parameter returns the analog output hub in Volt [V].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getMeasPinMode(self.devSession, state, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getMeasPinPowerLevel(self, level, channel):
		"""
		This function returns the meas pin power level in [W]
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			level(c_double use with byref) : This parameter returns the measure pin output power level in Watt [W].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getMeasPinPowerLevel(self.devSession, level, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setMeasPinPowerLevel(self, level, channel):
		"""
		This function returns the meas pin state
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			level(c_double) : This parameter sets the measure pin output power level in Watt [W].
			
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setMeasPinPowerLevel(self.devSession, level, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getMeasPinEnergyLevel(self, level, channel):
		"""
		This function returns the meas pin energy level in [J]
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			level(c_double use with byref) : This parameter returns the measure pin output energy level in  [J].
			
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getMeasPinEnergyLevel(self.devSession, level, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setMeasPinEnergyLevel(self, level, channel):
		"""
		This function returns the meas pin state
		
		Notes:
		(1) The function is only available on PM103
		
		
		
		Args:
			level(c_double) : This parameter returns the measurement pin energy level in [J].
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setMeasPinEnergyLevel(self.devSession, level, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setNegativePulseWidth(self, pulseDuration, channel):
		"""
		This function sets the low pulse duration in Seconds
		
		Notes:
		(1) The function is only available on PM103
		
		
		Args:
			pulseDuration(c_double) : low pulse duration in Seconds
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setNegativePulseWidth(self.devSession, pulseDuration, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPositivePulseWidth(self, pulseDuration, channel):
		"""
		This function sets the high pulse duration in Seconds
		
		Notes:
		(1) The function is only available on PM103
		
		
		Args:
			pulseDuration(c_double) : high pulse duration in Seconds
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPositivePulseWidth(self.devSession, pulseDuration, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setNegativeDutyCycle(self, dutyCycle, channel):
		"""
		This function sets the low duty cycle in Percent
		
		Notes:
		(1) The function is only available on PM103
		
		
		Args:
			dutyCycle(c_double) : low pulse duty cycle in Percent
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setNegativeDutyCycle(self.devSession, dutyCycle, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setPositiveDutyCycle(self, dutyCycle, channel):
		"""
		This function sets the high duty cycle in Percent
		
		Notes:
		(1) The function is only available on PM103
		
		
		Args:
			dutyCycle(c_double) : high pulse duty cycle in Percent
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setPositiveDutyCycle(self.devSession, dutyCycle, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measCurrent(self, current, channel):
		"""
		This function is used to obtain current readings from the instrument. 
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>. 
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160, PM200, PM400.
		
		
		Args:
			current(c_double use with byref) : This parameter returns the current in amperes [A].
			
			Remark:
			This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>. 
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measCurrent(self.devSession, current, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measVoltage(self, voltage, channel):
		"""
		This function is used to obtain voltage readings from the instrument. 
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>. 
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM160T, PM200, PM400.
		
		
		Args:
			voltage(c_double use with byref) : This parameter returns the voltage in volts [V].
			
			Remark:
			This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>. 
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measVoltage(self.devSession, voltage, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measPower(self, power, channel):
		"""
		This function is used to obtain power readings from the instrument. 
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>. 
		
		Args:
			power(c_double use with byref) : This parameter returns the power in the selected unit.
			
			Remark:
			(1) This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>. 
			(2) Select the unit with <Set Power Unit>.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measPower(self.devSession, power, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measEnergy(self, energy, channel):
		"""
		This function is used to obtain energy readings from the instrument. 
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			energy(c_double use with byref) : This parameter returns the actual measured energy value in joule [J].
			
			Remark:
			This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>. 
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measEnergy(self.devSession, energy, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measFreq(self, frequency, channel):
		"""
		This function is used to obtain frequency readings from the instrument. 
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			frequency(c_double use with byref) : This parameter returns the actual measured frequency of the input signal. 
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measFreq(self.devSession, frequency, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measPowerDens(self, powerDensity, channel):
		"""
		This function is used to obtain power density readings from the instrument. 
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			powerDensity(c_double use with byref) : This parameter returns the actual measured power density in watt per square centimeter [W/cm²].
			
			Remark:
			This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measPowerDens(self.devSession, powerDensity, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measEnergyDens(self, energyDensity, channel):
		"""
		This function is used to obtain energy density readings from the instrument. 
		
		Notes:
		(1) The function is only available on PM100D, PM100USB, PM200, PM400.
		
		
		Args:
			energyDensity(c_double use with byref) : This parameter returns the actual measured energy in joule per square centimeter [J/cm²].
			
			Remark:
			This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. Refer to <Set/Get Average Count>.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measEnergyDens(self.devSession, energyDensity, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measAuxAD0(self, voltage, channel):
		"""
		This function is used to obtain voltage readings from the instrument's auxiliary AD0 input. 
		
		Notes:
		(1) The function is only available on PM200, PM400.
		
		
		Args:
			voltage(c_double use with byref) : This parameter returns the voltage in volt.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measAuxAD0(self.devSession, voltage, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measAuxAD1(self, voltage, channel):
		"""
		This function is used to obtain voltage readings from the instrument's auxiliary AD1 input. 
		
		Notes:
		(1) The function is only available on PM200, PM400.
		
		
		Args:
			voltage(c_double use with byref) : This parameter returns the voltage in volt.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measAuxAD1(self.devSession, voltage, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measEmmHumidity(self, humidity, channel):
		"""
		This function is used to obtain relative humidity readings from the Environment Monitor Module (EMM) connected to the instrument. 
		
		Notes:
		(1) The function is only available on PM200, PM400.
		(2) The function will return an error when no EMM is connected.
		
		Args:
			humidity(c_double use with byref) : This parameter returns the relative humidity in %.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measEmmHumidity(self.devSession, humidity, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measEmmTemperature(self, temperature, channel):
		"""
		This function is used to obtain temperature readings from the Environment Monitor Module (EMM) connected to the instrument. 
		
		Notes:
		(1) The function is only available on PM200, PM400.
		(2) The function will return an error when no EMM is connected.
		
		Args:
			temperature(c_double use with byref) : This parameter returns the temperature in °C
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measEmmTemperature(self.devSession, temperature, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measExtNtcTemperature(self, temperature, channel):
		"""
		This function gets temperature readings from the external thermistor sensor connected to the instrument (NTC IN). 
		
		Notes:
		(1) The function is only available on PM400.
		(2) The function will return an error when no external sensor is connected.
		
		
		Args:
			temperature(c_double use with byref) : This parameter returns the temperature in °C
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measExtNtcTemperature(self.devSession, temperature, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measExtNtcResistance(self, resistance, channel):
		"""
		This function gets resistance readings from the external thermistor sensor connected to the instrument (NTC IN). 
		
		Notes:
		(1) The function is only available on PM400.
		(2) The function will return an error when no external sensor is connected.
		
		
		Args:
			resistance(c_double use with byref) : This parameter returns the resistance in Ohm
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measExtNtcResistance(self.devSession, resistance, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measHeadResistance(self, frequency, channel):
		"""
		This function is used to obtain frequency readings from the instrument. 
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			frequency(c_double use with byref) : This parameter returns the resistance in Ohm
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measHeadResistance(self.devSession, frequency, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measHeadTemperature(self, frequency, channel):
		"""
		This function is used to obtain frequency readings from the instrument. 
		
		Notes:
		(1) The function is only available on PM100D, PM100A, PM100USB, PM200, PM400.
		
		
		Args:
			frequency(c_double use with byref) : This parameter returns the temperature in °C
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measHeadTemperature(self.devSession, frequency, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def meas4QPositions(self, xPosition, yPosition, channel):
		"""
		This function returns the x and position of a 4q sensor
		
		Notes:
		(1) The function is only available on PM101, PM102, PM400.
		
		
		Args:
			xPosition(c_double use with byref) : This parameter returns the actual measured x position in µm
			yPosition(c_double use with byref) : This parameter returns the actual measured y position in µm
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_meas4QPositions(self.devSession, xPosition, yPosition, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def meas4QVoltages(self, voltage1, voltage2, voltage3, voltage4, channel):
		"""
		This function returns the voltage of each sector of a 4q sensor
		
		Notes:
		(1) The function is only available on PM101, PM102, PM400.
		
		
		Args:
			voltage1(c_double use with byref) : This parameter returns the actual measured voltage of the upper left sector of a 4q sensor.
			voltage2(c_double use with byref)
			voltage3(c_double use with byref)
			voltage4(c_double use with byref)
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_meas4QVoltages(self.devSession, voltage1, voltage2, voltage3, voltage4, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measNegPulseWidth(self, negativePulseWidth, channel):
		"""
		This function returns the negative pulse width in µsec.
		Notes:
		(1) The function is only available on PM103.
		
		
		Args:
			negativePulseWidth(c_double use with byref) : Negative Pulse Width in µsec.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measNegPulseWidth(self.devSession, negativePulseWidth, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measPosPulseWidth(self, positivePulseWidth, channel):
		"""
		This function returns the positive pulse width in µsec.
		Notes:
		(1) The function is only available on PM103.
		
		
		Args:
			positivePulseWidth(c_double use with byref) : Positive Pulse Width in µsec.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measPosPulseWidth(self.devSession, positivePulseWidth, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measNegDutyCycle(self, negativeDutyCycle, channel):
		"""
		This function returns the negative duty cycle in percentage.
		Notes:
		(1) The function is only available on PM103.
		
		
		Args:
			negativeDutyCycle(c_double use with byref) : Negative Duty Cycle in percentage.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measNegDutyCycle(self.devSession, negativeDutyCycle, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measPosDutyCycle(self, positiveDutyCycle, channel):
		"""
		This function returns the positive duty cycle in percentage.
		Notes:
		(1) The function is only available on PM103.
		
		
		Args:
			positiveDutyCycle(c_double use with byref) : Positive Duty Cycle in percentage.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measPosDutyCycle(self.devSession, positiveDutyCycle, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measPowerMeasurementSequence(self, baseTime, channel):
		"""
		This function send the SCPI Command "CONF:ARR:POW" to the device.
		Then is possible to call the method 'getMeasurementSequence' to get the power data.
		
		Duration of measurement in µsec = Count * Interval
		The maximum capture time is 1 sec regardless of the used interval
		
		Set the bandwidth to high(setInputFilterState to OFF) and disable auto ranging(setPowerAutoRange to OFF)
		
		Note: The function is only available on PM103.
		
		
		Args:
			baseTime(c_uint32) : interval between two measurements in the array in µsec.
			The maximum resolution is 100µsec without averaging
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measPowerMeasurementSequence(self.devSession, baseTime, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measPowerMeasurementSequenceHWTrigger(self, baseTime, hPos, channel):
		"""
		PM103:
		This function send the SCPI Command "CONF:ARR:HWTrig:POW" to the device.
		Then is possible to call the methods 'startMeasurementSequence' and  'getMeasurementSequenceHWTrigger' to get the power data.
		 
		Set the bandwidth to high (setInputFilterState to OFF) and disable auto ranging (setPowerAutoRange to OFF)
		
		PM101 special:
		This function send the SCPI Command "CONF:ARR" to the device.
		Then is possible to call the methods 'startMeasurementSequence' and 'getMeasurementSequenceHWTrigger' to get the power data.
		
		Note: The function is only available on PM103 and PM101 special.
		
		
		Args:
			baseTime(c_uint32) : PM103:
			interval between two measurements in the array in µsec. The maximum resolution is 100 µsec without averaging.
			
			PM101 special:
			time to collect measurements.
			hPos(c_uint32) : PM103:
			Sets the horizontal position of trigger condition in the scope catpure (Between 1 and 9999)
			
			PM101 special:
			Interval between measurements.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measPowerMeasurementSequenceHWTrigger(self.devSession, baseTime, hPos, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measureCurrentMeasurementSequence(self, baseTime, channel):
		"""
		This function send the SCPI Command "CONF:ARR:CURR" to the device.
		Then is possible to call the method 'getMeasurementSequence' to get the power data.
		 
		Duration of measurement in µsec = Count* Interval
		The maximum capture time is 1 sec regardless of the used interval
		
		Set the bandwidth to high(setInputFilterState to OFF) and disable auto ranging(setPowerAutoRange to OFF)
		
		Note: The function is only available on PM103.
		
		
		Args:
			baseTime(c_uint32) : interval between two measurements in the array in µsec.
			The maximum resolution is 100µsec without averaging
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measureCurrentMeasurementSequence(self.devSession, baseTime, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measureCurrentMeasurementSequenceHWTrigger(self, baseTime, hPos, channel):
		"""
		This function send the SCPI Command "CONF:ARR:HWTrig:CURR" to the device.
		Then is possible to call the method 'getMeasurementSequenceHWTrigger' to get the current data.
		 
		Set the bandwidth to high (setInputFilterState to OFF) and disable auto ranging ( setPowerAutoRange to OFF)
		
		PM101 special:
		This function send the SCPI Command "CONF:ARR:CURR" to the device.
		Then is possible to call the methods 'startMeasurementSequence' and 'getMeasurementSequenceHWTrigger' to get the current data.
		
		Note: The function is only available on PM103 and PM101 special.
		
		
		Args:
			baseTime(c_uint32) : PM103:
			interval between two measurements in the array in µsec. The maximum resolution is 100 µsec without averaging.
			
			PM101 special:
			time to collect measurements.
			hPos(c_uint32) : PM103:
			Sets the horizontal position of trigger condition in the scope catpure (Between 1 and 9999)
			
			PM101 special:
			Interval between measurements.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measureCurrentMeasurementSequenceHWTrigger(self.devSession, baseTime, hPos, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measureVoltageMeasurementSequence(self, baseTime, channel):
		"""
		This function send the SCPI Command "CONF:ARR:CURR" to the device.
		Then is possible to call the method 'getMeasurementSequence' to get the power data.
		 
		Duration of measurement in µsec = Count* Interval
		The maximum capture time is 1 sec regardless of the used interval
		
		Set the bandwidth to high(setInputFilterState to OFF) and disable auto ranging(setPowerAutoRange to OFF)
		
		Note: The function is only available on PM5020.
		
		
		Args:
			baseTime(c_uint32) : interval between two measurements in the array in µsec.
			The maximum resolution is 100µsec without averaging
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measureVoltageMeasurementSequence(self.devSession, baseTime, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def measureVoltageMeasurementSequenceHWTrigger(self, baseTime, hPos, channel):
		"""
		This function send the SCPI Command "CONF:ARR:HWTrig:CURR" to the device.
		Then is possible to call the method 'getMeasurementSequenceHWTrigger' to get the current data.
		 
		Set the bandwidth to high (setInputFilterState to OFF) and disable auto ranging ( setPowerAutoRange to OFF)
		
		Note: The function is only available on PM5020.
		
		
		Args:
			baseTime(c_uint32) : PM103:
			interval between two measurements in the array in µsec. The maximum resolution is 100 µsec without averaging.
			
			PM101 special:
			time to collect measurements.
			hPos(c_uint32) : PM103:
			Sets the horizontal position of trigger condition in the scope catpure (Between 1 and 9999)
			
			PM101 special:
			Interval between measurements.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_measureVoltageMeasurementSequenceHWTrigger(self.devSession, baseTime, hPos, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFetchState(self, state, channel):
		"""
		This function can be used to get the measurement state information before doing a fetch.
		
		Notes:
		(1) The function is only available on PM5020.
		
		
		Args:
			state(c_int16 use with byref) : This parameter returns the fetch state
			
			VI_FALSE = no new measurement is ready
			VI_TRUE  = a new measurement is ready and can be get by "FETCH#?" ( replace # with the number of the channel)
			
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFetchState(self.devSession, state, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def resetFastArrayMeasurement(self, channel):
		"""
		This function resets the array measurement.
		
		Note: The function is only available on PM103.
		
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_resetFastArrayMeasurement(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confPowerFastArrayMeasurement(self, channel):
		"""
		This function is used to conffiure the fast array measurement of power values
		After calling this method, wait some milliseconds to call the method TLPM_getNextFastArrayMeasurement.
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds.   
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confPowerFastArrayMeasurement(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confCurrentFastArrayMeasurement(self, channel):
		"""
		This function is used to conffiure the fast array measurement of current values
		After calling this method, wait some milliseconds to call the method TLPM_getNextFastArrayMeasurement.
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. 
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confCurrentFastArrayMeasurement(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confVoltageFastArrayMeasurement(self, channel):
		"""
		This function is used to conffiure the fast array measurement of voltage values
		After calling this method, wait some milliseconds to call the method TLPM_getNextFastArrayMeasurement.
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds.  
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confVoltageFastArrayMeasurement(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confPDensityFastArrayMeasurement(self, channel):
		"""
		This function is used to conffiure the fast array measurement of P density values
		After calling this method, wait some milliseconds to call the method TLPM_getNextFastArrayMeasurement.
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. 
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confPDensityFastArrayMeasurement(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confEnergyFastArrayMeasurement(self, channel):
		"""
		This function is used to configure the fast array measurement of energy values
		After calling this method, wait some milliseconds to call the method TLPM_getNextFastArrayMeasurement.
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. 
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confEnergyFastArrayMeasurement(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confEDensityFastArrayMeasurement(self, channel):
		"""
		This function is used to configure the fast array measurement of E density values.
		After calling this method, wait some milliseconds to call the method TLPM_getNextFastArrayMeasurement.
		
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds. 
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confEDensityFastArrayMeasurement(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getNextFastArrayMeasurement(self, count, timestamps, values, values2, channel):
		"""
		This function is used to obtain measurements from the instrument. 
		The result are timestamp - value pairs.
		
		
		Remark:
		This function starts a new measurement cycle and after finishing measurement the result is received. Subject to the actual Average Count this may take up to seconds.
		
		Args:
			count(c_uint16 use with byref) : The count of timestamp - measurement value pairs
			The value will be 200
			timestamps( (c_uint32 * arrayLength)()) : Buffer containing up to 200 timestamps.
			This are raw timestamps and are NOT in ms.
			values( (c_float * arrayLength)()) : Buffer containing up to 200 measurement values.
			values2( (c_float * arrayLength)()) : Array of power/current measurements. The size of this array is 100 * baseTime.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getNextFastArrayMeasurement(self.devSession, count, timestamps, values, values2, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFastMaxSamplerate(self, pVal, channel):
		"""
		This function is used to obtain the maximal possible sample rate (Hz) 
		
		Args:
			pVal(c_uint32 use with byref) : Max possible sample rate (Hz)
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFastMaxSamplerate(self.devSession, pVal, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confPowerMeasurementSequence(self, baseTime, channel):
		"""
		This function send the SCPI Command "CONF:ARR:POW" to the device.
		Then is possible to call the method 'getMeasurementSequence' to get the power data.
		
		Duration of measurement in µsec = Count * Interval
		The maximum capture time is 1 sec regardless of the used interval
		
		Set the bandwidth to high(setInputFilterState to OFF) and disable auto ranging(setPowerAutoRange to OFF)
		
		Note: The function is only available on PM103.
		
		
		Args:
			baseTime(c_uint32) : interval between two measurements in the array in µsec.
			The maximum resolution is 100µsec without averaging
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confPowerMeasurementSequence(self.devSession, baseTime, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confPowerMeasurementSequenceHWTrigger(self, trigSrc, baseTime, hPos, channel):
		"""
		PM103:
		This function send the SCPI Command "CONF:ARR:HWTrig:POW" to the device.
		Then is possible to call the methods 'startMeasurementSequence' and  'getMeasurementSequenceHWTrigger' to get the power data.
		 
		Set the bandwidth to high (setInputFilterState to OFF) and disable auto ranging (setPowerAutoRange to OFF)
		
		PM101 special:
		This function send the SCPI Command "CONF:ARR" to the device.
		Then is possible to call the methods 'startMeasurementSequence' and 'getMeasurementSequenceHWTrigger' to get the power data.
		
		Note: The function is only available on PM103 and PM101 special.
		
		
		Args:
			trigSrc(c_uint16) : PM103:
			interval between two measurements in the array in µsec. The maximum resolution is 100 µsec without averaging.
			
			PM101 special:
			time to collect measurements.
			baseTime(c_uint32) : PM103:
			Sets the horizontal position of trigger condition in the scope catpure (Between 1 and 9999)
			
			PM101 special:
			Interval between measurements.
			hPos(c_uint32) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confPowerMeasurementSequenceHWTrigger(self.devSession, trigSrc, baseTime, hPos, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confCurrentMeasurementSequence(self, baseTime, channel):
		"""
		This function send the SCPI Command "CONF:ARR:CURR" to the device.
		Then is possible to call the method 'getMeasurementSequence' to get the power data.
		 
		Duration of measurement in µsec = Count* Interval
		The maximum capture time is 1 sec regardless of the used interval
		
		Set the bandwidth to high(setInputFilterState to OFF) and disable auto ranging(setPowerAutoRange to OFF)
		
		Note: The function is only available on PM103.
		
		
		Args:
			baseTime(c_uint32) : interval between two measurements in the array in µsec.
			The maximum resolution is 100µsec without averaging
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confCurrentMeasurementSequence(self.devSession, baseTime, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confCurrentMeasurementSequenceHWTrigger(self, trigSrc, baseTime, hPos, channel):
		"""
		This function send the SCPI Command "CONF:ARR:HWTrig:CURR" to the device.
		Then is possible to call the method 'getMeasurementSequenceHWTrigger' to get the current data.
		 
		Set the bandwidth to high (setInputFilterState to OFF) and disable auto ranging ( setPowerAutoRange to OFF)
		
		PM101 special:
		This function send the SCPI Command "CONF:ARR:CURR" to the device.
		Then is possible to call the methods 'startMeasurementSequence' and 'getMeasurementSequenceHWTrigger' to get the current data.
		
		Note: The function is only available on PM103 and PM101 special.
		
		
		Args:
			trigSrc(c_uint16) : PM103:
			interval between two measurements in the array in µsec. The maximum resolution is 100 µsec without averaging.
			
			PM101 special:
			time to collect measurements.
			baseTime(c_uint32) : PM103:
			Sets the horizontal position of trigger condition in the scope catpure (Between 1 and 9999)
			
			PM101 special:
			Interval between measurements.
			hPos(c_uint32) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confCurrentMeasurementSequenceHWTrigger(self.devSession, trigSrc, baseTime, hPos, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confVolatgeMeasurementSequence(self, baseTime, channel):
		"""
		
		Args:
			baseTime(c_uint32)
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confVolatgeMeasurementSequence(self.devSession, baseTime, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confVolatgeMeasurementSequenceHWTrigger(self, trigSrc, baseTime, hPos, channel):
		"""
		
		Args:
			trigSrc(c_uint16)
			baseTime(c_uint32)
			hPos(c_uint32)
			channel(c_uint16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confVolatgeMeasurementSequenceHWTrigger(self.devSession, trigSrc, baseTime, hPos, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def startMeasurementSequence(self, autoTriggerDelay, triggerForced, channel):
		"""
		This function send the SCPI Command "INIT" to the device.
		
		PM103:
		Then it calls TLPM_readRegister for the register TLPM_REG_OPER_COND if there is new data to read
		
		If this method is successfull you can call getMeasurementSequence or getMeasurementSequenceHWTrigger
		
		PM101 special:
		Just the INIT command is send to the device.
		
		
		Note: The function is only available on PM103 and PM101 special. 
		
		
		
		Args:
			autoTriggerDelay(c_uint32) : PM103:
			The unit of this parameter is milliseconds.
			If this parameter bigger then zero, the method will
			wait the time in milliseconds to send the SCPI command:"TRIGer:ARRay:FORce".
			
			This command will force the measurement. 
			
			PM101 special:
			Not used.
			triggerForced(c_int16 use with byref) : PM103:
			Return parameter is TRUE if the command:"TRIGer:ARRay:FORce". was internally send to the device. See parameter "AutoTriggerDelay".
			
			PM101 special:
			Not used.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_startMeasurementSequence(self.devSession, autoTriggerDelay, triggerForced, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getMeasurementSequence(self, baseTime, timeStamps, values, values2, channel):
		"""
		 Should be called if the methods confPowerMeasurementSequence and startMeasurementSequence were called first.
		 
		This function filles the given array with (100 * baseTime) measurements from the device.
		
		Duration of measurement in µsec = Count* Interval
		The maximum capture time is 1 sec regardless of the used inteval
		Set the bandwidth to high(setInputFilterState to OFF) and disable auto ranging(setPowerAutoRange to OFF)
		
		Note: The function is only available on PM103.
		
		
		Args:
			baseTime(c_uint32) : The amount of samples to collect in the internal interation of the method.
			The value can be from 1 to 100.
			
			Every sample is 10µs for PM5020.
			timeStamps( (c_float * arrayLength)()) : Array of time stamps in ms. The size of this array is 100 * baseTime.
			values( (c_float * arrayLength)()) : Array of power/current measurements. The size of this array is 100 * baseTime.
			values2( (c_float * arrayLength)()) : Array of power/current measurements. The size of this array is 100 * baseTime.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getMeasurementSequence(self.devSession, baseTime, timeStamps, values, values2, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getMeasurementSequenceHWTrigger(self, baseTime, timeStamps, values, values2, channel):
		"""
		Should be called if the method confPowerMeasurementSequenceHWTrigger and startMeasurementSequence were called first, (or confCurrentMeasurementSequenceHWTrigger and startMeasurementSequence)
		
		PM103: 
		 This function fills the given array with (100 * baseTime) measurements from the device, external triggered.
		 Set the bandwidth to high(setInputFilterState to OFF) and disable auto ranging(setPowerAutoRange to OFF)
		 
		PM101 special:
		This function fills the Values array with measurements from the device, external triggered.
		The size of measurements to set in the array is in the parameter Base Time. Base Time is equal to the time of measurement through the intervall between each measurement. These parameters are set in the method confPowerMeasurementSequenceHWTrigger. 
		 
		
		 Note: The function is only available on PM103 and PM101 special (Not HWT). 
		
		
		Args:
			baseTime(c_uint32) : PM103:
			The amount of samples to collect in the internal interation of the method. The value can be from 1 to 100.
			PM101:
			Size of measuremnts to collect from the PM101. Time of measurement / intervall.
			timeStamps( (c_float * arrayLength)()) : PM103:
			Array of time stamps in ms. The size of this array is 100 * baseTime.
			
			PM101 special:
			Not used.
			values( (c_float * arrayLength)()) : PM103:
			Array of power/current measurements. The size of this array is 100 * baseTime.
			
			PM101:
			Array of power/current measurements. The size of this array is the time of measurement through the interval.
			
			values2( (c_float * arrayLength)()) : Array of power/current measurements. The size of this array is 100 * baseTime.
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getMeasurementSequenceHWTrigger(self.devSession, baseTime, timeStamps, values, values2, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confBurstArrayMeasurementChannel(self, channel):
		"""
		This function is used to configure the burst array measurement of each channel.
		
		
		Args:
			channel(c_uint16) : Number of the sensor channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confBurstArrayMeasurementChannel(self.devSession, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confBurstArrayMeasPowerTrigger(self, initDelay, burstCount, averaging):
		"""
		
		Args:
			initDelay(c_uint32)
			burstCount(c_uint32)
			averaging(c_uint32)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confBurstArrayMeasPowerTrigger(self.devSession, initDelay, burstCount, averaging)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def confBurstArrayMeasCurrentTrigger(self, initDelay, burstCount, averaging):
		"""
		
		Args:
			initDelay(c_uint32)
			burstCount(c_uint32)
			averaging(c_uint32)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_confBurstArrayMeasCurrentTrigger(self.devSession, initDelay, burstCount, averaging)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def startBurstArrayMeasurement(self):
		"""
		Starts a burst array measurement
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_startBurstArrayMeasurement(self.devSession)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getBurstArraySamplesCount(self, samplesCount):
		"""
		Read the amount of samples in the burst array buffer
		
		Args:
			samplesCount(c_uint32 use with byref) : Amount of samples measure in burst mode.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getBurstArraySamplesCount(self.devSession, samplesCount)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getBurstArraySamples(self, startIndex, sampleCount, timeStamps, values, values2):
		"""
		Read scope buffer content at index 
		
		Args:
			startIndex(c_uint32)
			sampleCount(c_uint32)
			timeStamps( (c_float * arrayLength)()) : Buffer containing the samples.
			
			Buffer size: Samples Count * 2
			values( (c_float * arrayLength)())
			values2( (c_float * arrayLength)())
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getBurstArraySamples(self.devSession, startIndex, sampleCount, timeStamps, values, values2)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDigIoDirection(self, IO0, IO1, IO2, IO3):
		"""
		This function sets the digital I/O port direction.
		
		Note: The function is only available on PM200 and PM400.
		
		Args:
			IO0(c_int16) : This parameter specifies the I/O port #0 direction.
			
			Input:  VI_OFF (0)
			Output: VI_ON  (1)
			
			IO1(c_int16) : This parameter specifies the I/O port #1 direction.
			
			Input:  VI_OFF (0)
			Output: VI_ON  (1)
			
			IO2(c_int16) : This parameter specifies the I/O port #2 direction.
			
			Input:  VI_OFF (0)
			Output: VI_ON  (1)
			
			IO3(c_int16) : This parameter specifies the I/O port #3 direction.
			
			Input:  VI_OFF (0)
			Output: VI_ON  (1)
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDigIoDirection(self.devSession, IO0, IO1, IO2, IO3)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDigIoDirection(self, IO0, IO1, IO2, IO3):
		"""
		This function returns the digital I/O port direction.
		
		Note: The function is only available on PM200 and PM400.
		
		Args:
			IO0(c_int16 use with byref) : This parameter returns the I/O port #0 direction where VI_OFF (0) indicates input and VI_ON (1) indicates output.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO1(c_int16 use with byref) : This parameter returns the I/O port #1 direction where VI_OFF (0) indicates input and VI_ON (1) indicates output.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO2(c_int16 use with byref) : This parameter returns the I/O port #2 direction where VI_OFF (0) indicates input and VI_ON (1) indicates output.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO3(c_int16 use with byref) : This parameter returns the I/O port #3 direction where VI_OFF (0) indicates input and VI_ON (1) indicates output.
			
			Note: You may pass VI_NULL if you don't need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDigIoDirection(self.devSession, IO0, IO1, IO2, IO3)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDigIoOutput(self, IO0, IO1, IO2, IO3):
		"""
		This function sets the digital I/O outputs.
		
		Notes:
		(1) Only ports configured as outputs are affected by this function. Use <Set Digital I/O Direction> to configure ports as outputs.
		(2) The function is only available on PM200 and PM400.
		
		Args:
			IO0(c_int16) : This parameter specifies the I/O port #0 output.
			
			Low level:  VI_OFF (0)
			High level: VI_ON  (1)
			
			IO1(c_int16) : This parameter specifies the I/O port #1 output.
			
			Low level:  VI_OFF (0)
			High level: VI_ON  (1)
			
			IO2(c_int16) : This parameter specifies the I/O port #2 output.
			
			Low level:  VI_OFF (0)
			High level: VI_ON  (1)
			
			IO3(c_int16) : This parameter specifies the I/O port #3 output.
			
			Low level:  VI_OFF (0)
			High level: VI_ON  (1)
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDigIoOutput(self.devSession, IO0, IO1, IO2, IO3)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDigIoOutput(self, IO0, IO1, IO2, IO3):
		"""
		This function returns the digital I/O output settings.
		
		Note: The function is only available on PM200 and PM400.
		
		Args:
			IO0(c_int16 use with byref) : This parameter returns the I/O port #0 output where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO1(c_int16 use with byref) : This parameter returns the I/O port #1 output where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO2(c_int16 use with byref) : This parameter returns the I/O port #2 output where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO3(c_int16 use with byref) : This parameter returns the I/O port #3 output where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDigIoOutput(self.devSession, IO0, IO1, IO2, IO3)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDigIoPort(self, IO0, IO1, IO2, IO3):
		"""
		This function returns the actual digital I/O port level.
		
		Note: The function is only available on PM200 and PM400.
		
		Args:
			IO0(c_int16 use with byref) : This parameter returns the I/O port #0 level where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO1(c_int16 use with byref) : This parameter returns the I/O port #1 level where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO2(c_int16 use with byref) : This parameter returns the I/O port #2 level where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO3(c_int16 use with byref) : This parameter returns the I/O port #3 level where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDigIoPort(self.devSession, IO0, IO1, IO2, IO3)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDigIoPinMode(self, pinNumber, pinMode):
		"""
		This function sets the digital I/O port direction.
		
		Note: The function is only available on PM200, PM400 and PM103
		
		Args:
			pinNumber(c_int16) : Number of the Pin.
			
			Range: 1-7
			pinMode(c_uint16) : This parameter specifies the I/O port direction.
			
			Input:       DIGITAL_IO_CONFIG_INPUT   (0)
			Output:      DIGITAL_IO_CONFIG_OUTPUT  (1)
			Alternative: DIGITAL_IO_CONFIG_ALT     (2)
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDigIoPinMode(self.devSession, pinNumber, pinMode)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDigIoPinMode(self, pinNumber, pinMode):
		"""
		This function returns the digital I/O port direction.
		
		Note: The function is only available on PM200, PM400 and PM103
		
		Args:
			pinNumber(c_int16) : Number of the Pin.
			
			Range: 1-7
			pinMode(c_uint16 use with byref) : This parameter returns the I/O port #0 direction.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			Input:              DIGITAL_IO_CONFIG_INPUT      (0)
			Output:             DIGITAL_IO_CONFIG_OUTPUT     (1)
			Input Alternative:  DIGITAL_IO_CONFIG_INPUT_ALT  (2)
			Output Alternative: DIGITAL_IO_CONFIG_OUTPUT_ALT (3)
			
			
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDigIoPinMode(self.devSession, pinNumber, pinMode)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDigIoOutput2(self, IO0, IO1, IO2, IO3):
		"""
		
		Args:
			IO0(c_int16)
			IO1(c_int16)
			IO2(c_int16)
			IO3(c_int16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDigIoOutput(self.devSession, IO0, IO1, IO2, IO3)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDigIoOutput2(self, IO0, IO1, IO2, IO3):
		"""
		
		Args:
			IO0(c_int16 use with byref)
			IO1(c_int16 use with byref)
			IO2(c_int16 use with byref)
			IO3(c_int16 use with byref)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDigIoOutput(self.devSession, IO0, IO1, IO2, IO3)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDigIoPinInput(self, IO0, IO1, IO2, IO3):
		"""
		This function returns the actual digital I/O port level.
		
		Note: The function is only available on PM200 and PM400.
		
		Args:
			IO0(c_int16 use with byref) : This parameter returns the I/O port #0 level where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO1(c_int16 use with byref) : This parameter returns the I/O port #1 level where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO2(c_int16 use with byref) : This parameter returns the I/O port #2 level where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
			IO3(c_int16 use with byref) : This parameter returns the I/O port #3 level where VI_OFF (0) indicates low level and VI_ON (1) indicates high level.
			
			Note: You may pass VI_NULL if you don't need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDigIoPinInput(self.devSession, IO0, IO1, IO2, IO3)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getShutterInterlock(self, interlockState):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			interlockState(c_int16 use with byref)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getShutterInterlock(self.devSession, interlockState)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setShutterPosition(self, position):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			position(c_int16)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setShutterPosition(self.devSession, position)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getShutterPosition(self, position):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			position(c_int16 use with byref)
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getShutterPosition(self.devSession, position)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setI2CMode(self, mode):
		"""
		This setter changes the I2C speed and operating mode. By dafault I2C is controlled by the powermeter and SCPI I2C commands are disabled. It is mandatory to select a manual mode before SCPI I2C commands are enabled. The configuraiton is not stored for next boot. Be aware in manual mode the optional external environmental sensor will not longer be queried by the powermeter. The following modes are supported
		INTER: I2C controlled by powermeter. SCPI I2C disabled.
		SLOW: I2C controlled by SCPI commands in 100k standard speed. Powermeter does not access bus.
		FAST: I2C controlled by SCPI commands in 400k fast speed. Powermeter does not access bus.
		
		Note: The function is only available on PM5020
		
		Args:
			mode(c_uint16) : INTER,SLOW,FASTnew I2C operating mode and speed. See list in detail section.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setI2CMode(self.devSession, mode)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getI2CMode(self, mode):
		"""
		The command queries the I2C speed and operating mode. 
		INTER: I2C controlled by powermeter. SCPI I2C disabled.
		SLOW: I2C controlled by SCPI commands in 100k standard speed. Powermeter does not access bus.
		FAST: I2C controlled by SCPI commands in 400k fast speed. Powermeter does not access bus.
		
		Note: The function is only available on PM5020
		
		Args:
			mode(c_int16 use with byref) : INTER,SLOW,FASTI2C operating mode and speed
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getI2CMode(self.devSession, mode)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def I2CRead(self, address, count, dataRead):
		"""
		The command receives data from slave with given address. The function requires TLPMX_setI2CMode to be called once previously. The command returns data as integer. Data is read synchronously with the SCPI command.
		
		Note: The function is only available on PM5020
		
		Args:
			address(c_uint32) : I2C slave address. Address are bit 7 to bit 1. Bit 0 is ignored.
			count(c_uint32) : amount of bytes to read from address. Needs to be less than 128.
			dataRead(c_uint32 use with byref) : received data.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_I2CRead(self.devSession, address, count, dataRead)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def I2CWrite(self, address, hexData):
		"""
		The command transmits given data to slave with given address. The function requires TLPMX_setI2CMode  to be called once previously. The transmission data is given as hexadecimal string parameter. The length needs to be a multiple of two as two hex digits encode a single byte. Leading zeros are mandatory. So to transfer byte 2 and 75 use string 024B. Hex digits are support upper or lowercase letters. The maximal length are 128 Bytes. Data is transferred synchronously with the SCPI command. If you want to read after writing some data you may use TLPMX_I2CWriteRead.
		
		Note: The function is only available on PM5020
		
		Args:
			address(c_uint32) : I2C slave address. Address are bit 7 to bit 1. Bit 0 is ignored.
			hexData(c_char_p) : transmission data as hexadecimal string without byte separator. Length always multiple of 2.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_I2CWrite(self.devSession, address, hexData)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def I2CWriteRead(self, address, hexSendData, count, dataRead):
		"""
		The command transmits given data to slave with given address following a bus reception from same device if transmission was successful. This command is a convenience function for a CON:I2C#:WRIT followed by a CON:I2C#:READ? command sequence. The maximal transmission and reception byte count is 128. For closer details of hexString format read TLPMX_I2CWrite command description.
		
		Note: The function is only available on PM5020
		
		Args:
			address(c_uint32) : I2C slave address. Address are bit 7 to bit 1. Bit 0 is ignored.
			hexSendData(c_char_p) : transmission data as hexadecimal string without byte separator. Length always multiple of 2.
			count(c_uint32) : amount of bytes to read from address.
			dataRead(c_uint32 use with byref) : received data.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_I2CWriteRead(self.devSession, address, hexSendData, count, dataRead)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFanState(self, isRunning, channel):
		"""
		This function returns if the fan is running
		
		Note: The function is only available on PM5020
		
		Args:
			isRunning(c_int16 use with byref) : Returns the fan running state
			
			VI_OFF (0) Fan is still
			VI_ON  (1) Fan is running
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFanState(self.devSession, isRunning, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setFanMode(self, mode, channel):
		"""
		This function sets the state of the fan to 
		
		FAN_OPER_OFF         (0)
		FAN_OPER_FULL        (1)
		FAN_OPER_OPEN_LOOP   (2)
		FAN_OPER_CLOSED_LOOP (3)
		FAN_OPER_TEMPER_CTRL (4)
		
		Note: The function is only available on PM5020
		
		Args:
			mode(c_uint16)
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setFanMode(self.devSession, mode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFanMode(self, mode, channel):
		"""
		This function gets the state of the fan of
		
		FAN_OPER_OFF         (0)
		FAN_OPER_FULL        (1)
		FAN_OPER_OPEN_LOOP   (2)
		FAN_OPER_CLOSED_LOOP (3)
		FAN_OPER_TEMPER_CTRL (4)
		
		Note: The function is only available on PM5020
		
		Args:
			mode(c_uint16 use with byref)
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFanMode(self.devSession, mode, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setFanVoltage(self, voltage, channel):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			voltage(c_double)
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setFanVoltage(self.devSession, voltage, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFanVoltage(self, voltage, channel):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			voltage(c_double use with byref)
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFanVoltage(self.devSession, voltage, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setFanRpm(self, maxRPM, targetRPM, channel):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			maxRPM(c_double) : Max RPM of the Fan
			targetRPM(c_double) : Target RPM of the Fan
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setFanRpm(self.devSession, maxRPM, targetRPM, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFanRpm(self, maxRPM, targetRPM, channel):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			maxRPM(c_double use with byref) : Max RPM of the fan
			targetRPM(c_double use with byref) : Target RPM of the fan
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFanRpm(self.devSession, maxRPM, targetRPM, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getActFanRpm(self, RPM, channel):
		"""
		Gets the current rpm of the fan
		
		Note: The function is only available on PM5020
		
		Args:
			RPM(c_double use with byref) : Current RPM of the fan
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getActFanRpm(self.devSession, RPM, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setFanTemperatureSource(self, source, channel):
		"""
		This function sets the source for the temperature control
		
		FAN_TEMPER_SRC_HEAD (0)    ///< Sensor head temper source
		FAN_TEMPER_SRC_EXT_NTC (1) ///< External NTC temper source
		
		Note: The function is only available on PM5020
		
		Args:
			source(c_uint16) : Source for the temperature control
			
			FAN_TEMPER_SRC_HEAD (0)    ///< Sensor head temper source
			FAN_TEMPER_SRC_EXT_NTC (1) ///< External NTC temper source
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setFanTemperatureSource(self.devSession, source, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFanTemperatureSource(self, source, channel):
		"""
		This function gets the source for the temperature control
		
		FAN_TEMPER_SRC_HEAD (0)    ///< Sensor head temper source
		FAN_TEMPER_SRC_EXT_NTC (1) ///< External NTC temper source
		
		Note: The function is only available on PM5020
		
		Args:
			source(c_uint16 use with byref) : Source for the temperature control
			
			FAN_TEMPER_SRC_HEAD (0)    ///< Sensor head temper source
			FAN_TEMPER_SRC_EXT_NTC (1) ///< External NTC temper source
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFanTemperatureSource(self.devSession, source, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setFanAdjustParameters(self, voltageMin, voltageMax, temperatureMin, temperatureMax, channel):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			voltageMin(c_double)
			voltageMax(c_double)
			temperatureMin(c_double)
			temperatureMax(c_double)
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setFanAdjustParameters(self.devSession, voltageMin, voltageMax, temperatureMin, temperatureMax, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getFanAdjustParameters(self, voltageMin, voltageMax, temperatureMin, temperatureMax, channel):
		"""
		This function sets the state of the fan to 
		
		OFF (0)
		FULL (1)
		
		Note: The function is only available on PM5020
		
		Args:
			voltageMin(c_double use with byref)
			voltageMax(c_double use with byref)
			temperatureMin(c_double use with byref)
			temperatureMax(c_double use with byref)
			channel(c_uint16) : Number of the fan channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getFanAdjustParameters(self.devSession, voltageMin, voltageMax, temperatureMin, temperatureMax, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def errorMessage(self, statusCode, description):
		"""
		This function takes the error code returned by the instrument driver functions interprets it and returns it as an user readable string. 
		
		Status/error codes and description:
		
		--- Instrument Driver Errors and Warnings ---
		Status      Description
		-------------------------------------------------
		         0  No error (the call was successful).
		0x3FFF0085  Unknown Status Code     - VI_WARN_UNKNOWN_STATUS
		0x3FFC0901  WARNING: Value overflow - VI_INSTR_WARN_OVERFLOW
		0x3FFC0902  WARNING: Value underrun - VI_INSTR_WARN_UNDERRUN
		0x3FFC0903  WARNING: Value is NaN   - VI_INSTR_WARN_NAN
		0xBFFC0001  Parameter 1 out of range. 
		0xBFFC0002  Parameter 2 out of range.
		0xBFFC0003  Parameter 3 out of range.
		0xBFFC0004  Parameter 4 out of range.
		0xBFFC0005  Parameter 5 out of range.
		0xBFFC0006  Parameter 6 out of range.
		0xBFFC0007  Parameter 7 out of range.
		0xBFFC0008  Parameter 8 out of range.
		0xBFFC0012  Error Interpreting instrument response.
		
		--- Instrument Errors --- 
		Range: 0xBFFC0700 .. 0xBFFC0CFF.
		Calculation: Device error code + 0xBFFC0900.
		Please see your device documentation for details.
		
		--- VISA Errors ---
		Please see your VISA documentation for details.
		
		
		Args:
			statusCode(c_int) : This parameter accepts the error codes returned from the instrument driver functions.
			
			Default Value: 0 - VI_SUCCESS
			description(create_string_buffer(1024)) : This parameter returns the interpreted code as an user readable message string.
			
			Notes:
			(1) The message buffer has to be initalized with 256 bytes.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_errorMessage(self.devSession, statusCode, description)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def errorQuery(self, errorNumber, errorMessage):
		"""
		This function queries the instrument's error queue manually. 
		Use this function to query the instrument's error queue if the driver's error query mode is set to manual query. 
		
		Notes:
		(1) The returned values are stored in the drivers error store. You may use <Error Message> to get a descriptive text at a later point of time.
		
		Args:
			errorNumber(c_int use with byref) : This parameter returns the instrument error number.
			
			Notes:
			(1) You may pass VI_NULL if you don't need this value.
			
			errorMessage(create_string_buffer(1024)) : This parameter returns the instrument error message.
			
			Notes:
			(1) The array must contain at least 256 elements ViChar[256] including the null byte.
			(2) You may pass VI_NULL if you do not need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_errorQuery(self.devSession, errorNumber, errorMessage)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def errorQueryMode(self, mode):
		"""
		This function selects the driver's error query mode.
		
		Args:
			mode(c_int16) : This parameter specifies the driver's error query mode. 
			
			If set to Automatic each driver function queries the instrument's error queue and in case an error occured returns the error number.
			
			If set to Manual the driver does not query the instrument for errors and therefore a driver function does not return instrument errors. You should use <Error Query> to manually query the instrument's error queue.
			
			VI_OFF (0): Manual error query.
			VI_ON  (1): Automatic error query (default).
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_errorQueryMode(self.devSession, mode)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def errorCount(self, count):
		"""
		This function returns the number of errors in the queue.
		
		Args:
			count(c_uint32 use with byref) : This parameter returns the instrument error number.
			
			Notes:
			(1) You may pass VI_NULL if you don't need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_errorCount(self.devSession, count)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def reset(self):
		"""
		Places the instrument in a default state.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_reset(self.devSession)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def selfTest(self, selfTestResult, description):
		"""
		This function runs the device self test routine and returns the test result.
		
		Args:
			selfTestResult(c_int16 use with byref) : This parameter contains the value returned from the device self test routine. A retured zero value indicates a successful run, a value other than zero indicates failure.
			description(create_string_buffer(1024)) : This parameter returns the interpreted code as an user readable message string.
			
			Notes:
			(1) The array must contain at least 256 elements ViChar[256].
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_selfTest(self.devSession, selfTestResult, description)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def revisionQuery(self, instrumentDriverRevision, firmwareRevision):
		"""
		This function returns the revision numbers of the instrument driver and the device firmware.
		
		Args:
			instrumentDriverRevision(create_string_buffer(1024)) : This parameter returns the Instrument Driver revision.
			
			Notes:
			(1) The array must contain at least 256 elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this value.
			
			firmwareRevision(create_string_buffer(1024)) : This parameter returns the device firmware revision. 
			
			Notes:
			(1) The array must contain at least 256 elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_revisionQuery(self.devSession, instrumentDriverRevision, firmwareRevision)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def identificationQuery(self, manufacturerName, deviceName, serialNumber, firmwareRevision):
		"""
		This function returns the device identification information.
		
		Args:
			manufacturerName(create_string_buffer(1024)) : This parameter returns the manufacturer name.
			
			Notes:
			(1) The array must contain at least 256 elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this value.
			
			deviceName(create_string_buffer(1024)) : This parameter returns the device name.
			
			Notes:
			(1) The array must contain at least 256 elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this value.
			
			serialNumber(create_string_buffer(1024)) : This parameter returns the device serial number.
			
			Notes:
			(1) The array must contain at least 256 elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this value.
			
			firmwareRevision(create_string_buffer(1024)) : This parameter returns the device firmware revision.
			
			Notes:
			(1) The array must contain at least 256 elements ViChar[256].
			(2) You may pass VI_NULL if you do not need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_identificationQuery(self.devSession, manufacturerName, deviceName, serialNumber, firmwareRevision)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getCalibrationMsg(self, message, channel):
		"""
		This function returns a human readable calibration message.
		
		
		Args:
			message(create_string_buffer(1024)) : This parameter returns the calibration message.
			
			Notes:
			(1) The array must contain at least TLPM_BUFFER_SIZE (256) elements ViChar[256].
			channel(c_uint16) : Number if the channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getCalibrationMsg(self.devSession, message, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDisplayName(self, name):
		"""
		This method send the SCPI command SYST:COMM:NET:HOST %S
		This name is used by the PM400 as custom display name
		and by the PM103E as network hostname.
		
		Args:
			name(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDisplayName(self.devSession, name)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDisplayName(self, name):
		"""
		This method send the SCPI command SYST:COMM:NET:HOST?
		This name is used by the PM400 as custom display name
		and by the PM103E as network hostname.
		
		Args:
			name(create_string_buffer(1024))
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDisplayName(self.devSession, name)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getChannels(self, channelCount):
		"""
		This function returns the number of supported sensor channels.
		
		Args:
			channelCount(c_uint16 use with byref) : Number of supported sensor channels.
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getChannels(self.devSession, channelCount)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getSensorInfo(self, name, snr, message, pType, pStype, pFlags, channel):
		"""
		This function is used to obtain informations from the connected sensor like sensor name, serial number, calibration message, sensor type, sensor subtype and sensor flags.  
		
		Remark:
		The meanings of the obtained sensor type, subtype and flags are:
		
		Sensor Types:
		 SENSOR_TYPE_NONE               0x00 // No sensor
		 SENSOR_TYPE_PD_SINGLE          0x01 // Photodiode sensor
		 SENSOR_TYPE_THERMO             0x02 // Thermopile sensor
		 SENSOR_TYPE_PYRO               0x03 // Pyroelectric sensor
		
		Sensor Subtypes:
		 SENSOR_SUBTYPE_NONE            0x00 // No sensor
		 
		Sensor Subtypes Photodiode:
		 SENSOR_SUBTYPE_PD_ADAPTER      0x01 // Photodiode adapter
		 SENSOR_SUBTYPE_PD_SINGLE_STD   0x02 // Photodiode sensor
		 SENSOR_SUBTYPE_PD_SINGLE_FSR   0x03 // Photodiode sensor with 
		                                        integrated filter
		                                        identified by position 
		 SENSOR_SUBTYPE_PD_SINGLE_STD_T 0x12 // Photodiode sensor with
		                                        temperature sensor
		Sensor Subtypes Thermopile:
		 SENSOR_SUBTYPE_THERMO_ADAPTER  0x01 // Thermopile adapter
		 SENSOR_SUBTYPE_THERMO_STD      0x02 // Thermopile sensor
		 SENSOR_SUBTYPE_THERMO_STD_T    0x12 // Thermopile sensor with 
		                                        temperature sensor
		Sensor Subtypes Pyroelectric Sensor:
		 SENSOR_SUBTYPE_PYRO_ADAPTER    0x01 // Pyroelectric adapter
		 SENSOR_SUBTYPE_PYRO_STD        0x02 // Pyroelectric sensor
		 SENSOR_SUBTYPE_PYRO_STD_T      0x12 // Pyroelectric sensor with
		                                        temperature sensor
		Sensor Flags:
		 TLPM_SENS_FLAG_IS_POWER     0x0001 // Power sensor
		 TLPM_SENS_FLAG_IS_ENERGY    0x0002 // Energy sensor
		 TLPM_SENS_FLAG_IS_RESP_SET  0x0010 // Responsivity settable
		 TLPM_SENS_FLAG_IS_WAVEL_SET 0x0020 // Wavelength settable
		 TLPM_SENS_FLAG_IS_TAU_SET   0x0040 // Time constant settable
		 TLPM_SENS_FLAG_HAS_TEMP     0x0100 // With Temperature sensor 
		
		Args:
			name(create_string_buffer(1024)) : This parameter returns the name of the connected sensor.
			
			snr(create_string_buffer(1024)) : This parameter returns the serial number of the connected sensor.
			message(create_string_buffer(1024)) : This parameter returns the calibration message of the connected sensor.
			
			pType(c_int16 use with byref) : This parameter returns the sensor type of the connected sensor.
			
			Remark:
			The meanings of the obtained sensor type are:
			
			Sensor Types:
			 SENSOR_TYPE_NONE               0x00 // No sensor
			 SENSOR_TYPE_PD_SINGLE          0x01 // Photodiode sensor
			 SENSOR_TYPE_THERMO             0x02 // Thermopile sensor
			 SENSOR_TYPE_PYRO               0x03 // Pyroelectric sensor
			pStype(c_int16 use with byref) : This parameter returns the subtype of the connected sensor.
			
			Remark:
			The meanings of the obtained sensor subtype are:
			
			Sensor Subtypes:
			 SENSOR_SUBTYPE_NONE            0x00 // No sensor
			 
			Sensor Subtypes Photodiode:
			 SENSOR_SUBTYPE_PD_ADAPTER      0x01 // Photodiode adapter
			 SENSOR_SUBTYPE_PD_SINGLE_STD   0x02 // Photodiode sensor
			 SENSOR_SUBTYPE_PD_SINGLE_FSR   0x03 // Photodiode sensor with 
			                                        integrated filter
			                                        identified by position 
			 SENSOR_SUBTYPE_PD_SINGLE_STD_T 0x12 // Photodiode sensor with
			                                        temperature sensor
			Sensor Subtypes Thermopile:
			 SENSOR_SUBTYPE_THERMO_ADAPTER  0x01 // Thermopile adapter
			 SENSOR_SUBTYPE_THERMO_STD      0x02 // Thermopile sensor
			 SENSOR_SUBTYPE_THERMO_STD_T    0x12 // Thermopile sensor with 
			                                        temperature sensor
			Sensor Subtypes Pyroelectric Sensor:
			 SENSOR_SUBTYPE_PYRO_ADAPTER    0x01 // Pyroelectric adapter
			 SENSOR_SUBTYPE_PYRO_STD        0x02 // Pyroelectric sensor
			 SENSOR_SUBTYPE_PYRO_STD_T      0x12 // Pyroelectric sensor with
			                                        temperature sensor
			pFlags(c_int16 use with byref) : This parameter returns the flags of the connected sensor.
			
			Remark:
			The meanings of the obtained sensor flags are:
			
			Sensor Flags:
			 TLPM_SENS_FLAG_IS_POWER     0x0001 // Power sensor
			 TLPM_SENS_FLAG_IS_ENERGY    0x0002 // Energy sensor
			 TLPM_SENS_FLAG_IS_RESP_SET  0x0010 // Responsivity settable
			 TLPM_SENS_FLAG_IS_WAVEL_SET 0x0020 // Wavelength settable
			 TLPM_SENS_FLAG_IS_TAU_SET   0x0040 // Time constant settable
			 TLPM_SENS_FLAG_HAS_TEMP     0x0100 // With Temperature sensor
			channel(c_uint16) : Number if the channel. 
			
			Default: 1 for non multi channel devices
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getSensorInfo(self.devSession, name, snr, message, pType, pStype, pFlags, channel)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def writeRaw(self, command):
		"""
		This function writes directly to the instrument.
		
		Args:
			command(c_char_p) : Null terminated command string to send to the instrument.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_writeRaw(self.devSession, command)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def readRaw(self, buffer, size, returnCount):
		"""
		This function reads directly from the instrument.
		
		
		Args:
			buffer(create_string_buffer(1024)) : Byte buffer that receives the data read from the instrument.
			
			Notes:
			(1) If received data is less than buffer size, the buffer is additionaly terminated with a '' character.
			(2) If received data is same as buffer size no '' character is appended. Its the caller's responsibility to make sure a buffer is '' terminated if the caller wants to interprete the buffer as string.
			size(c_uint32) : This parameter specifies the buffer size.
			
			returnCount(c_uint32 use with byref) : Number of bytes actually transferred and filled into Buffer. This number doesn't count the additional termination '' character. If Return Count == size the buffer content will not be '' terminated.
			
			Notes:
			(1) You may pass VI_NULL if you don't need this value.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_readRaw(self.devSession, buffer, size, returnCount)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setTimeoutValue(self, value):
		"""
		This function sets the interface communication timeout value.
		
		Args:
			value(c_uint32) : This parameter specifies the communication timeout value in ms.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setTimeoutValue(self.devSession, value)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getTimeoutValue(self, value):
		"""
		This function gets the interface communication timeout value.
		
		
		Args:
			value(c_uint32 use with byref) : This parameter returns the communication timeout value in ms.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getTimeoutValue(self.devSession, value)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setIPAddress(self, IPAddress):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			IPAddress(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setIPAddress(self.devSession, IPAddress)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getIPAddress(self, IPAddress):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			IPAddress(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getIPAddress(self.devSession, IPAddress)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setIPMask(self, IPMask):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			IPMask(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setIPMask(self.devSession, IPMask)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getIPMask(self, IPMask):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			IPMask(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getIPMask(self.devSession, IPMask)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getMACAddress(self, MACAddress):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			MACAddress(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getMACAddress(self.devSession, MACAddress)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDHCP(self, DHCP):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			DHCP(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDHCP(self.devSession, DHCP)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDHCP(self, DHCP):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			DHCP(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDHCP(self.devSession, DHCP)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setHostname(self, hostname):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			hostname(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setHostname(self.devSession, hostname)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getHostname(self, hostname):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			hostname(create_string_buffer(1024)) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getHostname(self.devSession, hostname)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setWebPort(self, port):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			port(c_uint32) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setWebPort(self.devSession, port)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getWebPort(self, port):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			port(c_uint32 use with byref) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getWebPort(self.devSession, port)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setSCPIPort(self, port):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			port(c_uint32) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setSCPIPort(self.devSession, port)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getSCPIPort(self, port):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			port(c_uint32 use with byref) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getSCPIPort(self.devSession, port)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDFUPort(self, port):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			port(c_uint32) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDFUPort(self.devSession, port)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDFUPort(self, port):
		"""
		Tell the instrument which ip address the device has to commuicate with.
		This value is stored inside the instrument. 
		
		
		
		Args:
			port(c_uint32 use with byref) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDFUPort(self.devSession, port)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDeviceBaudrate(self, baudrate):
		"""
		Tell the instrument which baudrate has to be used for the serial communication.
		This value is stored inside the instrument. 
		
		If the RS232 interface is currently used for the communication, call the function setDriverBaudrate to adapt to the new baudrate.
		
		Args:
			baudrate(c_uint32) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDeviceBaudrate(self.devSession, baudrate)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDeviceBaudrate(self, baudrate):
		"""
		This function returns the baudrate that is used for the serial communication inside the instrument
		
		
		Args:
			baudrate(c_uint32 use with byref) : This parameter returns the baudrate in bist/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDeviceBaudrate(self.devSession, baudrate)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def setDriverBaudrate(self, baudrate):
		"""
		This function sets the baudrate for the serial interface on the PC side
		
		Args:
			baudrate(c_uint32) : This parameter specifies the baudrate in bits/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_setDriverBaudrate(self.devSession, baudrate)
		self.__testForError(pInvokeResult)
		return pInvokeResult

	def getDriverBaudrate(self, baudrate):
		"""
		This function returns the baudrate that is used for the serial communication on the PC side
		
		
		Args:
			baudrate(c_uint32 use with byref) : This parameter returns the baudrate in bist/sec.
			
		Returns:
			int: The return value, 0 is for success
		"""
		pInvokeResult = self.dll.TLPMX_getDriverBaudrate(self.devSession, baudrate)
		self.__testForError(pInvokeResult)
		return pInvokeResult




================================================
File: tests/__init__.py
================================================
from TLPMX import TLPMX, TLPM_DEFAULT_CHANNEL


================================================
File: tests/debug_thorlabs_devices.py
================================================
import clr
from pathlib import Path

try:
    dll_path = Path(__file__).parent.parent / "Thorlabs_DLL"
    clr.AddReference(str(dll_path / "Thorlabs.MotionControl.DeviceManagerCLI.dll"))
    clr.AddReference(str(dll_path / "Thorlabs.MotionControl.PolarizerCLI.dll"))
    from Thorlabs.MotionControl.DeviceManagerCLI import DeviceManagerCLI
    from Thorlabs.MotionControl.PolarizerCLI import Polarizer
    
    print("DLLs loaded successfully")
    
    print("Building device list...")
    DeviceManagerCLI.BuildDeviceList()
    
    device_list = DeviceManagerCLI.GetDeviceList()
    print(f"Found {len(device_list)} devices:")
    
    for i, device in enumerate(device_list):
        print(f"  Device {i}: {device}")
    
    polarizer_list = DeviceManagerCLI.GetDeviceList(Polarizer.DevicePrefix)
    print(f"\nFound {len(polarizer_list)} polarizer devices:")
    
    for i, device in enumerate(polarizer_list):
        print(f"  Polarizer {i}: {device}")
        
    target_serial = "38000001"  # From your main SOA_TESTING.py
    test_serial = "38487984"    # From the test file
    
    print(f"\nChecking for target serial numbers:")
    print(f"  Main config serial ({target_serial}): {'FOUND' if target_serial in device_list else 'NOT FOUND'}")
    print(f"  Test file serial ({test_serial}): {'FOUND' if test_serial in device_list else 'NOT FOUND'}")
    
    if len(polarizer_list) > 0:
        print(f"\nRecommendation: Use serial number '{polarizer_list[0]}' in your test")
    else:
        print("\nNo polarizer devices found. Check USB connections!")
        
except Exception as e:
    print(f"Error: {e}")
    import traceback
    traceback.print_exc()


================================================
File: tests/test_smu.py
================================================
"""
SMU Test Script - Aim-TTi SMU4000 Series
Test script for debugging and validating SMU communication and functionality.
"""

import sys
import os
import time
from datetime import datetime

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from drivers.smu import AimTTi_SMU4000

def test_smu_connection(address: str, unit_id: str = "SMU_TEST"):
    """Test basic SMU connection and identification"""
    print(f"\n{'='*60}")
    print(f"TESTING SMU CONNECTION: {unit_id}")
    print(f"Address: {address}")
    print(f"{'='*60}")
    
    try:
        smu = AimTTi_SMU4000(address, unit_id)
        print("SUCCESS: SMU connection established")
        
        idn = smu.get_idn()
        print(f"Identification: {idn}")
        
        errors = smu.get_errors()
        if errors:
            print(f"Initial errors found: {len(errors)}")
            for error in errors:
                print(f"  - {error}")
            smu.clear_errors()
            print("Errors cleared")
        else:
            print("No initial errors")
        
        smu.disconnect()
        return True
        
    except Exception as e:
        print(f"FAILED: SMU connection failed - {e}")
        return False

def test_smu_basic_functions(address: str, unit_id: str = "SMU_TEST"):
    """Test basic SMU functions without enabling output"""
    print(f"\n{'='*60}")
    print(f"TESTING SMU BASIC FUNCTIONS: {unit_id}")
    print(f"{'='*60}")
    
    try:
        smu = AimTTi_SMU4000(address, unit_id)
        
        print("\nTesting voltage source mode...")
        smu.set_mode_source_voltage()
        mode = smu.get_source_mode()
        print(f"Current mode: {mode}")
        
        print("\nTesting current source mode...")
        smu.set_mode_source_current()
        mode = smu.get_source_mode()
        print(f"Current mode: {mode}")
        
        output_state = smu.get_output_state()
        print(f"\nOutput enabled: {output_state}")
        if output_state:
            print("WARNING: Output is enabled - disabling for safety")
            smu.enable_output(False)
        
        print("\nTesting measurements (output disabled)...")
        voltage = smu.measure_voltage()
        current = smu.measure_current()
        power = smu.measure_power()
        
        print(f"Measured voltage: {voltage:.6f} V")
        print(f"Measured current: {current:.9f} A")  
        print(f"Measured power: {power:.9f} W")
        
        print("\nGetting comprehensive status...")
        status = smu.get_status()
        print("Status information:")
        for key, value in status.items():
            print(f"  {key}: {value}")
        
        smu.disconnect()
        print("\nSUCCESS: Basic function tests completed")
        return True
        
    except Exception as e:
        print(f"FAILED: Basic function test failed - {e}")
        return False

def test_smu_safe_output(address: str, unit_id: str = "SMU_TEST"):
    """Test SMU output with safe parameters"""
    print(f"\n{'='*60}")
    print(f"TESTING SMU SAFE OUTPUT: {unit_id}")
    print(f"{'='*60}")
    
    print("WARNING: This test will briefly enable SMU output with safe parameters")
    print("Make sure no device is connected or use appropriate safety measures")
    
    confirm = input("Continue with output test? (y/n): ").strip().lower()
    if confirm not in ['y', 'yes']:
        print("Output test skipped")
        return True
    
    try:
        smu = AimTTi_SMU4000(address, unit_id)
        
        print("\nConfiguring voltage source mode...")
        smu.set_mode_source_voltage()
        
        print("Setting safe parameters: 1V, 1mA limit")
        
        print("Enabling output for 2 seconds...")
        smu.enable_output(True)
        time.sleep(0.5)
        
        voltage = smu.measure_voltage()
        current = smu.measure_current()
        power = smu.measure_power()
        
        print(f"Output voltage: {voltage:.6f} V")
        print(f"Output current: {current:.9f} A")
        print(f"Output power: {power:.9f} W")
        
        time.sleep(1.5)
        
        print("Disabling output...")
        smu.enable_output(False)
        
        output_state = smu.get_output_state()
        print(f"Output disabled: {not output_state}")
        
        smu.disconnect()
        print("\nSUCCESS: Safe output test completed")
        return True
        
    except Exception as e:
        print(f"FAILED: Safe output test failed - {e}")
        return False

def test_smu_error_handling(address: str, unit_id: str = "SMU_TEST"):
    """Test SMU error handling capabilities"""
    print(f"\n{'='*60}")
    print(f"TESTING SMU ERROR HANDLING: {unit_id}")
    print(f"{'='*60}")
    
    try:
        smu = AimTTi_SMU4000(address, unit_id)
        
        smu.clear_errors()
        
        errors = smu.get_errors()
        print(f"Errors after clear: {len(errors)}")
        
        print("\nTesting error detection...")
        try:
            response = smu.query("INVALID:COMMAND?")
            print(f"Unexpected response to invalid command: {response}")
        except:
            print("Expected error from invalid command")
        
        errors = smu.get_errors()
        if errors:
            print(f"Detected {len(errors)} errors:")
            for i, error in enumerate(errors):
                print(f"  {i+1}. {error}")
            smu.clear_errors()
            print("Errors cleared")
        else:
            print("No errors detected")
        
        smu.disconnect()
        print("\nSUCCESS: Error handling test completed")
        return True
        
    except Exception as e:
        print(f"FAILED: Error handling test failed - {e}")
        return False

def run_comprehensive_smu_test():
    """Run comprehensive SMU testing"""
    print("SMU COMPREHENSIVE TEST SUITE")
    print("=" * 80)
    print(f"Test started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    test_configs = [
        {"address": "TCPIP::10.11.83.58::INSTR", "unit_id": "SMU1"},
        {"address": "TCPIP::10.11.83.60::INSTR", "unit_id": "SMU2"},
    ]
    
    all_results = []
    
    for config in test_configs:
        address = config["address"]
        unit_id = config["unit_id"]
        
        print(f"\n\nTESTING SMU: {unit_id}")
        print(f"Address: {address}")
        
        result1 = test_smu_connection(address, unit_id)
        
        result2 = False
        if result1:
            result2 = test_smu_basic_functions(address, unit_id)
        
        result3 = False
        if result2:
            result3 = test_smu_error_handling(address, unit_id)
        
        result4 = False
        if result2:
            result4 = test_smu_safe_output(address, unit_id)
        
        all_results.append({
            "unit_id": unit_id,
            "address": address,
            "connection": result1,
            "basic_functions": result2,
            "error_handling": result3,
            "safe_output": result4
        })
    
    print(f"\n\n{'='*80}")
    print("TEST SUMMARY")
    print(f"{'='*80}")
    
    for result in all_results:
        print(f"\n{result['unit_id']} ({result['address']}):")
        print(f"  Connection:      {'PASS' if result['connection'] else 'FAIL'}")
        print(f"  Basic Functions: {'PASS' if result['basic_functions'] else 'FAIL'}")
        print(f"  Error Handling:  {'PASS' if result['error_handling'] else 'FAIL'}")
        print(f"  Safe Output:     {'PASS' if result['safe_output'] else 'SKIP'}")
    
    total_tests = len(all_results)
    passed_connections = sum(1 for r in all_results if r['connection'])
    
    print(f"\nOVERALL RESULTS:")
    print(f"Total SMUs tested: {total_tests}")
    print(f"Successful connections: {passed_connections}")
    
    if passed_connections == total_tests:
        print("STATUS: All SMUs operational")
    else:
        print(f"STATUS: {total_tests - passed_connections} SMU(s) have connection issues")

def main():
    """Main test execution"""
    if len(sys.argv) > 1:
        address = sys.argv[1]
        unit_id = sys.argv[2] if len(sys.argv) > 2 else "SMU_MANUAL"
        
        print("SINGLE SMU TEST MODE")
        print(f"Address: {address}")
        print(f"Unit ID: {unit_id}")
        
        test_smu_connection(address, unit_id)
        test_smu_basic_functions(address, unit_id)
        test_smu_error_handling(address, unit_id)
        test_smu_safe_output(address, unit_id)
    else:
        run_comprehensive_smu_test()

if __name__ == "__main__":
    main()


================================================
File: tests/test_thorlabs_pm.py
================================================

"""
This script combines two approaches for controlling a Thorlabs Power Meter.

It uses the Thorlabs-provided TLPMX driver library via Python's ctypes module
for direct instrument communication (as seen in the first user-provided script).
This direct method can be more reliable than generic VISA commands.

The script is structured into a user-friendly class, `ThorlabsPowerMeter`,
with methods for configuration and continuous power reading (inspired by the
second user-provided pyvisa script).

This provides the robust connection of the first script with the cleaner
structure and functionality of the second.
"""

import time
import numpy as np
from ctypes import cdll, byref, create_string_buffer, c_bool, c_int16, c_double, c_char_p
from TLPMX import TLPMX
from TLPMX import TLPM_DEFAULT_CHANNEL

class ThorlabsPowerMeter:
    """
    A class to control Thorlabs power meters using the TLPMX driver.
    """
    def __init__(self, visa_id: str):
        """
        Initializes the power meter and establishes a connection.

        Args:
            visa_id (str): The VISA resource string for the instrument.
                           e.g., "USB0::0x1313::0x8076::M01230612::0::INSTR"
        """
        self.visa_id = visa_id
        self.instrument_handle = None
        self.is_open = False
        self.last_cal_msg = ""
        self.wavelength = 0.0

        try:
            self.instrument_handle = TLPMX()
            
            resource_name_c = self.visa_id.encode('ascii')

            self.instrument_handle.open(resource_name_c, c_bool(True), c_bool(True))
            self.is_open = True
            
            self.instrument_handle.setPowerUnit(c_int16(0), TLPM_DEFAULT_CHANNEL)
            
            self.instrument_handle.setPowerAutoRange(c_int16(1), TLPM_DEFAULT_CHANNEL)
            
            cmsg = create_string_buffer(128) # Increased buffer size for safety
            self.instrument_handle.getCalibrationMsg(cmsg, TLPM_DEFAULT_CHANNEL)
            self.last_cal_msg = cmsg.value.decode('utf-8')

        except Exception as e:
            if self.is_open:
                self.disconnect()
            raise ConnectionError(f"Could not connect to or configure Power Meter: {e}")

    def get_id(self) -> str:
        """
        Retrieves identifying information from the power meter.

        Returns:
            str: A string containing the manufacturer, model, and serial number.
        """
        if not self.is_open:
            return "Device not connected."
            
        try:
            model_name = create_string_buffer(128)
            serial_number = create_string_buffer(128)
            manufacturer = create_string_buffer(128)
            
            dummy_bool = c_bool(False)

            self.instrument_handle.getDevInfo(model_name, serial_number, manufacturer, byref(dummy_bool))
            
            return (f"Manufacturer: {manufacturer.value.decode('utf-8')}, "
                    f"Model: {model_name.value.decode('utf-8')}, "
                    f"S/N: {serial_number.value.decode('utf-8')}")
        except Exception as e:
            return f"Error retrieving ID: {e}"

    def configure(self, wavelength: int):
        """
        Configures the power meter for a specific wavelength.

        Args:
            wavelength (int): The wavelength to measure in nanometers (e.g., 1310).
        """
        if not self.is_open:
            print("Cannot configure, device not connected.")
            return

        try:
            self.wavelength = float(wavelength)
            self.instrument_handle.setWavelength(c_double(self.wavelength), TLPM_DEFAULT_CHANNEL)
            print(f"Configured for {wavelength} nm.")
        except Exception as e:
            print(f"Error setting wavelength: {e}")

    def read_power_w(self) -> float:
        """
        Measures and returns the current power reading in Watts.

        Returns:
            float: The power reading in Watts. Returns 0.0 on error.
        """
        if not self.is_open:
            return 0.0
            
        try:
            power_c = c_double()
            self.instrument_handle.measPower(byref(power_c), TLPM_DEFAULT_CHANNEL)
            return power_c.value
        except Exception as e:
            print(f"Error reading power: {e}")
            return 0.0

    def read_power_dbm(self) -> float:
        """
        Measures power in Watts and converts it to dBm.

        Returns:
            float: The power reading in dBm. Returns a very low number on error or zero power.
        """
        power_w = self.read_power_w()
        if power_w > 0:
            return 10 * np.log10(power_w * 1000)
        else:
            return -999.0

    def disconnect(self):
        """
        Closes the connection to the power meter.
        """
        if self.is_open and self.instrument_handle:
            try:
                self.instrument_handle.close()
                self.is_open = False
                print("\nDisconnected from Power Meter.")
            except Exception as e:
                print(f"Error during disconnection: {e}")


def main():
    """
    Main function to run the power meter reading loop.
    """
    POWER_METER_VISA_ID = "USB0::0x1313::0x8076::M01230612::0::INSTR"
    WAVELENGTH_NM = 1310

    pm = None
    try:
        pm = ThorlabsPowerMeter(POWER_METER_VISA_ID)
        print(f"Successfully connected to device.")
        print(f"ID: {pm.get_id()}")
        print(f"Sensor Cal Message: {pm.last_cal_msg}")
        
        pm.configure(WAVELENGTH_NM)

        print("\nContinuously reading power. Press Ctrl+C to exit.")
        while True:
            power_w = pm.read_power_w()
            power_dbm = 10 * np.log10(power_w * 1000) if power_w > 0 else -999.0
            
            print(f"Power: {power_w:.4e} W  ({power_dbm:.2f} dBm)   \r", end="")
            
            time.sleep(0.5)

    except ConnectionError as e:
        print(f"Connection Failed: {e}")
        print("Please ensure the VISA ID is correct and the device is connected.")
    except KeyboardInterrupt:
        print("\nStopping power reading.")
    except Exception as e:
        print(f"\nAn unexpected error occurred: {e}")
    finally:
        if pm:
            pm.disconnect()

if __name__ == "__main__":
    main()



================================================
File: utils/recorder.py
================================================

import logging
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import pathlib
import time
import json
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional, Tuple, Union
from dataclasses import dataclass
import warnings

warnings.filterwarnings('ignore', category=UserWarning, module='matplotlib')


@dataclass
class PlotConfig:
    """Configuration for plot generation."""
    plot_type: str = "line"
    figsize: Tuple[int, int] = (12, 6)
    dpi: int = 150
    linewidth: float = 1.5
    alpha: float = 0.7
    grid: bool = True


@dataclass
class DataConfig:
    """Configuration for data handling and processing."""
    auto_detect_types: bool = True
    handle_missing: str = "fill"  # Options: 'fill', 'drop', 'interpolate'
    numeric_precision: int = 6
    encoding: str = "utf-8"


class UniversalRecorder:
    """
    A comprehensive recorder for test and measurement data.

    This class handles the creation of a structured directory system for test runs,
    data processing, plotting, and metadata generation.
    """
    def __init__(
        self,
        top_dir: str,
        plot_config: Optional[PlotConfig] = None,
        data_config: Optional[DataConfig] = None
    ) -> None:
        """
        Initializes the recorder.

        Args:
            top_dir (str): The root directory where all test data will be stored.
            plot_config (Optional[PlotConfig]): Configuration for plots.
            data_config (Optional[DataConfig]): Configuration for data handling.
        """
        self.top_dir = pathlib.Path(top_dir)
        self.plot_config = plot_config or PlotConfig()
        self.data_config = data_config or DataConfig()
        self._setup_directories()
        
        self.run_dir: pathlib.Path | str = ""
        self.phase_dir: pathlib.Path | str = ""
        self.cwd: pathlib.Path = self.top_dir
        
        self.current_run_info: Dict[str, Any] = {}

    def _setup_directories(self) -> None:
        """Creates the top-level directory if it doesn't exist."""
        self.top_dir.mkdir(parents=True, exist_ok=True)

    def _convert_to_dataframe(self, data: Any, headers: Optional[List[str]] = None) -> pd.DataFrame:
        """
        Converts various data types into a pandas DataFrame.
        Supports file paths (CSV, TXT), pandas DataFrames, numpy arrays,
        dictionaries, and lists/tuples.
        """
        if isinstance(data, (str, pathlib.Path)):
            path = pathlib.Path(data)
            if path.exists() and path.is_file():
                ext = path.suffix.lower()
                if ext == '.csv':
                    return pd.read_csv(path, encoding=self.data_config.encoding)
                elif ext == '.txt':
                    return self._parse_txt_file(path)
                else: # Treat as a generic text file with one column
                    with open(path, 'r', encoding=self.data_config.encoding) as f:
                        lines = [line.rstrip('\n') for line in f]
                    return pd.DataFrame(lines, columns=['value'])

        if isinstance(data, pd.DataFrame):
            return data.copy()
        elif isinstance(data, np.ndarray):
            df = pd.DataFrame(data)
            if headers and len(headers) == df.shape[1]:
                df.columns = headers
            return df
        elif isinstance(data, dict):
            return pd.DataFrame([data]) if not all(isinstance(v, (list, tuple)) for v in data.values()) else pd.DataFrame(data)
        elif isinstance(data, (list, tuple)):
            if not data:
                return pd.DataFrame()
            if isinstance(data[0], dict):
                return pd.DataFrame(data)
            elif isinstance(data[0], (list, tuple)):
                df = pd.DataFrame(data)
                if headers and len(headers) == df.shape[1]:
                    df.columns = headers
                return df
            else: # List of scalars
                return pd.DataFrame(data, columns=['value'])
        else: # Treat as a single scalar value
            return pd.DataFrame([data], columns=['value'])

    def _parse_txt_file(self, path: pathlib.Path) -> pd.DataFrame:
        """Parses a space- or tab-delimited text file into a DataFrame."""
        with open(path, 'r', encoding=self.data_config.encoding) as f:
            raw_lines = [line.rstrip('\n') for line in f]

        lines = [line for line in raw_lines if line.strip() and not line.lstrip().startswith('#')]
        if not lines:
            return pd.DataFrame()

        first_tokens = lines[0].strip().split()
        header_detected = any(not self._is_numeric(token) for token in first_tokens)
        
        if header_detected:
            headers = first_tokens
            data_lines = lines[1:]
        else:
            headers = None
            data_lines = lines

        data_rows = [line.strip().split() for line in data_lines]
        if not data_rows:
            return pd.DataFrame()

        max_cols = max(len(row) for row in data_rows)
        padded_rows = [row + [np.nan] * (max_cols - len(row)) for row in data_rows]
        
        df = pd.DataFrame(padded_rows)
        
        if headers and len(headers) == df.shape[1]:
            df.columns = headers
        else:
            df.columns = [f"col_{i}" for i in range(max_cols)]

        for col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce')

        return df

    def _is_numeric(self, value: str) -> bool:
        """Helper to check if a string can be cast to a float."""
        try:
            float(value)
            return True
        except (ValueError, TypeError):
            return False

    def _process_dataframe(self, df: pd.DataFrame) -> pd.DataFrame:
        """Applies data cleaning steps based on DataConfig."""
        df = df.copy()
        
        if self.data_config.handle_missing == "drop":
            df = df.dropna()
        elif self.data_config.handle_missing == "fill":
            for col in df.columns:
                if pd.api.types.is_numeric_dtype(df[col]):
                    df[col] = df[col].fillna(df[col].mean())
                else:
                    mode_val = df[col].mode()
                    fill_val = mode_val.iloc[0] if not mode_val.empty else 'Unknown'
                    df[col] = df[col].fillna(fill_val)
        elif self.data_config.handle_missing == "interpolate":
            for col in df.columns:
                if pd.api.types.is_numeric_dtype(df[col]):
                    df[col] = df[col].interpolate()

        if self.data_config.auto_detect_types:
            for col in df.columns:
                if df[col].dtype == 'object':
                    numeric_series = pd.to_numeric(df[col], errors='coerce')
                    if not numeric_series.isna().all():
                        df[col] = numeric_series
        return df

    def test_run_start(
        self,
        workstation: str,
        dut_family: str,
        dut_batch: str,
        dut_lot: str,
        dut_wafer: str,
        dut_id: str,
        run_set_id: int = 1,
        run_id: int = 1
    ) -> bool:
        """
        Starts a new test run, creating the required directory structure.
        """
        self.run_end()
        
        timestamp = time.strftime("%Y%m%d_%H%M%S", time.localtime())
        run_dir_name = f"{dut_id}_{timestamp}_S{run_set_id}_RUN{run_id:04d}"
        
        full_path = (
            self.top_dir
            / workstation
            / dut_family
            / dut_batch
            / dut_lot
            / dut_wafer
            / dut_id
            / run_dir_name
        )
        
        try:
            full_path.mkdir(parents=True, exist_ok=True)
            self.run_dir = full_path
            self.cwd = self.run_dir
            
            self.current_run_info = {
                'workstation': workstation,
                'dut_family': dut_family,
                'dut_batch': dut_batch,
                'dut_lot': dut_lot,
                'dut_wafer': dut_wafer,
                'dut_id': dut_id,
                'run_set_id': str(run_set_id),
                'run_id': str(run_id)
            }
            
            logging.info(f'TEST_RUN_START: {dut_id} run {run_id} at {self.run_dir}')
            return True
        except Exception as e:
            logging.error(f'Failed to create run directory {full_path}: {e}')
            return False

    def run_end(self):
        """Ends the current test run."""
        self.phase_end()
        if self.run_dir:
            logging.info(f'RUN_END')
            self.cwd = self.top_dir
            self.run_dir = ""
            self.current_run_info = {}

    def phase_start(self, phase_idx: int, phase_name: str) -> bool:
        """Starts a new phase within the current test run."""
        self.phase_end()
        if not self.run_dir:
            logging.error("No active run. Cannot start a phase.")
            return False
            
        phase_dir = self.run_dir / f"{phase_idx:04d}_{phase_name}"
        try:
            phase_dir.mkdir(parents=True, exist_ok=True)
            self.phase_dir = phase_dir
            self.cwd = self.phase_dir
            logging.info(f'PHASE_START: {phase_idx} - {phase_name}')
            return True
        except Exception as e:
            logging.error(f'Failed to create phase directory: {e}')
            return False

    def phase_end(self):
        """Ends the current phase."""
        if self.phase_dir:
            logging.info(f'PHASE_END')
            self.cwd = self.run_dir if self.run_dir else self.top_dir
            self.phase_dir = ""

    def create_plot(
        self,
        name: str,
        x_data: Union[List, np.ndarray, pd.Series],
        y_data: Union[List, np.ndarray, pd.Series],
        title: str = "",
        xlabel: str = "",
        ylabel: str = "",
        plot_config: Optional[PlotConfig] = None
    ) -> Optional[pathlib.Path]:
        """Creates and saves a single plot."""
        config = plot_config or self.plot_config
        
        try:
            fig, ax = plt.subplots(figsize=config.figsize)
            
            if config.plot_type == "line":
                ax.plot(x_data, y_data, linewidth=config.linewidth, alpha=config.alpha)
            else:
                ax.scatter(x_data, y_data, alpha=config.alpha)

            ax.set_title(title or "Data Plot", fontsize=12)
            ax.set_xlabel(xlabel, fontsize=10)
            ax.set_ylabel(ylabel, fontsize=10)
            
            if config.grid:
                ax.grid(True, alpha=0.3)

            filepath = self.cwd / f"{name}.png"
            fig.savefig(filepath, dpi=config.dpi, bbox_inches='tight')
            plt.close(fig)
            
            logging.info(f'Saved plot: {filepath}')
            return filepath
        except Exception as e:
            logging.error(f'Failed to create plot: {e}')
            return None

    def _generate_basic_statistics(self, df: pd.DataFrame) -> Dict:
        """Helper to generate descriptive statistics for numeric columns."""
        stats = {}
        try:
            numeric_cols = df.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                desc = df[numeric_cols].describe()
                for col in numeric_cols:
                    stats[col] = {
                        "count": float(desc.loc['count', col]),
                        "mean": float(desc.loc['mean', col]),
                        "std": float(desc.loc['std', col]),
                        "min": float(desc.loc['min', col]),
                        "25%": float(desc.loc['25%', col]),
                        "50%": float(desc.loc['50%', col]),
                        "75%": float(desc.loc['75%', col]),
                        "max": float(desc.loc['max', col])
                    }
        except Exception as e:
            logging.warning(f"Could not generate statistics: {e}")
        return stats

    def _get_relative_path(self, filepath: pathlib.Path) -> str:
        """Gets the path of a file relative to the top_dir."""
        try:
            return filepath.relative_to(self.top_dir).as_posix()
        except ValueError:
            return str(filepath)

    def record_complete_dataset(
        self,
        name: str,
        data: Any,
        test_info: Dict,
        environment_info: Dict,
        *,
        column_names: Optional[List[str]] = None,
        testing_variable: Optional[Union[int, str]] = None,
        dependent_variables: Optional[List[Union[int, str]]] = None,
        headers: Optional[List[str]] = None,
        plot_config: Optional[PlotConfig] = None,
        parameters: Optional[Dict] = None,
        equipment_ids: Optional[str] = None,
        dut_fab: Optional[str] = None,
        dut_subchip_id: Optional[str] = None,
        dut_subcomponent_id: Optional[str] = None,
        script_version: Optional[str] = None,
        comments: Optional[str] = None,
        **csv_kwargs
    ) -> Optional[Dict]:
        """
        Records a complete dataset, including CSV, plots, and metadata.

        This is the main public method for recording data. It orchestrates
        data conversion, cleaning, saving, plotting, and metadata generation.
        """
        try:
            required_test_fields = ["test_name", "test_location", "test_user"]
            required_env_fields = ["environment_temp", "environment_humidity"]
            
            for field in required_test_fields:
                if field not in test_info:
                    raise ValueError(f"Required test_info field '{field}' is missing")
            
            for field in required_env_fields:
                if field not in environment_info:
                    raise ValueError(f"Required environment_info field '{field}' is missing")

            df = self._convert_to_dataframe(data, headers)
            
            if column_names:
                if len(column_names) != df.shape[1]:
                    raise ValueError(f"column_names length ({len(column_names)}) doesn't match DataFrame columns ({df.shape[1]})")
                df.columns = column_names
            
            df = self._process_dataframe(df)

            csv_path = self.cwd / f"{name}.csv"
            csv_params = {
                'index': False,
                'encoding': self.data_config.encoding,
                'float_format': f'%.{self.data_config.numeric_precision}g'
            }
            csv_params.update(csv_kwargs)
            df.to_csv(csv_path, **csv_params)
            logging.info(f'Saved CSV: {csv_path}')

            if df.empty:
                x_col, y_cols = None, []
            elif testing_variable is None:
                x_col = df.columns[0]
            else:
                try:
                    x_idx = int(testing_variable)
                    x_col = df.columns[x_idx]
                except (ValueError, IndexError):
                    x_col = str(testing_variable)
                    if x_col not in df.columns:
                        raise ValueError(f"Testing variable '{testing_variable}' not found in DataFrame columns.")

            if df.empty:
                y_cols = []
            elif dependent_variables is None:
                y_cols = [col for col in df.columns if col != x_col]
            else:
                y_cols = []
                for dv in dependent_variables:
                    try:
                        y_idx = int(dv)
                        y_col = df.columns[y_idx]
                    except (ValueError, IndexError):
                        y_col = str(dv)
                        if y_col not in df.columns:
                            raise ValueError(f"Dependent variable '{dv}' not found in DataFrame columns.")
                    y_cols.append(y_col)

            plot_files = []
            if x_col:
                for y_col in y_cols:
                    plot_name = f"{name}_{x_col}_vs_{y_col}"
                    plot_path = self.create_plot(
                        name=plot_name,
                        x_data=df[x_col],
                        y_data=df[y_col],
                        title=f"{y_col} vs {x_col}",
                        xlabel=x_col,
                        ylabel=y_col,
                        plot_config=plot_config
                    )
                    
                    if plot_path:
                        plot_files.append({
                            "filename": f"{plot_name}.png",
                            "relative_path": self._get_relative_path(plot_path),
                            "type": "image_png",
                            "tab_name": plot_name.replace("_", " ")
                        })
            
            metadata = {
                "test_location": test_info["test_location"],
                "test_user": test_info["test_user"],
                "test_name": test_info["test_name"],
                
                **self.current_run_info,
                
                "dut_fab": dut_fab,
                "dut_subchip_id": dut_subchip_id,
                "dut_subcomponent_id": dut_subcomponent_id,
                
                "equipment_ids": equipment_ids,
                "testing_variable_ids": x_col if x_col else None,
                "dependent_variable_ids": ", ".join(y_cols) if y_cols else None,
                
                "environment_temp": environment_info["environment_temp"],
                "environment_humidity": environment_info["environment_humidity"],
                
                "script_version": script_version,
                "comments": comments,
                
                "timestamp_generated_utc": datetime.now(timezone.utc).isoformat(),
                "data_preview": df.head(5).to_dict('records') if not df.empty else [],
                "basic_statistics": self._generate_basic_statistics(df),
                "csv_relative_path": self._get_relative_path(csv_path),
                
                "plot_files": plot_files,
                "sql_table_name": None,
                "sql_relative_path": None,
                "nd_data_tables": [],
                
                "parameters": parameters or {}
            }

            metadata_path = self.cwd / "metadata.json"
            with open(metadata_path, 'w', encoding='utf-8') as f:
                json.dump(metadata, f, indent=2)
            logging.info(f'Saved metadata: {metadata_path}')

            return {
                'csv_path': csv_path,
                'dataframe': df,
                'plot_files': plot_files,
                'metadata_path': metadata_path,
                'metadata': metadata
            }

        except Exception as e:
            logging.error(f'Failed to record dataset "{name}": {e}', exc_info=True)
            return None


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(levelname)s: %(message)s')
    
    data_config = DataConfig(
        auto_detect_types=True,
        handle_missing="interpolate",
        numeric_precision=4,
        encoding="utf-8"
    )
    
    plot_config = PlotConfig(
        plot_type="line",
        figsize=(14, 8),
        dpi=200,
        linewidth=2.0,
        alpha=0.8,
        grid=True
    )
    
    recorder = UniversalRecorder(
        top_dir='./test_output_demo',
        plot_config=plot_config,
        data_config=data_config
    )
    
    recorder.test_run_start(
        workstation='Autotester2',
        dut_family='SL6', 
        dut_batch='DemoBatch',
        dut_lot='DemoLot',
        dut_wafer='W01C1',
        dut_id='R1C1',
        run_set_id=1,
        run_id=1
    )
    
    recorder.phase_start(1, "Numpy_Data_Test")
    
    x_np = np.linspace(0, 2 * np.pi, 100)
    y_np = np.sin(x_np) + np.random.normal(0, 0.1, 100)
    numpy_data = np.column_stack([x_np, y_np])
    
    test_info = {"test_name": "SineWaveTest", "test_location": "Lab A", "test_user": "demo_user"}
    env_info = {"environment_temp": 25.0, "environment_humidity": 45.0}

    result1 = recorder.record_complete_dataset(
        name='sine_wave_data',
        data=numpy_data,
        test_info=test_info,
        environment_info=env_info,
        column_names=["Angle_rad", "Amplitude_V"],
        testing_variable="Angle_rad",
        dependent_variables=["Amplitude_V"],
        script_version="v1.1",
        comments="This is a test with numpy data."
    )
    if result1:
        print("Successfully recorded numpy dataset.")
    
    recorder.phase_end()
    
    recorder.phase_start(2, "Text_File_Test")

    dummy_txt_content = """# My Test Data File
1549.5  -10.1
1550.0  -9.8
1550.5  -9.9
1551.0  -10.3
1551.5  -11.0
"""
    dummy_txt_path = recorder.cwd / "sample_data.txt"
    with open(dummy_txt_path, "w") as f:
        f.write(dummy_txt_content)
        
    result2 = recorder.record_complete_dataset(
        name='optical_spectrum',
        data=str(dummy_txt_path), # Pass the path as a string
        test_info=test_info,
        environment_info=env_info,
        headers=["Wavelength_nm", "Power_dBm"],
        script_version="v1.1",
        comments="Data loaded from a text file."
    )
    if result2:
        print("Successfully recorded text file dataset.")

    recorder.phase_end()
    
    recorder.run_end()


